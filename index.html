<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Alex&apos;s personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex Chiu">
<meta property="og:url" content="http://AlexanderChiuluvB.github.io/index.html">
<meta property="og:site_name" content="Alex Chiu">
<meta property="og:description" content="Alex&apos;s personal blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex Chiu">
<meta name="twitter:description" content="Alex&apos;s personal blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://AlexanderChiuluvB.github.io/"/>





  <title>Alex Chiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex Chiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/15/CSAPP-proxy-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/15/CSAPP-proxy-lab/" itemprop="url">CSAPP-proxy lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-15T21:43:43+08:00">
                2018-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Implementing-a-sequential-web-proxy"><a href="#Implementing-a-sequential-web-proxy" class="headerlink" title="Implementing a sequential web proxy"></a>Implementing a sequential web proxy</h3><p>先搞清listen socket 和 connected socket 的区别。</p>
<p><img src="/home/alex/图片/taojiezidui.png" alt="upload succful"></p>
<p>一个套接字对标记着一个客户端和服务器的链接。</p>
<p>客户端是发起连接请求的主动实体，而内核会认为socket函数创建的套接字是主动套接字，而服务器就是要调用listen函数告诉内核，该套接字是被服务器而不是客户端使用的，即listen函数将一个主动套接字转化为<strong><em>监听套接字</em></strong>。</p>
<p>服务器通过accept函数等待来自客户端的连接请求到达监听套接字，并返回一个<strong><em>已连接套接字</em></strong>，这个connfd可以被用来与客户端进行通讯。</p>
<p>实验过程如下：</p>
<p><img src="/home/alex/图片/实验过程.png" alt="upload successful"></p>
<h4 id="some-def"><a href="#some-def" class="headerlink" title="some def"></a>some def</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* You won&apos;t lose style points for including this long line in your code */</span><br><span class="line">static const char *user_agent_hdr = &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;;</span><br><span class="line">static const char *conn_hdr = &quot;Connection: close\r\n&quot;;</span><br><span class="line">static const char *prox_hdr = &quot;Proxy-Connection: close\r\n&quot;;</span><br><span class="line">static const char *hostFormat = &quot;Host: %s\r\n&quot;;</span><br><span class="line">static const char *requestHeaderFormat = &quot;GET %s HTTP/1.0\r\n&quot;;</span><br><span class="line">static const char *endof_hdr = &quot;\r\n&quot;;</span><br><span class="line">static const char *connection_key = &quot;Connection&quot;;</span><br><span class="line">static const char *user_agent_key= &quot;User-Agent&quot;;</span><br><span class="line">static const char *proxy_connection_key = &quot;Proxy-Connection&quot;;</span><br><span class="line">static const char *hostKey = &quot;Host&quot;;</span><br><span class="line"></span><br><span class="line">void doit(int fd);</span><br><span class="line">void parse_uri(char *uri,char *hostname,char *path,int *port);</span><br><span class="line">void buildHTTPHeader(char *http_header,char *hostname,char *path,int port,rio_t *client_rio);</span><br><span class="line">int connectEndServer(char *hostname,int port,char *httpHeader);</span><br><span class="line">void *thread(void *vargp);</span><br><span class="line">void initCache();</span><br><span class="line">int reader(int fd,char *uri);</span><br><span class="line">void writer(char *uri,char *buf);</span><br><span class="line">//reference: https://zhuanlan.zhihu.com/p/37902495</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char *buf;</span><br><span class="line">    char *uri;</span><br><span class="line">&#125;cacheLine;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    cacheLine* objects;</span><br><span class="line">    int count;</span><br><span class="line">&#125;Cache;</span><br><span class="line"></span><br><span class="line">Cache cache;</span><br><span class="line">int readCount;</span><br><span class="line">sem_t mutex,wmutex;</span><br><span class="line">//用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制</span><br></pre></td></tr></table></figure>
<p>main 函数，参考课本的tiny服务器，注意的是这里pthread_create是传值而不是引用，是为了避免竞争。（传值是传一个独立的副本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int listenfd,connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    char hostname[MAXLINE];</span><br><span class="line">    char port[MAXLINE];</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    if(argc!=2)&#123;</span><br><span class="line">        fprintf(stderr,&quot;usage %s &lt;port&gt;\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    initCache();</span><br><span class="line">    //ignore the SIGPIPE signal</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    //transfrom the fd to listenfd</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        clientlen = sizeof(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">        //ip-&gt;host name</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr,clientlen,hostname,MAXLINE,port,MAXLINE,0);</span><br><span class="line">        printf(&quot;Accepted connection from (%s %s)\n&quot;,hostname,port);</span><br><span class="line">        //pass value of connfd to create function to avoid competition</span><br><span class="line">        Pthread_create(&amp;tid,NULL,thread,(void*)connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void *thread(void *vargp)&#123;</span><br><span class="line">    int connfd = (int)vargp;</span><br><span class="line">    //要把线程分离出去，让这个线程计数结束之后自己回收资源，避免内存泄露。</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    doit(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doit"><a href="#doit" class="headerlink" title="doit"></a>doit</h3><p>函数逻辑：</p>
<p>1.得到解析后的请求行和请求头</p>
<p>2.然后去连接对应的服务器，发送请求</p>
<p>3.建立连接后，返回信息会在描述符中，也就是endServerFd</p>
<p>4.再把信息从endServerFd中读取出来，直接写进客户端对应的描述符fd就可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//对客户端请求的HTTP header 进行处理，首先获得request header</span><br><span class="line">//eg: GET http://www.zhihu.com HTTP/1.1</span><br><span class="line">//然后对于请求URL进行分析，获取需要连接的服务器的hostname，port，</span><br><span class="line">//修改客户端的HTTP，让proxy充当客户端把信息转发给正确的服务器，然后接收服务器</span><br><span class="line">//的返回并转发给正确的客户端</span><br><span class="line">void doit(int connfd)&#123;</span><br><span class="line"></span><br><span class="line">    char buf[MAXLINE],uri[MAXLINE],method[MAXLINE],version[MAXLINE];</span><br><span class="line">    //parseRequest(fd,&amp;requestLine,headers,&amp;numHead);</span><br><span class="line">    char endServerHTTP [MAXLINE];</span><br><span class="line">    char hostname[MAXLINE],path[MAXLINE];</span><br><span class="line">    char objectBUF[MAX_OBJECT_SIZE];</span><br><span class="line">    int port,endServerFd;</span><br><span class="line"></span><br><span class="line">    rio_t rio,serverRio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio,connfd);</span><br><span class="line">    Rio_readlineb(&amp;rio,buf,MAXLINE);</span><br><span class="line">    //read GET http://www.zhihu.com HTTP/1.1</span><br><span class="line">    //format read function</span><br><span class="line">    sscanf(buf,&quot;%s %s %s&quot;,method,uri,version);</span><br><span class="line">    </span><br><span class="line">    if(strcasecmp(method,&quot;GET&quot;))&#123;</span><br><span class="line">        printf(&quot;Proxy does not implement the method&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //parse the uri and save the hostname,path,port number to the argument</span><br><span class="line">    parse_uri(uri,hostname,path,&amp;port);</span><br><span class="line"></span><br><span class="line">    //build the http header which will send to the end server</span><br><span class="line">    buildHTTPHeader(endServerHTTP,hostname,path,port,&amp;rio);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    strcpy(uri,hostname);</span><br><span class="line">    strcpy(uri+strlen(uri),path);</span><br><span class="line">    if(reader(connfd,uri))&#123;</span><br><span class="line">        fprintf(stdout,&quot;%s from cache\n&quot;,uri);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int totalSize = 0;</span><br><span class="line">    //connect to the end server;</span><br><span class="line">    endServerFd = connectEndServer(hostname,port);</span><br><span class="line">    if(endServerFd&lt;0)&#123;</span><br><span class="line">        printf(&quot;connection failed&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Rio_readinitb(&amp;serverRio,endServerFd);</span><br><span class="line">    Rio_writen(endServerFd,endServerHTTP,strlen(endServerHTTP));</span><br><span class="line"></span><br><span class="line">    //receive message from end server and send to client</span><br><span class="line">    size_t n;</span><br><span class="line">    while((n=Rio_readlineb(&amp;serverRio,buf,MAXLINE)))&#123;</span><br><span class="line">        printf(&quot;proxy received %ld bytes,then send.\n&quot;,n);</span><br><span class="line">        Rio_writen(connfd,buf,n);</span><br><span class="line">        strcpy(objectBUF+totalSize,buf);</span><br><span class="line">        totalSize+=n;</span><br><span class="line">    &#125;</span><br><span class="line">   //each objectBUF save all info of the request</span><br><span class="line">    if(totalSize&lt;MAX_OBJECT_SIZE)</span><br><span class="line">        writer(uri,objectBUF);</span><br><span class="line">    Close(endServerFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="build-HTTP-that-send-to-the-end-server"><a href="#build-HTTP-that-send-to-the-end-server" class="headerlink" title="build HTTP that send to the end server"></a>build HTTP that send to the end server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void buildHTTPHeader(char *http_header,char *hostname,char *path,int port,rio_t *client_rio)&#123;</span><br><span class="line"></span><br><span class="line">    char buf[MAXLINE],requestHeader[MAXLINE],otherHeader[MAXLINE],hostHeader[MAXLINE];</span><br><span class="line"></span><br><span class="line">    //request line</span><br><span class="line">    //static const char *requestHeaderFormat = &quot;GET %s HTTP/1.0\r\n&quot;;</span><br><span class="line">    //把path内容按照格式写入requestHeader</span><br><span class="line">    sprintf(requestHeader,requestHeaderFormat,path);</span><br><span class="line">    while(Rio_readlineb(client_rio,buf,MAXLINE)&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">        if(!strcmp(buf,endof_hdr))&#123;</span><br><span class="line">            break; //EOF</span><br><span class="line">        &#125;</span><br><span class="line">        //Host</span><br><span class="line">        if(!strncasecmp(buf,hostKey,strlen(hostKey)))&#123;</span><br><span class="line">            strcpy(hostHeader,buf);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!strncasecmp(buf,connection_key,strlen(connection_key))&amp;&amp;!</span><br><span class="line">            strncasecmp(buf,proxy_connection_key,strlen(proxy_connection_key)),</span><br><span class="line">            !strncasecmp(buf,user_agent_key,strlen(user_agent_key)))&#123;</span><br><span class="line">            //把两个串连接起来</span><br><span class="line">            strcat(otherHeader,buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if(strlen(hostHeader)==0)&#123;</span><br><span class="line">        sprintf(hostHeader,hostFormat,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    //static const char *user_agent_hdr = &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;;</span><br><span class="line">    //static const char *conn_hdr = &quot;Connection: close\r\n&quot;;</span><br><span class="line">    //static const char *prox_hdr = &quot;Proxy-Connection: close\r\n&quot;;</span><br><span class="line">    //static const char *endof_hdr = &quot;\r\n&quot;;</span><br><span class="line">    </span><br><span class="line">    //put all header to http_header</span><br><span class="line">    sprintf(http_header,&quot;%s%s%s%s%s%s%s&quot;,requestHeader,hostHeader,</span><br><span class="line">            conn_hdr,prox_hdr,user_agent_hdr,otherHeader,endof_hdr);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parseuri"><a href="#parseuri" class="headerlink" title="parseuri"></a>parseuri</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void parse_uri(char *uri,char *hostname,char *path,int *port)&#123;</span><br><span class="line"></span><br><span class="line">    //strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。</span><br><span class="line">    //如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。</span><br><span class="line"></span><br><span class="line">    *port = 80;</span><br><span class="line">    char *pos1 = strstr(uri,&quot;//&quot;);</span><br><span class="line"></span><br><span class="line">    if(pos1)&#123;</span><br><span class="line">        pos1 =  pos1+2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        pos1 = uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char *pos2 = strstr(pos1,&quot;:&quot;);</span><br><span class="line">    //case the uri has the port info</span><br><span class="line">    if(pos2)&#123;</span><br><span class="line"></span><br><span class="line">        //          userinfo     host        port</span><br><span class="line">        //          ┌─┴────┐ ┌────┴────────┐ ┌┴┐</span><br><span class="line">        //  https://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top</span><br><span class="line">        //  └─┬─┘ └───────┬────────────────────┘└─┬─────────────┘└──┬───────────────────────┘└┬─┘</span><br><span class="line">        //  scheme     authority                 path              query                      fragment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //initalize the head of pos2 is \0 i.e clean the pos2</span><br><span class="line">        *pos2 = &apos;\0&apos;;</span><br><span class="line">        sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">        sscanf(pos2+1,&quot;%d%s&quot;,port,path);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        //</span><br><span class="line">        //telnet://192.0.2.16:80/xxx</span><br><span class="line">        //└──┬─┘ └──────┬──────┘│</span><br><span class="line">        //scheme    authority  path</span><br><span class="line">        // no port info</span><br><span class="line">        pos2 = strstr(pos1,&quot;/&quot;);</span><br><span class="line">        if(pos2)&#123;</span><br><span class="line">            sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">            *pos2 = &apos;/&apos;;</span><br><span class="line">            sscanf(pos2,&quot;%s&quot;,path);</span><br><span class="line">        &#125;</span><br><span class="line">        //only hostname info</span><br><span class="line">        else&#123;</span><br><span class="line">            sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="connect-end-server"><a href="#connect-end-server" class="headerlink" title="connect end server"></a>connect end server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline int connectEndServer(char *hostname,int port)&#123;</span><br><span class="line"></span><br><span class="line">    char portStr[100];</span><br><span class="line">    sprintf(portStr,&quot;%d&quot;,port);</span><br><span class="line">    return Open_clientfd(hostname,portStr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>采用读者-写者模型，可以让多个线程同时来读。</p>
<p>没有实现LRU，只是简单地把1MiB内存分为十块，每次接受请求并解析之后，先去cache看看有没有对应的web object，如果有直接返回给客户端，没有再从服务端请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int reader(int fd,char *uri)&#123;</span><br><span class="line"></span><br><span class="line">    //here uri = each server&apos;s hostname+path</span><br><span class="line">    int Found = 0;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    readCount++;</span><br><span class="line">    if(readCount==1)&#123;</span><br><span class="line">        P(&amp;wmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        if(!strcmp(cache.objects[i].uri,uri))&#123;</span><br><span class="line">            Rio_writen(fd,cache.objects[i].buf,MAX_OBJECT_SIZE);</span><br><span class="line">            Found=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    readCount--;</span><br><span class="line">    if(readCount==0)&#123;</span><br><span class="line">        V(&amp;wmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">    return Found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer(char *uri,char *buf)&#123;</span><br><span class="line"></span><br><span class="line">    P(&amp;wmutex);</span><br><span class="line">    strcpy(cache.objects[cache.count].uri,uri);</span><br><span class="line">    strcpy(cache.objects[cache.count].buf,buf);</span><br><span class="line">    ++cache.count;</span><br><span class="line">    V(&amp;wmutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//simple cache no use LRU,just split the memory to 10 block,</span><br><span class="line">//each time use a loop to find whether the uri of the request is in the block</span><br><span class="line">//在server和client之间加入代理的好处之一，就可以实现cache化。</span><br><span class="line">//因为，经常有很多对同一个资源多次请求的情况，如果每次都从服务端获取，那样服务器会很累。</span><br><span class="line">//如果可以在代理部分就实现一个cache，</span><br><span class="line">//将最近客户端请求过的数据给存储起来，那样就不需要每次都要从服务器请求了，进而提高服务器的效率。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void initCache()&#123;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;mutex,0,1);</span><br><span class="line">    sem_init(&amp;wmutex,0,1);</span><br><span class="line">    cache.objects = (cacheLine*)malloc(sizeof(cacheLine)*10);</span><br><span class="line">    cache.count=0;</span><br><span class="line">    readCount=0;</span><br><span class="line">    for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        cache.objects[i].buf = malloc(sizeof(char)*MAXLINE);</span><br><span class="line">        cache.objects[i].uri = malloc(sizeof(char)*MAX_OBJECT_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ul>
<li><p>use ./free-port.sh to get a free port, like 4501</p>
</li>
<li><p>open a terminal, nc -l 4501</p>
<ul>
<li>this is to start netcat as a server listening on port you get</li>
</ul>
</li>
<li><p>open a terminal </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --proxy http://localhost:23885/ http://localhost:4501/</span><br></pre></td></tr></table></figure>
<ul>
<li>open a terminal </li>
</ul>
<p>./proxy 23885</p>
<p><img src="/home/alex/图片/2018-91.png" alt="filename alady exists, renamed"></p>
<p>netcat is listening on 4501,proxy is listening on 23885,here netcat serves as a server,print sth in the ‘nc -l’ window,then you can see the exact sth print on the ‘curl’ window</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p><a href="https://blog.csdn.net/u012336567/article/details/52056089" target="_blank" rel="noopener">https://blog.csdn.net/u012336567/article/details/52056089</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37902495" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37902495</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/15/SAPP-Synchronization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/15/SAPP-Synchronization/" itemprop="url">CSAPP-Synchronization</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-15T13:50:00+08:00">
                2018-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现代操作系统提供三种构造并发程序的方法：</p>
<p>1.进程</p>
<p>2.I/O多路复用</p>
<p>3.线程</p>
<h3 id="基于进程的并发编程"><a href="#基于进程的并发编程" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h3><p>1.内核自动管理多个逻辑流</p>
<p>2.每个进程有私有的地址空间（进程切换的时候要保存和载入数据）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void sigchld_handler(int sig)&#123;</span><br><span class="line">    while (waitpid(-1, 0, WNOHANG) &gt; 0)</span><br><span class="line">        ;</span><br><span class="line">    return;</span><br><span class="line">    // Reap all zombie children</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        if (Fork() == 0) &#123;</span><br><span class="line">            Close(listenfd); // Child closes its listening socket</span><br><span class="line">            echo(connfd); // Child services client</span><br><span class="line">            Close(connfd); // Child closes connection with client</span><br><span class="line">            exit(0); // Child exits</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); // Parent closes connected socket (important!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器在accept函数中等待连接请求，然后客户端通过调用connect函数发送连接请求，最后服务器在accept中返回connfd并且fork一个子进程来处理客户端链接，链接就建立在listenfd和connfd之间。</p>
<ul>
<li><p>每个客户端由独立的子进程处理，而且必须回收僵尸进程，避免内存泄漏</p>
</li>
<li><p>不同进程之间不共享数据</p>
</li>
<li><p>父进程和子进程都有listenfd和connfd，所以父进程中要关闭connfd，子进程要关闭listenfd</p>
<ul>
<li>内核会保存对每个socket的引用计数，(refcnt(connfd)=2)，所以父进程需要关闭connfd，这样在子进程结束后引用计数才会变为0</li>
</ul>
</li>
</ul>
<p>优点：只共享已打开的file table，无论是descriptor还是全局变量都不共享，不容易造成同步问题。</p>
<p>缺点：带来额外的进程管理开销，进程间通信需要用IPC</p>
<h3 id="基于事件-I-O-multiplexing"><a href="#基于事件-I-O-multiplexing" class="headerlink" title="基于事件 I/O multiplexing"></a>基于事件 I/O multiplexing</h3><p>1.由程序员手动控制多个逻辑流。</p>
<p>2.所有逻辑流共享同一个地址空间</p>
<h3 id="基于线程"><a href="#基于线程" class="headerlink" title="基于线程"></a>基于线程</h3><p>内核自动管理多个逻辑流</p>
<p>每个线程共享地址空间</p>
<p>属于基于进程和基于事件的混合体</p>
<h3 id="传统观点下的进程"><a href="#传统观点下的进程" class="headerlink" title="传统观点下的进程"></a>传统观点下的进程</h3><p><img src="/home/alex/图片/jincheng.png" alt="upload sessful"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程有多个线程，每个线程有自己的线程id，有自己的逻辑控制流，也有自己用来保存局部变量的栈（其他线程可以修改）。而且共享所有代码，数据和内核上下文。</p>
<p><img src="/home/alex/图片/xiancheng.png" alt="upload sucssful"></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><img src="/home/alex/图片/duoxianc.png" alt="upload sussful"></p>
<p>概念上的</p>
<p><img src="/home/alex/图片/gainian.png" alt="upload sessful"></p>
<p>实际上的</p>
<p><img src="/home/alex/图片/globaland.png" alt="upload sucsful"></p>
<p>不同线程之间的数据其实可以相互访问</p>
<h3 id="Shared-variable"><a href="#Shared-variable" class="headerlink" title="Shared variable"></a>Shared variable</h3><p>a variable x is shared if and only if multiple threads reference some instance of x </p>
<h4 id="global-amp-local-variable"><a href="#global-amp-local-variable" class="headerlink" title="global &amp; local variable"></a>global &amp; local variable</h4><p><img src="/home/alex/图片/stat.png" alt="upload sful"></p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p><img src="/home/alex/图片/example.png" alt="upload suessful"></p>
<p>ptr是全局变量，shared by main thread and thread 1&amp;2</p>
<p>i is only referenced by main, so not shared</p>
<p>msgs is referenced by all 3 threads, so is is shared </p>
<p>myid is only referenced by thread 1 &amp; 2 seperately</p>
<p>static int cnt is referenced by both 1 &amp;2</p>
<p>so if <strong><em>multiple threads reference the same x instance, the x is shared </em></strong></p>
<p><img src="/home/alex/图片/shared.png" alt="upload succful"></p>
<h3 id="bad-example"><a href="#bad-example" class="headerlink" title="bad example"></a>bad example</h3><p><img src="/home/alex/图片/badeg.png" alt="upload successful"></p>
<p>看loop的汇编代码</p>
<p><img src="/home/alex/图片/2018-86.png" alt="filename ady exists, renamed"></p>
<p>正常结果</p>
<p><img src="/home/alex/图片/zhengchang.png" alt="upload succful"></p>
<p>下图是线程2提前Load了cnt，结果rdx2为0，正确结果是等到线程1store之后线程2再load</p>
<p><img src="/home/alex/图片/dang.png" alt="upload succeful"></p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</p>
<h3 id="再看信号量"><a href="#再看信号量" class="headerlink" title="再看信号量:"></a>再看信号量:</h3><p><img src="/home/alex/图片/sss.png" alt="upload sussful"></p>
<p>信号量的提出，是为了解决<strong><em>同步不同执行线程问题</em></strong>的方法。</p>
<p>什么是信号量？</p>
<p>信号量<strong>s</strong>是一个具有非负值的全局变量。</p>
<p>只能由两种特殊操作P，V来处理</p>
<p>P，V原理如上图</p>
<p><img src="/home/alex/图片/xinhaol.png" alt="uploadccessful"></p>
<p>定义P和V，为了确保一个正在运行的程序绝不可能进入s是负值的状态，这个属性叫<strong><em>信号量不变性</em></strong></p>
<h3 id="使用信号量实现互斥"><a href="#使用信号量实现互斥" class="headerlink" title="使用信号量实现互斥"></a>使用信号量实现互斥</h3><p><img src="/home/alex/图片/jiasuo.png" alt="upload cessful"></p>
<p><img src="/home/alex/图片/2018-87.png" alt="filename alrey exists, renamed"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">volatile int cnt=0; </span><br><span class="line">sem_t mutex; //声明信号量mutex</span><br><span class="line"></span><br><span class="line">Sem_init(&amp;mutex,0,1);//主线程中初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在线程例程中对共享变量cnt的更新包围P和V操作，从而保护他们</span><br><span class="line">for(i=0;i&lt;niters;i++)&#123;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用信号量来调度共享资源"><a href="#使用信号量来调度共享资源" class="headerlink" title="使用信号量来调度共享资源"></a>使用信号量来调度共享资源</h3><h4 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h4><p><img src="/home/alex/图片/yuanli.png" alt="upload cessful"></p>
<h4 id="读者和写者问题"><a href="#读者和写者问题" class="headerlink" title="读者和写者问题"></a>读者和写者问题</h4><p><img src="/home/alex/图片/duzhe.png" alt="load successful"></p>
<p><img src="/home/alex/图片/esa.png" alt="upload sucsful"></p>
<p><img src="/home/alex/图片/2018-88.png" alt="filename exists, renamed"></p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>一个函数如果被多个并发线程反复调用的时候，会一直产生正确的结果，否则就是线程不安全的。</p>
<p>1.不保护共享变量的函数</p>
<p>解决方案，利用P,V这样的同步操作来保护共享的变量</p>
<p>2.保持跨越多个调用状态的函数</p>
<p><img src="/home/alex/图片/jiang.png" alt="uoad successful"></p>
<p>3.返回指向静态变量的指针的函数</p>
<p><img src="/home/alex/图片/hanshu.png" alt="upload scessful"></p>
<p>4.调用线程不安全函数的函数。</p>
<p> 1.如果函数f调用线程不安全函数g。那么f可能不安全。<br> 2.如果g是第二类，那么f一定不安全，也没有办法去修正，只能改变g.<br> 3.如果g是第一，三类，可以用加锁-拷贝技术来解决。</p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点，就会发生竞争。</p>
<p>1.通常，竞争发生的理由是因为程序员假定某种特殊的轨迹线穿过执行状态空间。</p>
<p><img src="/home/alex/图片/face.png" alt="u successful"></p>
<p><img src="/home/alex/图片/2018-89.png" alt="filename alry exists, renamed"></p>
<p><img src="/home/alex/图片/sisuo.png" alt="upload successf"></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="/home/alex/图片/2018-90.png" alt="filename ady exists, renamed"></p>
<p><img src="/home/alex/图片/pindong.png" alt="uploaessful"></p>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>判断 myid会不会出现竞争</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 版本一</span><br><span class="line">void *foo(void *vargp)</span><br><span class="line">&#123;</span><br><span class="line">    int myid;</span><br><span class="line">    myid = *((int *)vargp);</span><br><span class="line">    Free(vargp);</span><br><span class="line">    printf(&quot;Thread %d\n&quot;, myid);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[2];</span><br><span class="line">    int i, *ptr;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; 2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = Malloc(sizeof(int));</span><br><span class="line">        *ptr = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], 0, foo, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    Pthread_join(tid[0], 0);</span><br><span class="line">    Pthread_join(tid[1], 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环中每次创建不同的指针，两个线程不是共享同一个变量。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 版本二</span><br><span class="line">void *foo(void *vargp)</span><br><span class="line">&#123;</span><br><span class="line">    int myid;</span><br><span class="line">    myid = *((int *)vargp);</span><br><span class="line">    printf(&quot;Thread %d\n&quot;, myid);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[2];</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; 2; i++)</span><br><span class="line">        Pthread_create(&amp;tid[i], NULL, foo, &amp;i);</span><br><span class="line">    Pthread_join(tid[0], NULL);</span><br><span class="line">    Pthread_join(tid[1], NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个线程共享i变量，而i++和myid = <em>((int </em>)vargp)<br>会发生竞争，当然前提是传的是引用&amp;i，因为这样的话foo函数会改变i本身的值，若如果是传值i，则只会改变i的一个副本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-Network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-Network/" itemprop="url">CSAPP-Network</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T20:19:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p><img src="/home/alex/图片/socket.png" alt="upload sucsful"></p>
<h4 id="socket-address-structures"><a href="#socket-address-structures" class="headerlink" title="socket address structures"></a>socket address structures</h4><p><img src="/home/alex/图片/sas.png" alt="upload suful"></p>
<p><img src="/home/alex/图片/2018-82.png" alt="filename aly exists, renamed"></p>
<p>发明套接字接口的时候，还没有void*,为了兼容，可以定义套接字函数要求一个指向通用sockaddr结构的指针，然后要求应用程序将与协议特定的结构的指针强制转换成这个通用的结构。</p>
<h3 id="socket-Interface"><a href="#socket-Interface" class="headerlink" title="socket Interface"></a>socket Interface</h3><p><img src="/home/alex/图片/socketInterface.png" alt="upload succesl"></p>
<p>1.开启服务器</p>
<ul>
<li>（open_listenfd函数，做好接收请求的准备）</li>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>accept</li>
</ul>
<p>2.开启客户端</p>
<ul>
<li>getaddrinfo</li>
<li>socket</li>
<li>connect</li>
</ul>
<ol start="3">
<li>交换数据</li>
</ol>
<p>4.关闭客户端</p>
<p>5.断开客户端</p>
<h4 id="getaddrinfo："><a href="#getaddrinfo：" class="headerlink" title="getaddrinfo："></a>getaddrinfo：</h4><p>设置服务器的相关信息</p>
<h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h4><p>创建socket descriptor ，也就是之后用来读写的file descriptor</p>
<p><img src="/home/alex/图片/socf.png" alt="upload cessful"></p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>请求kernel把socket address 和 socket descriptor绑定</p>
<p>Bind is kernel call to designate which service this program will be hosting</p>
<p>告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来，对于socket和connect，最好方法是用getaddrinfo来为bind提供参数</p>
<p><img src="/home/alex/图片/2018-83.png" alt="filename alrey exists, renamed"></p>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>由于客户端是发起连接要求的主动实体，服务器是被动等待连接请求的，所以默认条件下，内核会认为socket函数创建的描述符对应于主动套接字，它存在于一个连接的客户端。服务器调用listen函数告诉内核，描述符是被服务器而不是客户端使用的。</p>
<p>也就是说listen函数把sockfd从一个主动套接字转化为一个监听套接字，这个套接字可以接受来自客户端的连接请求。</p>
<p><img src="/home/alex/图片/listen.png" alt="upload succeul"></p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><p>等待来自客户端的连接请求到达listenfd，然后在addr中填写客户端的套接字地址，并且返回一个已连接描述符，这个描述符可以用来利用Unix I/O 函数与客户端通信。</p>
<p><img src="/home/alex/图片/accept.png" alt="upload succeul"></p>
<p><img src="/home/alex/图片/2018-84.png" alt="filename ady exists, renamed"></p>
<h4 id="connect-client-side"><a href="#connect-client-side" class="headerlink" title="connect (client side)"></a>connect (client side)</h4><p>connect 函数试图与套接字地址为addr的服务器建立一个因特网链接，其中addrlen是sizeof（sockaddr_in）connect函数会阻塞，一直到连接成功或者发现错误。</p>
<p><img src="/home/alex/图片/connect.png" alt="uploessful"></p>
<h3 id="diff-of-connected-amp-listening-descriptors"><a href="#diff-of-connected-amp-listening-descriptors" class="headerlink" title="diff of connected &amp; listening descriptors"></a>diff of connected &amp; listening descriptors</h3><p><img src="/home/alex/图片/connected.png" alt="upload successful"></p>
<h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p><img src="/home/alex/图片/get.png" alt="upload succesl"></p>
<h3 id="Host-and-service-connection"><a href="#Host-and-service-connection" class="headerlink" title="Host and service connection"></a>Host and service connection</h3><p><img src="/home/alex/图片/host.png" alt="uload successful"></p>
<p>result 指向addrinfo结构的链表</p>
<h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p><img src="/home/alex/图片/info.png" alt="upload succesul"></p>
<h3 id="LLR-by-getinfo"><a href="#LLR-by-getinfo" class="headerlink" title="LLR by getinfo"></a>LLR by getinfo</h3><p><img src="/home/alex/图片/adddd.png" alt="upload sussful"></p>
<h4 id="addrinfo-struct（代码实现）"><a href="#addrinfo-struct（代码实现）" class="headerlink" title="addrinfo struct（代码实现）"></a>addrinfo struct（代码实现）</h4><p><img src="/home/alex/图片/daimashixian.png" alt="upload succel"></p>
<p>以下函数是用来把域名转化为IP地址的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line"></span><br><span class="line">	struct addrinfo *p,*listp,hints;</span><br><span class="line">	char buf[MAXLINE];</span><br><span class="line">	int rc,flags;</span><br><span class="line"></span><br><span class="line">	if(argc!=2)&#123;</span><br><span class="line">		fprintf(stderr,&quot;usage: %s &lt;domain name&gt;\n&quot;,argv[0]);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//get a list of addinfo records</span><br><span class="line">	memset(&amp;hints,0,sizeof(struct addrinfo));</span><br><span class="line">	hints.ai_family = AF_INET;</span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	if((rc=getaddrinfo(argv[1],NULL,&amp;hints,&amp;listp))!=0)&#123;</span><br><span class="line">		fprintf(stderr,&quot;getaddrinfo error: %s\n&quot;,gai_strerror(rc));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	flags = NI_NUMERICHOST;</span><br><span class="line"></span><br><span class="line">	for(p=listp;p;p = p-&gt;ai_next)&#123;</span><br><span class="line">		Getnameinfo(p-&gt;ai_addr,p-&gt;ai_addrlen,buf,MAXLINE,NULL,0,flags);</span><br><span class="line">		printf(&quot;%s\n&quot;,buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Freeaddrinfo(listp);</span><br><span class="line"></span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p><img src="/home/alex/图片/cline.png" alt="upload sssful"></p>
<p>web server return content to clients,in 2 different ways:</p>
<p>1.取磁盘文件，并把他的内容返回给客户端，磁盘文件称为静态内容，返回文件给客户端叫服务静态内容。</p>
<p>2.运行一个可执行文件，把输出返回给客户端，运行的时候输出内容叫做动态内容，而运行程序并返回输出内容叫做服务动态内容。</p>
<p>web服务器返回的内容都是和它管理的某个文件相关联的，这些文件中的每一个都有一个唯一的名字叫<strong><em>URL，通用资源定位符。</em></strong></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议</p>
<h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>通用网关接口，用来处理服务器向客户端提供动态内容的问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-UNIX-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-UNIX-IO/" itemprop="url">CSAPP-UNIX/IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T16:45:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Unix-I-O-Overview"><a href="#Unix-I-O-Overview" class="headerlink" title="Unix I/O Overview"></a>Unix I/O Overview</h3><p>1.A linux file is a sequence of m bytes</p>
<p>  B0,B1..Bm-1</p>
<p>2.all I/O devices and even the kernel are represented as files</p>
<p>/dev/sda2 (/usr disk partition)<br>/dev/tty2 (terminal)</p>
<p><img src="/home/alex/图片/2018-76.png" alt="filename aady exists, renamed"></p>
<h3 id="File-Types"><a href="#File-Types" class="headerlink" title="File Types"></a>File Types</h3><p>1.regular file</p>
<p>2.directory</p>
<p>3.<strong>socket</strong> for communicating with a process on another machine</p>
<h4 id="regular-files"><a href="#regular-files" class="headerlink" title="regular files"></a>regular files</h4><p>Kernel doesn’t know the difference between text files and regular files</p>
<h3 id="pathname"><a href="#pathname" class="headerlink" title="pathname"></a>pathname</h3><h4 id="absolute-pathname"><a href="#absolute-pathname" class="headerlink" title="absolute pathname"></a>absolute pathname</h4><p>starts with ‘/‘ and denotes path from root</p>
<p>/home/droh/a.c</p>
<h4 id="relative-pathname"><a href="#relative-pathname" class="headerlink" title="relative pathname"></a>relative pathname</h4><p>../home/droh/a.c</p>
<p><img src="/home/alex/图片/ics.png" alt="upload succsful"></p>
<h3 id="open-amp-closing-file"><a href="#open-amp-closing-file" class="headerlink" title="open&amp;closing file"></a>open&amp;closing file</h3><p><img src="/home/alex/图片/open.png" alt="upload successul"></p>
<p><img src="/home/alex/图片/1.png" alt="upload suessful"></p>
<h3 id="Reading-Files"><a href="#Reading-Files" class="headerlink" title="Reading Files"></a>Reading Files</h3><p><img src="/home/alex/图片/rf.png" alt="upload succful"></p>
<h3 id="Writing-Files"><a href="#Writing-Files" class="headerlink" title="Writing Files"></a>Writing Files</h3><p><img src="/home/alex/图片/2018-77.png" alt="filenameady exists, renamed"></p>
<h3 id="Simple-Unix-I-O-example"><a href="#Simple-Unix-I-O-example" class="headerlink" title="Simple Unix I/O example"></a>Simple Unix I/O example</h3><h4 id="bad-case"><a href="#bad-case" class="headerlink" title="bad case"></a>bad case</h4><p>Each while loop, execute 2 operating system function,that means you have to go to the kernel,go through,context switch,do whatever you wants,then switch back. in a word,it is too <strong>expensive</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line"></span><br><span class="line">    while(Read(STDIN_FILENO, &amp;c, 1) != 0)</span><br><span class="line">        Write(STDOUT_FILENO, &amp;c, 1);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="short-counts"><a href="#short-counts" class="headerlink" title="short counts"></a>short counts</h3><p><img src="/home/alex/图片/2018-78.png" alt="filename y exists, renamed"></p>
<h3 id="File-Metadata"><a href="#File-Metadata" class="headerlink" title="File Metadata"></a>File Metadata</h3><p><img src="/home/alex/图片/file metadata.png" alt="upload essful"></p>
<h3 id="File-Sharing"><a href="#File-Sharing" class="headerlink" title="File Sharing"></a>File Sharing</h3><p><img src="/home/alex/图片/fileSharing.png" alt="upload succesul"></p>
<p><img src="/home/alex/图片/2018-79.png" alt="filename ady exists, renamed"></p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><img src="/home/alex/图片/output.png" alt="upload scessful"></p>
<p><img src="/home/alex/图片/2018-80.png" alt="filename aldy exists, renamed"></p>
<p>内核用三个相关的数据结构来表示打开的文件</p>
<p>1.每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的，每个打开的描述符表项指向文件表一个表项。</p>
<p>2.文件表。是所有进程共享的，保存当前文件位置，引用计数（当前指向该表项的描述符表项数），以及一个指向vnode表对应表项的指针</p>
<p>3.vnode表，所有进程共享</p>
<h3 id="I-O-Redirection"><a href="#I-O-Redirection" class="headerlink" title="I/O Redirection"></a>I/O Redirection</h3><p><img src="/home/alex/图片/ioredi.png" alt="upload cessful"></p>
<h4 id="steps-1"><a href="#steps-1" class="headerlink" title="steps 1"></a>steps 1</h4><p><img src="/home/alex/图片/steps1.png" alt="upload sucessful"></p>
<h4 id="steps-2"><a href="#steps-2" class="headerlink" title="steps 2"></a>steps 2</h4><p><img src="/home/alex/图片/samefile.png" alt="upload essful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fd(5,0)</span><br></pre></td></tr></table></figure>
<p>就是把重定向标准输入到描述符5</p>
<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p><img src="/home/alex/图片/ggg.png" alt="upload succeful"></p>
<p>fd3重定向到了fd2，所以他们指向同样的open file table项，c2是第一个字符a，而c3在此基础上读下一个字符，所以是b。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-malloc-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-malloc-lab/" itemprop="url">CSAPP-malloc lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T14:43:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>所用策略：Segregated lists + best fits + explicit free list</p>
<p><img src="/home/alex/图片/disanwei.png" alt="upload sucssful"></p>
<p>堆的结构：<br>地址从上到下是从低到高<br><img src="/home/alex/图片/heap.png" alt="upload successful"></p>
<p><img src="/home/alex/图片/fenlishipei.png" alt="upload ful"></p>
<p>分离适配的原理：</p>
<p>allocator 维护一个空闲链表的数组，每个空闲链表是和一个大小类相关联的，被组织成某种类型的显式或者隐式链表，每个链表包含潜在的大小不同的块。</p>
<p>为了分配，要先确定请求的大小的类，并且对适当的空闲链表做首次适配，如果找到，就分割，并把剩余部分查到空闲链表。如果找不到，就搜索下一个更大的类，如果还是没有，就向操作系统请求额外的堆内存，然后从这个堆内存中分配出一个块，并把剩余部分放在适当的大小类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* single word (4) or double word (8) alignment */</span><br><span class="line">#define ALIGNMENT 8</span><br><span class="line"></span><br><span class="line">/* rounds up to the nearest multiple of ALIGNMENT */</span><br><span class="line">#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define WSIZE 4 //word and header/footer size</span><br><span class="line">#define DSIZE 8 //double word size (bytes)</span><br><span class="line"></span><br><span class="line">#define INITCHUNKSIZE (1&lt;&lt;6) //the size of extended heap </span><br><span class="line">#define CHUNKSIZE (1&lt;&lt;12) //extend heap </span><br><span class="line"></span><br><span class="line">#define MAX(x,y) ((x)&gt;(y))?(x):(y)</span><br><span class="line">#define MIN(x,y) ((x)&lt;(y))?(x):(y)</span><br><span class="line"></span><br><span class="line">#define PACK(size,alloc) ((size)|(alloc))</span><br><span class="line"></span><br><span class="line">//read and write a word at addr p</span><br><span class="line">#define GET(p) (*(unsigned int*)(p))</span><br><span class="line">#define PUT(p,val) (*(unsigned int*)(p) = (val))</span><br><span class="line"></span><br><span class="line">#define SET_PTR(p,ptr) (*(unsigned int*)(p) = (unsigned int)(ptr))</span><br><span class="line"></span><br><span class="line">#define GET_SIZE(p)  (GET(p)&amp;~0x7)</span><br><span class="line">#define GET_ALLOC(p)  (GET(p)&amp;0x1)</span><br><span class="line"></span><br><span class="line">//given block ptr bp,compute address of its header and footer</span><br><span class="line">#define HDRP(bp)  ((char*)(bp)-WSIZE)</span><br><span class="line">// (char*bp)+size -wsize= next&apos;s block&apos;s bp &apos;s position,-DSIZE,that means </span><br><span class="line">//  previous block&apos;s foot address</span><br><span class="line">#define FTRP(bp)  ((char*)(bp)+GET_SIZE(HDRP(bp))-DSIZE)</span><br><span class="line"></span><br><span class="line">#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp)-WSIZE))</span><br><span class="line">#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp)-DSIZE))</span><br><span class="line"></span><br><span class="line">#define PRED_PTR(ptr) ((char*)(ptr))</span><br><span class="line">#define SUCC_PTR(ptr) ((char*)(ptr)+WSIZE)</span><br><span class="line"></span><br><span class="line">#define PRED(ptr) (*(char **)(ptr))</span><br><span class="line">#define SUCC(ptr) (*(char **)(SUCC_PTR(ptr)))</span><br><span class="line"></span><br><span class="line">#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span><br><span class="line">#define LIST_SIZE 16</span><br></pre></td></tr></table></figure>
<p>全局函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void *extend_heap(size_t words);</span><br><span class="line">static void *coalesce(void *bp);</span><br><span class="line">static void *place(void *bp,size_t asize);</span><br><span class="line">static void insert(void *bp,size_t size);</span><br><span class="line">static void delete(void *bp);</span><br></pre></td></tr></table></figure></p>
<p>初始化列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * mm_init - initialize the malloc package.</span><br><span class="line"> */</span><br><span class="line">int mm_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *heap;</span><br><span class="line">    if((heap=mem_sbrk(4*WSIZE))==(void*)-1)</span><br><span class="line">        return -1;</span><br><span class="line">    </span><br><span class="line">    int idx;</span><br><span class="line">	</span><br><span class="line">    //initialize the list</span><br><span class="line">    for(idx=0;idx&lt;LIST_SIZE;idx++)&#123;</span><br><span class="line">        list[idx] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //alignment padding</span><br><span class="line">    //按照上图堆的结构来初始化</span><br><span class="line">    PUT(heap,0);</span><br><span class="line">    PUT(heap+(1*WSIZE),PACK(DSIZE,1));  //prologue header</span><br><span class="line">    PUT(heap+(2*WSIZE),PACK(DSIZE,1)); //prologue footer</span><br><span class="line">    PUT(heap+(3*WSIZE),PACK(0,1)); //Epilogue header</span><br><span class="line"></span><br><span class="line">    if(extend_heap(INITCHUNKSIZE)==NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span><br><span class="line"> *     Always allocate a block whose size is a multiple of the alignment.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void *mm_malloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    //ignore spurious requeses</span><br><span class="line">    if(size==0)</span><br><span class="line">        return NULL;</span><br><span class="line">    </span><br><span class="line">    if(size&lt;=DSIZE)</span><br><span class="line">        size = 2*DSIZE;</span><br><span class="line">    else</span><br><span class="line">        size = ALIGN(size+DSIZE);</span><br><span class="line"></span><br><span class="line">    int idx = 0;</span><br><span class="line">    size_t ssize = size;</span><br><span class="line">    void *ptr = NULL;</span><br><span class="line"></span><br><span class="line">    while(idx&lt;LIST_SIZE)&#123;</span><br><span class="line">		//链表类的大小分别是 1 1 2 4 8 16 32...</span><br><span class="line">        // 分别存储 &#123;0&#125;,&#123;1&#125;,&#123;2,3&#125;,&#123;4,5,6,7&#125;..</span><br><span class="line">        // 通过循环 ssize&gt;&gt;=1 与idx,找到该分配的</span><br><span class="line">        //字节大小所在的链表</span><br><span class="line">        //然后再内嵌一个循环，在这个链表中寻找大小适			//合的pointer</span><br><span class="line">        if((ssize&lt;=1)&amp;&amp;(list[idx]!=NULL))&#123;</span><br><span class="line">            ptr = list[idx];</span><br><span class="line">            while(ptr&amp;&amp;((size&gt;GET_SIZE(HDRP(ptr)))))&#123;</span><br><span class="line">                ptr = PRED(ptr);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果找到了就break</span><br><span class="line">            if(ptr!=NULL)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        ssize&gt;&gt;=1;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果找不到，向系统申请额外的堆内存</span><br><span class="line">    if(ptr==NULL)&#123;</span><br><span class="line">        int extendsize = MAX(size,CHUNKSIZE);</span><br><span class="line">        if((ptr=extend_heap(extendsize))==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //在free块中allocate size大小的块</span><br><span class="line">    ptr = place(ptr,size);</span><br><span class="line"></span><br><span class="line">    return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void mm_free(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">	//把该块头脚末位都标注为0，说明这一块是free</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, 0));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, 0));</span><br><span class="line"></span><br><span class="line">    /* 插入分离空闲链表 */</span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    /* 合并 */</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/13/并发与并行区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/并发与并行区别/" itemprop="url">并发与并行区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T17:15:32+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.cnblogs.com/liqiuhao/p/8082246.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiuhao/p/8082246.html</a></p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>程序加载到内存中执行，（这时变成进程），操作系统会通过虚拟内存机制，通过让它和其他进程分时段占用CPU，使其产生独占CPU的假象。在CPU执行一个进程的指令的时候，被执行的许多指令连接起来，就构成了逻辑控制流。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>就是两个逻辑控制流交替进行</p>
<p><img src="/home/alex/图片/bingfa.png" alt="upload succe"></p>
<p>A与B，A与C并发</p>
<p><strong><em>并发与CPU个数或者计算机个数无关</em></strong></p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p><strong><em>如果两个逻辑控制流同时（一个cpu时段内）在不同的cpu（多核）或者计算机上被执行，我们就称其为并行。</em></strong></p>
<p><img src="/home/alex/图片/2018-75.png" alt="filename already existsmed"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/12/CSAPP-SHELL-LAB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/12/CSAPP-SHELL-LAB/" itemprop="url">CSAPP-SHELL LAB</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-12T13:45:47+08:00">
                2018-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>整个过程中要考虑显式阻塞</p>
<p>1.在访问全局变量（jobs）以及调用给定函数的时候，要阻塞所有的信号，务必保证这些使用for循环遍历的函数不被中断。</p>
<p>2.在一些函数或者指令有必须的先后顺序的时候，要阻塞，保证前一个函数调用完成，再调用后面一个函数。</p>
<p>其他事项：</p>
<p><img src="/home/alex/图片/2018-70.png" alt="filename already exists, renaed"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//判断是否是当前引起停止信号的是否是前台进程</span><br><span class="line">volatile sig_atomic_t fg_stop_or_exit;</span><br></pre></td></tr></table></figure></p>
<h3 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h3><p>功能是对用户输入的参数进行解析，命令有两种，一种是内置的命令，会立刻执行，否则就要ｆｏｒｋ一个新的子进程并且把该任务在子进程的上下文中运行。<strong><em>如果是前台任务则需要等到它运行结束才返回</em></strong></p>
<p>每个子进程必须有一个独一无二的进程组id，通过在fork（）之后子进程的Setpgid(0,0)实现，这样当我们向前台程序发送ctrl+c或者ctrl+z命令才不会影响到后台程序。否则所有的子进程会与当前的tsh shell进程为同一个进程组，发送信号的时候，前后台子进程都会收到。</p>
<p>同时fork新进程的前后要阻塞SIGCHLD信号，防止出现竞争的同步错误：fork之后会在job列表里添加job，信号处理函数sigchld_handler回收进程后会在job列表中删除，如果信号来得很早，那么就可能发生先删除后添加的情况，那么job就会永远在列表中（内存泄漏？），所以我们先block掉SIGCHLD，添加job后再还原。</p>
<p>说白了就是要避免僵尸进程，防止父进程没有给子进程收尸，屏蔽这个信号，那么父亲进程就会不关心这个子进程，子进程结束将由init进程去处理。</p>
<h6 id="setpgid-函数"><a href="#setpgid-函数" class="headerlink" title="setpgid 函数"></a>setpgid 函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setpgid (pid_t pid,pgid_t pgid);</span><br></pre></td></tr></table></figure>
<p>该函数的意义是找到进程ID为pid的进程，将其进程组ID修改为pgid，如果pid=0，说明要修改进程组ID。如果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setpgid(0,0)</span><br></pre></td></tr></table></figure>
<p>表示创立新的进程组，并且指定的进程会成为进程组的首进程。</p>
<p>如果执行成功就返回组识别码，如果有错误则返回-1，错误原因保存在errno中。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>eval函数实现如下：</p>
<p>if builtin_command return 0,then shell starts a new child process,and execute the requested programs in the child process,if the user asks for running the program in background, then shell return back to the top of the loop,waiting for next command. otherwise shell uses the waitpid function to wait for the jobs ‘ termination. when jobs terminates,shell begin a new loop.</p>
<p>参考：<br><a href="https://blog.csdn.net/zxygww/article/details/25976107" target="_blank" rel="noopener">https://blog.csdn.net/zxygww/article/details/25976107</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">void eval(char *cmdline)</span><br><span class="line">&#123;</span><br><span class="line">    char *argv[MAXARGS];  //argument list execve()</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    int argc;</span><br><span class="line">    int bg; //whether the job is in fg or bg</span><br><span class="line">    bg = parseline(cmdline,argv);</span><br><span class="line">    sigset_t mask_chld,mask_all,mask_prev;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;mask_chld);</span><br><span class="line">    #把SIGCHLD信号赋给mask_chld</span><br><span class="line">    sigaddset(&amp;mask_chld,SIGCHLD);</span><br><span class="line">    #fill所有SIG信号给mask_all</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    strcpy(buf,cmdline);</span><br><span class="line"></span><br><span class="line">    //empty command</span><br><span class="line">    if(argv[0]==NULL)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!builtin_cmd(argv))&#123;</span><br><span class="line">		//如果不是内部函数，首先要把SIGCHLD信号阻塞住，以防出现竞争条件。</span><br><span class="line">		//子进程要解决信号阻塞，并执行相关的函数</span><br><span class="line">        //if the below code are outside of the buildin_cmd function,</span><br><span class="line">        //then these locks won&apos;t be realeased when executing inner commands</span><br><span class="line">        //block the SIGCHLD in order to prevent child process ends between father process</span><br><span class="line">		//先要阻塞SIGCHLD信号</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_chld,&amp;mask_prev);</span><br><span class="line">        //codes below won&apos;t be interrupt by signal SIGCHLD</span><br><span class="line"></span><br><span class="line">        //running a child process</span><br><span class="line">        //</span><br><span class="line">        if((pid=fork())==0)&#123;</span><br><span class="line">         //由于子进程会继承block的特性，所以子进程要记得unblock。</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);//unblock the order</span><br><span class="line">            //change the process &apos;s group, not the same as tsh&apos;s group</span><br><span class="line">            setpgid(0,0);</span><br><span class="line">            if(execve(argv[0],argv,environ)&lt;0)&#123;</span><br><span class="line">                printf(&quot;%s: Command not found\n&quot;,argv[0]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //if execve cannot process then child process will execute main process</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //blcok all signal</span><br><span class="line">        //为我阻挡一切！！就算天塌下来也要先addjob不然顺序乱就gg</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,NULL);</span><br><span class="line">        //foreGround</span><br><span class="line">        if(!bg)&#123;</span><br><span class="line">            addjob(jobs,pid,FG,cmdline);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            addjob(jobs,pid,BG,cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">        //block sigchld again</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_chld,NULL);</span><br><span class="line"></span><br><span class="line">        //father process wait until front process stops</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //父进程要判断子进程是前台进程还是后台进程，如果是前台进程，则调用waitpid来等待前台进程，如果是后台，把新添加进程利用addjob添加到工作组中。</span><br><span class="line">        if(!bg)&#123;</span><br><span class="line">            //Block until process pid is no longer the foreground process</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sigprocmask(SIG_BLOCK,&amp;mask_all,NULL);</span><br><span class="line">            struct job_t * currbgmask = getjobpid(jobs,pid);</span><br><span class="line">            printf(&quot;[%d] (%d) %s&quot;,currbgmask-&gt;jid,currbgmask-&gt;pid,currbgmask-&gt;cmdline);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //unblock all signals</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="builtin-command"><a href="#builtin-command" class="headerlink" title="builtin_command"></a>builtin_command</h3><p>注意访问全局变量jobs的时候要阻塞全部信号就是了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int builtin_cmd(char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    sigset_t mask_all,mask_prev;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    if(!strcmp(argv[0],&quot;quit&quot;))&#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;&amp;&quot;))&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;jobs&quot;))&#123;</span><br><span class="line">        //when visit a global variance,you need to block all signals</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;bg&quot;)||!strcmp(argv[0],&quot;fg&quot;))&#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;     /* not a builtin command */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>只要进程号一直是前台程序，就一直sleep等待</p>
<p>但奇怪的是，这个版本的waitfg函数运行有错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">void waitfg(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //fgpid return the pid of the front process id</span><br><span class="line">    </span><br><span class="line">    while((pid==fgpid(jobs)))&#123;</span><br><span class="line">        sleep(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下版本：<br>是书中545中介绍的一种显式接收信号的方法</p>
<p>只要信号处理函数回收了前台进程，它就会将fg_stop_or_exit(注意用volatile关键字声明) 置1，这样我们的waitfg函数就会退出，接着读取用户的下一个输入.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="line"> */</span><br><span class="line">void waitfg(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    sigset_t mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    fg_stop_or_exit = 0;</span><br><span class="line">   </span><br><span class="line">    ////只有发出这个信号的子进程是前台进程才设置fg_stop_or_exit标志。</span><br><span class="line">    while(!fg_stop_or_exit)&#123;</span><br><span class="line">        sigsuspend(&amp;mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sigint-handler-amp-sigtstp-handler"><a href="#sigint-handler-amp-sigtstp-handler" class="headerlink" title="sigint_handler &amp; sigtstp_handler"></a>sigint_handler &amp; sigtstp_handler</h3><p>思路：</p>
<p>1.获取前台进程（fgpid），判断当前是否有前台进程，如果没有则直接返回，有则进行步骤2</p>
<p>2.使用kill函数，发送SIGINT/SIGTSTP信号给前台进程组</p>
<h6 id="kill函数使用"><a href="#kill函数使用" class="headerlink" title="kill函数使用"></a>kill函数使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid,int sig);</span><br><span class="line"></span><br><span class="line">//如果pid大于0，那么kill函数发送信号号码sig给进程pid，如果pid==0，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid&lt;0，则发送sig给进程组|pid|中的每个进程。</span><br></pre></td></tr></table></figure>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>1.访问jobs的时候要阻塞所有信号</p>
<p>2.kill的pid是负的，说明发送信号对象是进程组，是所有前台程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="line"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="line"> *    to the foreground job.</span><br><span class="line"> */</span><br><span class="line">void sigint_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int olderrno = errno;</span><br><span class="line">    sigset_t mask_all,prev_all;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    //execute global function, so block all signals</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    pid=fgpid(jobs);</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,NULL);</span><br><span class="line"></span><br><span class="line">    //only process the front process</span><br><span class="line">    //pid==0 means background process?</span><br><span class="line"></span><br><span class="line">    if(pid!=0)&#123;</span><br><span class="line">        kill(-pid,SIGINT);</span><br><span class="line">        //printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;,pid2jid(pid),pid,sig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><p>1.注意如果进程已经停止，就不要再把它设置为停止了否则会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="line"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="line"> *     foreground job by sending it a SIGTSTP.</span><br><span class="line"> */</span><br><span class="line">void sigtstp_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid=fgpid(jobs);</span><br><span class="line"></span><br><span class="line">    if(pid!=0)&#123;</span><br><span class="line">        struct job_t *job = getjobpid(jobs,pid);</span><br><span class="line">        if(job-&gt;state==ST)</span><br><span class="line">            return;</span><br><span class="line">        else</span><br><span class="line">            kill(-pid,SIGTSTP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h3><p>status表示中止进程或者停止进程的原因，WNOHANG|WUNTRACED作用是判断当前进程中是否存在已经停止或者终止的进程，如果存在则返回pid，不存在立即返回</p>
<p>WIFSTOPPED(status):表示如果进程是因为停止的信号而停止，那么返回true</p>
<p>WIFSIGNALED(status):表示进程是因为捕获的信号而中止，返回true</p>
<p>WIFEXITED(status): 表示进程通过调用exit()或者return正常结束，则返回true。</p>
<p>参考：<a href="https://www.cnblogs.com/sky-heaven/p/8074273.html" target="_blank" rel="noopener">https://www.cnblogs.com/sky-heaven/p/8074273.html</a></p>
<p><img src="/home/alex/图片/2018-69.png" alt="filename already exists, rnamed"></p>
<h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="line"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="line"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="line"> *     available zombie children, but doesn&apos;t wait for any other</span><br><span class="line"> *     currently running children to terminate.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void sigchld_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    int olderrno = errno;</span><br><span class="line">    sigset_t mask_all,prev_all;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    struct job_t *gc_job;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    //尽可能回收子进程，使用WNOHANG,使得如果当前进程都没有停止的时候直接返回，</span><br><span class="line">    //而不是挂起该回收进程，这样可能会阻碍无法两个短时间结束的后台进程</span><br><span class="line"></span><br><span class="line">    while((pid = waitpid(-1,&amp;status,WNOHANG|WUNTRACED))&gt;0)&#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">        gc_job = getjobpid(jobs,pid);</span><br><span class="line">        //说明当前引起停止的确实是前台进程</span><br><span class="line">        if(pid==fgpid(jobs))&#123;</span><br><span class="line">            fg_stop_or_exit=1;</span><br><span class="line">        &#125;</span><br><span class="line">        //子进程正常结束，返回一个非0值</span><br><span class="line">        if(WIFEXITED(status))&#123;</span><br><span class="line">            deletejob(jobs,pid);</span><br><span class="line">        &#125;</span><br><span class="line">        //子进程被暂停，只有暂停不用deletejobs</span><br><span class="line">        else if(WIFSTOPPED(status))&#123;</span><br><span class="line">            //子进程停止引起waitpid函数返回,再判断该进程是否是前台进程</span><br><span class="line">            gc_job-&gt;state = ST;</span><br><span class="line">            printf(&quot;Job [%d] (%d) stopped by signal %d\n&quot;, gc_job-&gt;jid, gc_job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        //因捕获信号而终止</span><br><span class="line">        else if (WIFSIGNALED(status))&#123;</span><br><span class="line">            //子进程终止引起的返回，判断是否是前台进程</span><br><span class="line">            //并且判断该信号是否是未捕获的的信号</span><br><span class="line">            printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;, gc_job-&gt;jid, gc_job-&gt;pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs,pid);</span><br><span class="line">        &#125;</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        //unblock all signals</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;prev_all,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-fgbg"><a href="#do-fgbg" class="headerlink" title="do_fgbg"></a>do_fgbg</h3><p>1.输入时%num 代表jobsid，num代表进程id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="line"> */</span><br><span class="line">void do_bgfg(char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //parameters</span><br><span class="line">    char *para = argv[1];</span><br><span class="line">    </span><br><span class="line">    //lack parameters</span><br><span class="line">    if(para==NULL)&#123;</span><br><span class="line">        printf(&quot;%s command requires PID or %%jobid argument\n&quot;,argv[0]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //full dirname</span><br><span class="line">    char *cmd = argv[0];</span><br><span class="line"></span><br><span class="line">    struct job_t*curr_job;</span><br><span class="line">    sigset_t mask_all,mask_prev;</span><br><span class="line">    int curr_jid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    //first character of the paramaters</span><br><span class="line">    //linux command: fg %n bring process n from background to frontground</span><br><span class="line">    if(para[0]==&apos;%&apos;)&#123;</span><br><span class="line">  </span><br><span class="line">        // the argument is a job id</span><br><span class="line">        curr_jid = atoi(&amp;(para[1]));</span><br><span class="line">        //mistake process2</span><br><span class="line">        curr_job = getjobjid(jobs,curr_jid);</span><br><span class="line">        if(curr_job==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%%%d: No such job\n&quot;,curr_jid);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line">    	// the argument is a process id</span><br><span class="line">        curr_jid = atoi(para);</span><br><span class="line">        if(curr_jid==0)&#123;</span><br><span class="line">            printf(&quot;%s: argument must be a PID or %%jobid\n&quot;,cmd);</span><br><span class="line">            fflush(stdout);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //block all signals when visit global vairance</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">        curr_jid = pid2jid(curr_jid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //block all signals when visit global vairance</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">    curr_job = getjobjid(jobs,curr_jid);</span><br><span class="line"></span><br><span class="line">    if(curr_job==NULL)&#123;</span><br><span class="line">        printf(&quot;(%s): No such process\n&quot;,para);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //bg</span><br><span class="line">    if(!strcmp(cmd,&quot;bg&quot;))&#123;</span><br><span class="line">        switch(curr_job-&gt;state)&#123;</span><br><span class="line">            case ST:</span><br><span class="line">                //change from stop to bg ST-&gt;BG</span><br><span class="line">                //meanwhile send signal to child process</span><br><span class="line">                curr_job-&gt;state =BG;</span><br><span class="line">                kill(-(curr_job-&gt;pid),SIGCONT);</span><br><span class="line">                printf(&quot;[%d] (%d) %s&quot;,curr_job-&gt;jid,curr_job-&gt;pid,curr_job-&gt;cmdline);</span><br><span class="line">                break;</span><br><span class="line">            case BG:</span><br><span class="line">                break;</span><br><span class="line">            case UNDEF:</span><br><span class="line">            case FG:</span><br><span class="line">                unix_error(&quot;bg or undef error&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//要用waitfg指令，等待前台作业结束后再退出    </span><br><span class="line">    else&#123;</span><br><span class="line">        switch(curr_job-&gt;state)&#123;</span><br><span class="line">            //如果作业本身是STOP的话，要记得发送信号（SIGCONT，让其继续运行）</span><br><span class="line">            case ST:</span><br><span class="line">                //change from stop to bg ST-&gt;BG</span><br><span class="line">                //meanwhile send signal to child process</span><br><span class="line">                curr_job-&gt;state =FG;</span><br><span class="line">                //发射信号给前台进程组，所有前台进程都会受到信号</span><br><span class="line">                kill(-(curr_job-&gt;pid),SIGCONT);</span><br><span class="line">                //if change to fg,then you need to wait until it dies</span><br><span class="line">                waitfg(curr_job-&gt;pid);</span><br><span class="line">                break;</span><br><span class="line">            case BG:</span><br><span class="line">                curr_job-&gt;state =FG;</span><br><span class="line">                waitfg(curr_job-&gt;pid);</span><br><span class="line">                break;</span><br><span class="line">            case UNDEF:</span><br><span class="line">            case FG:</span><br><span class="line">                unix_error(&quot;bg or undef error&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当我们在真正的shell（例如bash）中执行tsh时，tsh本身也是被放在前台进程组中的，它的子进程也会在前台进程组中，例如下图所示：</p>
<p><img src="/home/alex/图片/jinchengzu.png" alt="upload succsful"></p>
<h3 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h3><p>1.<a href="https://www.cnblogs.com/liqiuhao/p/8120617.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiuhao/p/8120617.html</a></p>
<p>2.<a href="https://blog.csdn.net/xiaolian_hust/article/details/80087376" target="_blank" rel="noopener">https://blog.csdn.net/xiaolian_hust/article/details/80087376</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/07/程序的机器级表示与执行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/程序的机器级表示与执行/" itemprop="url">CSAPP-异常控制流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T19:30:00+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CPU所执行的指令的地址序列称为CPU的控制流，通过下述两种方式得到的控制流为正常控制流。</p>
<p>1.按顺序取下一条指令执行。</p>
<p>2.通过CALL/RET/Jcc/JMP等指令跳转到转移目标地址处执行</p>
<h3 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h3><p><img src="/home/alex/图片/ctrlc.png" alt="upload sucessful"></p>
<p>硬件层面有两种情况：</p>
<p>1.执行指令的硬件发现指令有异常。eg:除0</p>
<p>2.外部中断 ctrl+c</p>
<p>异常控制流形成原因（1.2硬件层面）</p>
<p>1.内部异常：缺页，越权，越级，整除0，溢出等，都是CPU可以发现的。</p>
<p>2.外部中断（Ctrl-C，打印缺纸，DMA结束等）由外界请求信号通知CPU</p>
<p>3.进程的上下文切换（发生在操作系统层）</p>
<p>4.一个进程直接发送信号给另外一个进程（发生在应用软件层）</p>
<h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><p><img src="/home/alex/图片/程序和进程.png" alt="uplod successful"></p>
<p><img src="/home/alex/图片/PROCESS.png" alt="upload sucessful"></p>
<p><img src="/home/alex/图片/XITONG.png" alt="pload successful"></p>
<p>vm_area_struct  是一个线性链表</p>
<h4 id="引入进程的好处"><a href="#引入进程的好处" class="headerlink" title="引入进程的好处"></a>引入进程的好处</h4><p><img src="/home/alex/图片/2018-42.png" alt="ilename already exists, renamed"></p>
<p>独立的逻辑控制流意味着进程不会感觉到其他进程的存在，使得其不容易受其他进程打乱</p>
<h4 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h4><p><img src="/home/alex/图片/2018-43.png" alt="filename eady exists, renamed"></p>
<p> 进程p1，A12，打断一次</p>
<p> 进程p2，A24，打断一次</p>
<h4 id="进程与上下文切换"><a href="#进程与上下文切换" class="headerlink" title="进程与上下文切换"></a>进程与上下文切换</h4><p>什么叫进程的上下文？<br><img src="/home/alex/图片/chuliqi.png" alt="upload sucessful"></p>
<p><img src="/home/alex/图片/js.png" alt="upload succeul"></p>
<p><strong><em>用户级上下文地址空间和系统级上下文地址空间一起构成了一个进程的整个存储器映像</em></strong></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>以下内容引用<br><a href="https://wdxtub.com/2016/04/16/thin-csapp-5/" target="_blank" rel="noopener">https://wdxtub.com/2016/04/16/thin-csapp-5/</a></p>
<p>进程才是程序（指令和数据）的真正运行实例。之所以重要，是因为进程给每个应用提供了两个非常关键的抽象：一是逻辑控制流，二是私有地址空间。逻辑控制流通过称为上下文切换(context switching)的内核机制让每个程序都感觉自己在独占处理器。私有地址空间则是通过称为虚拟内存(virtual memory)的机制让每个程序都感觉自己在独占内存。这样的抽象使得具体的进程不需要操心处理器和内存的相关适宜，也保证了在不同情况下运行同样的程序能得到相同的结果。</p>
<p><img src="/home/alex/图片/2018-68.png" alt="filename already exists, ramed"></p>
<p>左边是单进程的模型，内存中保存着进程所需的各种信息，因为该进程独占 CPU，所以并不需要保存寄存器值。而在右边的单核多进程模型中，虚线部分可以认为是当前正在执行的进程，因为我们可能会切换到其他进程，所以内存中需要另一块区域来保存当前的寄存器值，以便下次执行的时候进行恢复（也就是所谓的上下文切换）。整个过程中，CPU 交替执行不同的进程，虚拟内存系统会负责管理地址空间，而没有执行的进程的寄存器值会被保存在内存中。切换到另一个进程的时候，会载入已保存的对应于将要执行的进程的寄存器值。</p>
<p>我们所讲的“双核”</p>
<p><img src="/home/alex/图片/double.png" alt="upload success"></p>
<p><img src="/home/alex/图片/进程.png" alt="upload successfu"></p>
<p>上下文切换是指把运行内核代码的环境调出来，然后把用户代码的环境（PC，寄存器等）保存起来</p>
<h4 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h4><p>虚拟地址空间由内核空间和用户空间两部分组成。用户空间（32位）都从0x08048000组成。<br><img src="/home/alex/图片/、、.png" alt="upload successfl"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 errno 这个全局变量来表示错误的原因。使用的时候记住两个规则：</p>
<p>1.对于每个系统调用都应该检查返回值<br>2.当然有一些系统调用的返回值为 void，在这里就不适用</p>
<p>fork函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void unix_error(char *msg) /* Unix-style error */</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pid_t Fork(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    if ((pid = fork()) &lt; 0)</span><br><span class="line">        unix_error(&quot;Fork error&quot;);</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取进程信息"><a href="#获取进程信息" class="headerlink" title="获取进程信息"></a>获取进程信息</h4><p>我们可以用下面两个函数获取进程的相关信息：</p>
<p>1.pid_t getpid(void) - 返回当前进程的 PID<br>2.pid_t getppid(void) - 返回当前进程的父进程的 PID</p>
<p>我们可以认为，进程有三个主要状态：</p>
<p>1.运行 Running<br>        正在被执行、正在等待执行或者最终将会被执行<br>2.停止 Stopped<br>        执行被挂起，在进一步通知前不会计划执行<br>3.终止 Terminated<br>        进程被永久停止</p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p><img src="/home/alex/图片/2018-44.png" alt="filename alredy exists, renamed"></p>
<h3 id="程序的加载和运行"><a href="#程序的加载和运行" class="headerlink" title="程序的加载和运行"></a>程序的加载和运行</h3><p><img src="/home/alex/图片/taipei.png" alt="upload succesful"></p>
<p><img src="/home/alex/图片/jiazai.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/2018-45.png" alt="filename alrdy exists, renamed"></p>
<p><img src="/home/alex/图片/ke.png" alt="upload succesul"></p>
<p>entry point 是可执行目标文件ELF头 的entry point</p>
<p>所以程序的加载和运行就是一个进程切换到另外一个进程，中间要进行上下文切换。切换新进程的时候先要创建一个进程（fork），然后exec，然后运行main</p>
<p><img src="/home/alex/图片/fork.png" alt="upload successful"></p>
<p>第一个参数先压栈，最后一个参数最后压栈，注意上图，argv是一个指针，指向一个数组，即图中argv【0】处，每一个元素又本身是一个指针，指向一个字符串，envp也是一个指针数组，每一个元素指向一个环境变量。</p>
<p>然后如果main函数调用了其它函数，就会又长出一个栈帧，这就是程序加载与运行的过程。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>可以用kill函数发射信号</p>
<p>子进程陷入无限循环，则父进程发射KILL信号，终结子进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void forkandkill()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid[N];</span><br><span class="line">    int i;</span><br><span class="line">    int child_status;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">        if ((pid[i] = fork()) == 0)</span><br><span class="line">            while(1) ;  // 死循环</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Killing process %d\n&quot;, pid[i]);</span><br><span class="line">        kill(pid[i], SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid_t wpid = wait(&amp;child_status);</span><br><span class="line">        if (WIFEXITED(child_status))</span><br><span class="line"> printf(&quot;Child %d terminated with exit status  %d\n&quot;,wpid,WEXITSTATUS(child_status));</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Child %d terminated abnormally\n&quot;, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>所有上下文切换都是通过调用某个异常处理器（exception handler）完成的，内核会计算对易于某个进程p的pnb值：pnb=pending&amp;~blocked</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void unix_error(char *msg) /* Unix-style error */</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sigint_handler(int sig) // SIGINT 处理器</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;想通过 ctrl+c 来关闭我？\n&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    sleep(1);</span><br><span class="line">    printf(&quot;OK. :-)\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 设定 SIGINT 处理器</span><br><span class="line">    if (signal(SIGINT, sigint_handler) == SIG_ERR)</span><br><span class="line">        unix_error(&quot;signal error&quot;);</span><br><span class="line">        </span><br><span class="line">    // 等待接收信号</span><br><span class="line">    pause();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/maye.png" alt="upload succeful"></p>
<p>信号处理器的工作流程可以认为是和当前用户进程“并发”的同一个伪进程。</p>
<h4 id="并行与并发的区别"><a href="#并行与并发的区别" class="headerlink" title="并行与并发的区别"></a>并行与并发的区别</h4><p>并行：多个CPU同时执行程序</p>
<p>并发(concurrent)：即使只有一个CPU，但操作系统能够把程序的执行单位细化，然后分开执行。是一种伪并行执行</p>
<h4 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h4><p>内核会阻塞与当前在处理的信号同类型的其他正在等待的信号，也就是说一个SIGINT信号处理是不能被另外一个SIGINT信号中断的。</p>
<p>如果要显示阻塞，需要用sigprocmask函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sigset_t mask, prev_mask;</span><br><span class="line">Sigemptyset(&amp;mask); // 创建空集</span><br><span class="line">Sigaddset(&amp;mask, SIGINT); // 把 SIGINT 信号加入屏蔽列表中</span><br><span class="line">// 阻塞对应信号，并保存之前的集合作为备份</span><br><span class="line">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line">...</span><br><span class="line">... // 这部分代码不会被 SIGINT 中断</span><br><span class="line">...</span><br><span class="line">// 取消阻塞信号，恢复原来的状态</span><br><span class="line">Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL);</span><br></pre></td></tr></table></figure>
<p>并行访问可能会导致数据毁坏问题，以下是一些编写程序的规则。</p>
<pre><code>规则 1：信号处理器越简单越好
    例如：设置一个全局的标记，并返回
规则 2：信号处理器中只调用异步且信号安全(async-signal-safe)的函数
    诸如 printf, sprintf, malloc 和 exit 都是不安全的！
规则 3：在进入和退出的时候保存和恢复 errno
    这样信号处理器就不会覆盖原有的 errno 值
规则 4：临时阻塞所有的信号以保证对于共享数据结构的访问
    防止可能出现的数据损坏
规则 5：用 volatile 关键字声明全局变量
    这样编译器就不会把它们保存在寄存器中，保证一致性
规则 6：用 volatile sig_atomic_t 来声明全局标识符(flag)
    这样可以防止出现访问异常
</code></pre><p>异步信号安全：指的是如下两类函数：</p>
<p>1.所有的变量都保存在栈帧当中<br>2.不会被信号中断的函数</p>
<h3 id="非本地跳转-Non-local-jump"><a href="#非本地跳转-Non-local-jump" class="headerlink" title="非本地跳转 Non local jump"></a>非本地跳转 Non local jump</h3><p>从一个函数跳转到另一个函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setjmp 保存当前程序的堆栈上下文环境(stack context)，注意，这个保存的堆栈上下文环境仅在调用 setjmp 的函数内有效，如果调用 setjmp 的函数返回了，这个保存的堆栈上下文环境就失效了。调用 setjmp 的直接返回值为 0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">longjmp 将会恢复由 setjmp 保存的程序堆栈上下文，即程序从调用 setjmp 处重新开始执行，不过此时的 setjmp 的返回值将是由 longjmp 指定的值。注意longjmp 不能指定0为返回值，即使指定了 0，longjmp 也会使 setjmp 返回 1。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf env;</span><br><span class="line">P1()</span><br><span class="line">&#123;</span><br><span class="line">    if (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">        // 跳转到这里</span><br><span class="line">    &#125; else </span><br><span class="line">    &#123;</span><br><span class="line">        P2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">P2()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    P2();</span><br><span class="line">    ...</span><br><span class="line">    P3();</span><br><span class="line">&#125;</span><br><span class="line">P3()</span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/kundao.png" alt="uploadccessful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf env;</span><br><span class="line">P1()</span><br><span class="line">&#123;</span><br><span class="line">    P2(); P3();</span><br><span class="line">&#125;</span><br><span class="line">P2()</span><br><span class="line">&#123;</span><br><span class="line">    if (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">        // 跳转到这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P3()</span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为P2在跳转的时候，已经在P3前返回了，内存已经清理了其对应的栈帧，所以P3的longjmp不能实现期望的操作。</p>
<h4 id="CSAPP-家庭作业"><a href="#CSAPP-家庭作业" class="headerlink" title="CSAPP 家庭作业"></a>CSAPP 家庭作业</h4><p>waitpid函数的作用：</p>
<p>当指定等待的子进程以及停止运行或者结束了，waitpid函数会立即返回，如果子进程还没有停止运行或者结束，调用waitpid的父进程会被祖塞，暂停运行</p>
<p>8.18<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void end()&#123;</span><br><span class="line">  </span><br><span class="line">      printf(&quot;2&quot;);fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">     if(fork()==0)</span><br><span class="line">        atexit(end);</span><br><span class="line">     if(fork()==0)&#123;</span><br><span class="line">        printf(&quot;0&quot;);fflush(stdout);</span><br><span class="line">      &#125;</span><br><span class="line">     else&#123;</span><br><span class="line">        printf(&quot;1&quot;);fflush(stdout);</span><br><span class="line">     &#125;</span><br><span class="line">      exit(0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个子进程的atexit函数把end函数添加到函数列表中，那么这个子进程生成的两个子进程的堆栈中也会有end函数，但是另外父进程则独立，不受影响，即使wxit也不会有反应。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/07/IA-32-linux中的地址转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/IA-32-linux中的地址转换/" itemprop="url">CSAPP-IA-32/linux中的地址转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T15:28:00+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/home/alex/图片/2018-32.png" alt="filename alrady exists, renamed"></p>
<p><img src="/home/alex/图片/IA32.png" alt="upload succeful"></p>
<p>1.逻辑地址-》线性地址是 分段<br>2.线性地址-》内存地址是 分页</p>
<p>这里的8是偏移量A<br>%ebp是基址寄存器B，%esp是变址寄存器I，4是比例因子S</p>
<h3 id="分段过程"><a href="#分段过程" class="headerlink" title="分段过程"></a>分段过程</h3><p>线性地址的计算</p>
<p><img src="/home/alex/图片/duanxuanze.png" alt="upload sucsful"></p>
<p>段选择符是在上图的段寄存器里面的</p>
<p><img src="/home/alex/图片/dizhizhuanhuan.png" alt="upload success"></p>
<p>段选择符就相当于index位，分段方式中有一个”段表“（在主存），段表记录了段的长度，段开始的地方，存取权限等。</p>
<p>线性地址 = 段基址+有效地址</p>
<p>有效地址 = 基址寄存器+变址寄存器×比例因子</p>
<p>有效地址实际上是一个段内的偏移量，首地址+段内偏移量 = 线性地址。</p>
<p><img src="/home/alex/图片/duan.png" alt="upload succesful"></p>
<p>得到的线性地址再通过分页，通过页表转换为主存地址</p>
<h3 id="段寄存器的含义"><a href="#段寄存器的含义" class="headerlink" title="段寄存器的含义"></a>段寄存器的含义</h3><p><img src="/home/alex/图片/2018-33.png" alt="filename already exists, rend"></p>
<p>RPL： 最后两位表示管理状态（request privilege level）</p>
<p><img src="/home/alex/图片/2018-35.png" alt="filename alreadmed"></p>
<h3 id="段描述符和段描述符表"><a href="#段描述符和段描述符表" class="headerlink" title="段描述符和段描述符表"></a>段描述符和段描述符表</h3><p><img src="/home/alex/图片/2018-36.png" alt="filename already exists, renamed"></p>
<p>什么叫任务状态段？</p>
<p>这里的任务指的是进程，就是进程执行到某个阶段的时候，CS.SS.EIP，ESP，GPR内容等信息（代码算段，堆栈段，指令指针，栈指针，通用寄存器内容等）</p>
<p>中断门描述符记录了处理中断等异常处理的程序的首地址</p>
<p><img src="/home/alex/图片/logical.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/2018-37.png" alt="filename already enamed"></p>
<p>为了减少从主存中找段描述符，使用cache</p>
<p><img src="/home/alex/图片/cc.png" alt="upload succsful"></p>
<p><img src="/home/alex/图片/2018-38.png" alt="upload suessful"></p>
<p>TSS描述符在进行进程切换的时候，TR里面的内容也要进行切换。</p>
<p>所有表的起始地址是放在GDR，而所有异常中断程序的首地址放在IDT，IDT的首地址也放在IDTR里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GDT和IDT只有一个，GDTR 和 IDTR指向各自起始的地方，根据TR取GDT中的TSS描述符的时候，GDTR给出首地址</span><br></pre></td></tr></table></figure>
<h4 id="Linux的全局段描述符表"><a href="#Linux的全局段描述符表" class="headerlink" title="Linux的全局段描述符表"></a>Linux的全局段描述符表</h4><p><img src="/home/alex/图片/GDT.png" alt="upload sucssful"></p>
<p>最后两位是RPL,都为0表示其在第0环，位于内核</p>
<p>倒数第三位表示这个描述符在GDT中，剩下的位便是索引号，<br>TSS索引是0x0010,即全局描述符表的第16项，LDT索引是0x0011，是第17项</p>
<p>因此在上上图中，操作系统会分别把0x80与0x88放在TR与LDTR中</p>
<h4 id="逻辑地址向线性地址转换"><a href="#逻辑地址向线性地址转换" class="headerlink" title="逻辑地址向线性地址转换"></a>逻辑地址向线性地址转换</h4><p><img src="/home/alex/图片/GDTR.png" alt="upload succesful"></p>
<p>逻辑地址（48位）=》 线性地址（32位）</p>
<p>16位的段选择符，根据TI选择去GDT还是去LDT，其中GDT，LDT的首地址分别存储在GDTR和LDTR里面，（不可见寄存器）</p>
<p><strong><em>段描述符 = 首地址+8×段选择符的索引</em></strong></p>
<p>所以得到的段基地址加上段偏移量，就得到32位线性地址</p>
<p>段描述符只有在第一次进行访问，访问过后就放在了cache里面，所以之后求线性地址，只需要在cache里面取基地址然后相加就行</p>
<p><img src="/home/alex/图片/risc.png" alt="upoad successful"></p>
<p>1.就是初始化时候上述4个段描述符放在GDT中<br>2.每个段都被初始化在0-4GB的线性地址空间中</p>
<p><img src="/home/alex/图片/ldtgdt.png" alt="uploauccessful"></p>
<p><img src="/home/alex/图片/2018-39.png" alt="filename already exists, reamed"></p>
<p>有效地址（偏移量） = 基址寄存器+变址寄存器×比例因子</p>
<p><img src="/home/alex/图片/2018-40.png" alt="filename alreay exists, renamed"></p>
<p>所以<strong><em>线性地址就等于EA = 有效地址 </em></strong></p>
<p>线性地址 = 基地址+有效地址</p>
<p>所谓EA其实只是一个segment内的一个段内偏移量</p>
<p><img src="/home/alex/图片/logic.png" alt="upload succeul"></p>
<p>指令的线性地址 = 代码段基地址+有效地址，而linux编译器默认了代码段基地址位0，因此指令的线性地址就等于有效地址就等于段的偏移量。</p>
<p>而数据的线性地址 = 数据段基地址+EA =0+ R[ECX]+R[EDX]*4</p>
<p>0X8048A00+(400)的16进制，注意进制的转换</p>
<h3 id="分页过程（线性地址-》物理地址）"><a href="#分页过程（线性地址-》物理地址）" class="headerlink" title="分页过程（线性地址-》物理地址）"></a>分页过程（线性地址-》物理地址）</h3><p>如果页大小为4KB，每个页表项占4B则理论上一个页表大小：</p>
<p>项个数：2^32/2^12 = 2^20 ，因此每个页表大小位4MB</p>
<p>比页还要大，因此采用多级页表方式来存储</p>
<p>—————————————————————————————————————————</p>
<p><img src="/home/alex/图片/2018-41.png" alt="filename already exists, red"></p>
<p>IA-32采用二级页表方式来存储</p>
<p><img src="/home/alex/图片/yedizhi.png" alt="upload sucssful"></p>
<p>每个页表起始位置按4KB对齐意思就是每个页表起始的20位都是相同的，只有后面的12位（4KB）不同</p>
<p><img src="/home/alex/图片/mmu.png" alt="upload"></p>
<p><img src="/home/alex/图片/imge.png" alt="upload succeul"></p>
<p>MMU 完成从逻辑地址到线性地址的过程</p>
<h3 id="CPL-RPL-DPL区别与联系"><a href="#CPL-RPL-DPL区别与联系" class="headerlink" title="CPL,RPL,DPL区别与联系"></a>CPL,RPL,DPL区别与联系</h3><p>1.CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。
　　</p>
<p>2.RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。
　　　　</p>
<p>3.DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。<br>当进程访问一个段时，需要进程特权级检查，一般要求DPL &gt;= max {CPL, RPL}</p>
<p>下面打一个比方，中国官员分为6级国家主席1、总理2、省长3、市长4、县长5、乡长6，假设我是当前进程，级别总理（CPL=2）,我去聊城市(DPL=4)考察(呵呵),我用省长的级别(RPL=3 这样也能吓死他们:-))去访问,可以吧，如果我用县长的级别，人家就不理咱了(你看看电视上的微服私访，呵呵)，明白了吧！为什么采用RPL，是考虑到安全的问题，就好像你明明对一个文件用有写权限，为什么用只读打开它呢，还不是为了安全！</p>
<p>ref：<a href="https://blog.csdn.net/better0332/article/details/3416749" target="_blank" rel="noopener">https://blog.csdn.net/better0332/article/details/3416749</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/06/CSAPP-Virtural-Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/CSAPP-Virtural-Memory/" itemprop="url">CSAPP-Virtural Memory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T20:12:21+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>为每个进程提供了一个大的，一致的和私有的地址空间。</p>
<p>1.把主存看成是一个存储在磁盘上的地址空间的高速缓存</p>
<p>2.为每个进程提供了一致的地址空间，简化了内存管理</p>
<p>3.保护每个进程的地址空间不被其他进程破坏</p>
<h3 id="早期分页方式的概念"><a href="#早期分页方式的概念" class="headerlink" title="早期分页方式的概念"></a>早期分页方式的概念</h3><p>大白话：程序是在逻辑空间上写的，而是在物理空间上运行，所以要解决逻辑空间与物理空间之间的映射。</p>
<p><img src="/home/alex/图片/page.png" alt="upload successf"></p>
<p>就是程序可能会有2^16byte长，但是物理容量只有4K</p>
<p><img src="/home/alex/图片/2018-26.png" alt="filename alrady exists, renamed"></p>
<p>这个区号意思就是说，地址空间0-4095对应page 1，4096-8192对应page2</p>
<p><strong><em>区间就是页(page)，主存中存放页的区域成为页框</em></strong></p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p><img src="/home/alex/图片/paging.png" alt="upload succesul"></p>
<p><img src="/home/alex/图片/dazi.png" alt="upad successful"></p>
<p>逻辑地址 1：30  1作为地址空间索引号（页号），30作为内容</p>
<p>14代表页框号 </p>
<p>所以页表就是用来映射页号和物理地址中的页框号</p>
<p><img src="/home/alex/图片/durian.png" alt="upload successl"></p>
<p>页框之间内容可以离散，页框内部内容连续</p>
<h3 id="虚拟存储系统"><a href="#虚拟存储系统" class="headerlink" title="虚拟存储系统"></a>虚拟存储系统</h3><p>大白话：程序可能很长，但是主存容量有限，于是把活跃的程序段放到主存中运行，然后自动进行切换</p>
<p>实质：</p>
<p>1.程序员在比实际主存空间大得多的逻辑地址空间中编写程序</p>
<p>2.程序执行的时候，要把当前需要的程序段以及相应的数据块调入主存当中，不用的部分放在磁盘上</p>
<h4 id="虚拟存储技术的实质"><a href="#虚拟存储技术的实质" class="headerlink" title="虚拟存储技术的实质"></a>虚拟存储技术的实质</h4><p>进程调入物理主存的空间（程序中活跃的片段占用了主存的物理空间）</p>
<p><img src="/home/alex/图片/xuange.png" alt="upload successl"></p>
<p>每个程序会有一个页表来说明它这一页的情况<br>（在磁盘上/内存上/空页）</p>
<p><img src="/home/alex/图片/vmm.png" alt="upload successl"></p>
<p>cpu拿到的是虚拟地址，要求转化为主存地址，而这个过程是在执行指令的时候完成的，只能通过硬件来完成</p>
<p><img src="/home/alex/图片/2018-27.png" alt="filename already exists, med"></p>
<p>加载一个可执行文件，执行的时候，不会实际上把数据都加载到内存当中，而是生成该程序对应的一个页表。然后按照按需调页原则，通过pageFault异常来实现，把数据装入到内存当中。</p>
<h4 id="主存–磁盘"><a href="#主存–磁盘" class="headerlink" title="主存–磁盘"></a>主存–磁盘</h4><p><img src="/home/alex/图片/images.png" alt="upload successl"></p>
<p>因为访问磁盘的时间会比较长，因此要尽可能减少磁盘的次数</p>
<p>write back 只写主存，不写磁盘</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>用结构数组来实现</p>
<p><img src="/home/alex/图片/vlid.png" alt="upload successfu"></p>
<p>装入位-&gt;valid bit</p>
<p>修改位-&gt;dirty bit</p>
<p>替换控制位-&gt;根据其使用情况，决定该page是淘汰掉还是保留<br>eg（LRU.LMU）</p>
<p>实页号-&gt;页框号</p>
<p><strong>每个进程有一个页表，其中有装入位，dirty位，替换控制位，访问权限位（确定是否可读/可写）还有禁止缓存位，实页号</strong></p>
<p>一个页数的项数有什么来决定？<strong>虚拟地址空间大小来决定</strong></p>
<p>项数 = 虚拟地址空间大小 / 页大小</p>
<p>4GB/4KB = 2^20 项</p>
<p>每个进程的页表大小一样吗？</p>
<p><strong><em>各个进程有相同虚拟空间，所以理论上一样。实际大小看具体实现方式，如“空洞：页面如何处理</em></strong></p>
<p><img src="/home/alex/图片/2018-28.png" alt="fil"></p>
<p>页表分三种</p>
<p><img src="/home/alex/图片/ju.png" alt="upload successl"></p>
<h4 id="逻辑地址转换为物理地址"><a href="#逻辑地址转换为物理地址" class="headerlink" title="逻辑地址转换为物理地址"></a>逻辑地址转换为物理地址</h4><p><img src="/home/alex/图片/VA.png" alt="upload success"></p>
<p>VA：VIRTUAL ADDRESS</p>
<p>类比于全相连cache，地址只有两部分，高位的tag，低位的偏移量。这里也是类似，page no,表示页表索引，页表基址存放在一个寄存器当中，<strong><em>页表的地址 = 基址+页表索引×页框大小</em></strong> </p>
<p>PF： frame no. ，即物理页号，其加上disp偏移量就等于PA，物理地址。</p>
<p>V = 0时，发生缺页。</p>
<h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p>这个时候就需要操作系统来帮忙处理</p>
<p><img src="/home/alex/图片/vm2.png" alt="upload success"></p>
<h4 id="TLB（快表）"><a href="#TLB（快表）" class="headerlink" title="TLB（快表）"></a>TLB（快表）</h4><p><img src="/home/alex/图片/um.png" alt="upload sssful"></p>
<p>全相连中，tag = 标签号，没有组号</p>
<p>组相连当中，虚页号高位作为tag，低位作为组号（index）</p>
<p><img src="/home/alex/图片/TLB.png" alt="upload succe"></p>
<p>1.从virtual page中得到虚页号，把虚页号与TLB中的tag作比较，如果valid=0 or valid = 1 but tag!=VA,then 发生缺页。</p>
<p>2.于是从主存的页表(慢表)开始寻找，由于页表中的表项是按照索引号排列的，所以并不需要tag号。如果V=0，还找不到，则时候就要到外存当中的磁盘找对应的表项。</p>
<p>3.如果找到了，可以直接从page frame中生成物理地址号，这样就不需要访问向前面部分介绍的那样，访问主存。</p>
<p><strong><em>所以引入快表（在cache）目的就是减少主存的访问次数，提高逻辑地址与物理地址转换的速度。</em></strong></p>
<p><img src="/home/alex/图片/cmt.png" alt="upload successfl"></p>
<p>最理想路径： VA-&gt;HIT1-&gt;HIT3-&gt;CPU 不用访问主存</p>
<p>如果发生了TLB缺失（miss1），在主存中的的页表中寻找，如果找到了就是hit2，继续送到cache里面，否则就是miss 2 ，发生page fault</p>
<p>如果送到cache，cache miss了，就发生miss 3，从主存那里找。</p>
<h5 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h5><p><img src="/home/alex/图片/2018-30.png" alt="filename already exists, renaed"></p>
<p>最上面那一段属于页表，中间段属于TLB，下面那一段是cache</p>
<p>大概过程：虚拟地址从TLB表中寻找，如果找不到就去页表找，然后映射为物理地址后，物理地址在cache中找，找不到就访问主存，从主存中找。</p>
<p>虚拟地址分为20位的虚拟页号，12位的页内地址</p>
<p>上图中由于是组相连，因此虚拟页号分为tag标记以及组索引，当v=1而且TLB标记等于标记号的时候，就找到了物理页号，然后物理页号与虚拟地址的业内地址结合起来，就找到了物理地址。然后物理地址就又分为标记号，组索引以及块内地址，于cache中寻找所要寻找的字节。</p>
<p><img src="/home/alex/图片/ca.png" alt="upload successl"></p>
<p>缺页处理是由操作系统来作的</p>
<p><img src="/home/alex/图片/HMM.png" alt="upload ful"></p>
<p>如果不在页表当中，就绝对不可能再快表当中；如果页表缺失，说明信息不在主存，cache也一定不可能有！</p>
<p>三个都miss过程：</p>
<p>1.快表miss，去页表（在主存）中找，访存1次</p>
<p>2.页表miss，只能从磁盘中寻找，访问磁盘一次</p>
<p>3.cache miss，从主存当中寻找，访存第二次</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="/home/alex/图片/lee.png" alt="upload succesul"></p>
<p>页表项数： 虚拟地址大小 / 页大小</p>
<p><img src="/home/alex/图片/phy.png" alt="upload succesl"></p>
<p>虚拟地址中，高8位就是虚拟页号，低6位就是偏移量。</p>
<p>物理地址中，高6位是实页号，低6号是偏移量。</p>
<p>快表：</p>
<p><img src="/home/alex/图片/bufen.png" alt="upload successl"></p>
<p>16个TLB项，4路组相连，说明TLBI是2，剩下6位就是tag位</p>
<p>快表中0A34数据有误，因为其VPN就是tag+set号</p>
<p> tag是0A,set是03，所以VPN为 00101011 就是0x2B</p>
<p>但是在慢表中，0x2Bvalid位是0，所以说明数据有误</p>
<p>cache：</p>
<p><img src="/home/alex/图片/china.png" alt="upload succesful"></p>
<p>一共有16行，所以CI是4，偏移量是2（主存块4B）</p>
<p><img src="/home/alex/图片/jizz.png" alt="upload succesul"></p>
<p>VPN = 0xF TLBI = 0x3 TLBT = 0x3</p>
<p>即在快表的第三组中找tag==3的，找到了，说明其命中，没有page fault，PPN是0D</p>
<p>0D = 1101</p>
<p>所以物理地址为（PPN+VPO）<br>001101010100</p>
<p>C0 = 00<br>CI = 0101<br>CT = 001101</p>
<p>在cache中找第5行，tag为001101的16位数据</p>
<p>B0 = 36 B1 = 72</p>
<p>所以要找的数据是7236(小端，高位数据在高位)</p>
<h4 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h4><p>分段方式很好管理，但是占的空间多，储存空间管理不好管理。</p>
<p><img src="/home/alex/图片/fenduan.png" alt="oad successful"></p>
<p><img src="/home/alex/图片/2018-31.png" alt="file already exists, renamed"></p>
<h4 id="段页式存储器"><a href="#段页式存储器" class="headerlink" title="段页式存储器"></a>段页式存储器</h4><p><img src="/home/alex/图片/ta.png" alt="upload succful"></p>
<h5 id="练习题9-5"><a href="#练习题9-5" class="headerlink" title="练习题9.5"></a>练习题9.5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">char *bufp</span><br><span class="line"></span><br><span class="line">//fd 为open函数返回的文件描述符</span><br><span class="line">void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offset)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建一个包含size字节的只读，私有，请求二进制0的虚拟内存区域，如果调用成功，bufp则为新区域的地址</span><br><span class="line">bufp = Mmap(NULL,size,PROT_READ,MAP_PRIVATE|MAP_ANON,0,0);</span><br></pre></td></tr></table></figure>
<p>用以上函数，讲一个任意大小的磁盘文件复制到stdout，文件名作为一个命令行参数传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;csapp.h&gt;</span><br><span class="line"></span><br><span class="line">void mmapcopy(int fd,int size)&#123;</span><br><span class="line">    char *bufp;</span><br><span class="line">    bufp = Mmap(NULL,size,PROT_READ,MAP_PRIVATE,fd,0);</span><br><span class="line">    Write(1,bufp,size);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">    if(argc!=2)&#123;</span><br><span class="line">        printf(&quot;usage: %s &lt;filename&gt;\n&quot;,argv[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int fd;</span><br><span class="line">    struct stat stat;</span><br><span class="line">    fd = Open(argv[0],O_RDONLY,0);</span><br><span class="line">    fstat(fd,&amp;stat);</span><br><span class="line">    mmapcopy(fd,stat.st_size);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//文件描述符的用法<br>//<a href="https://blog.csdn.net/u012736748/article/details/74626145" target="_blank" rel="noopener">https://blog.csdn.net/u012736748/article/details/74626145</a></p>
<p>文件描述符是一个索引，指向内核为每一个进程所维护的该进程打开文件的记录表。</p>
<h4 id="删除虚拟地址"><a href="#删除虚拟地址" class="headerlink" title="删除虚拟地址"></a>删除虚拟地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int mummap（void *start,size_t length）;</span><br></pre></td></tr></table></figure>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><h4 id="usage-of-malloc-package"><a href="#usage-of-malloc-package" class="headerlink" title="usage of malloc package"></a>usage of malloc package</h4><p><img src="/home/alex/图片/mallocz.png" alt="upload scessful"></p>
<p><img src="/home/alex/图片/2018-71.png" alt="fildy existsenamed"></p>
<p>可以通过诸如malloc,new等方法让程序运行的时候得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，叫做堆。</p>
<p>分配器以块为单位来维护堆，可以进行分配或者释放。有两种类型：</p>
<pre><code>1.显式分配器：应用分配并且回收空间（malloc &amp; free）
2.隐式分配器，只负责分配，但是不负责回收（JAVA中的垃圾收集）
</code></pre><p>过程如下：</p>
<p><img src="/home/alex/图片/malloc.png" alt="upload "></p>
<p><img src="/home/alex/图片/gg.png" alt="upload"></p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>假设给定一个malloc和free的请求的序列目标是尽可能提高吞吐量和内存利用率。</p>
<p>吞吐量： 单位时间内完成的请求数量。</p>
<p>内存利用率：主要影响因素是内存碎片。</p>
<h5 id="内部碎片"><a href="#内部碎片" class="headerlink" title="内部碎片"></a>内部碎片</h5><p><img src="/home/alex/图片/内存碎片.png" alt="upld successful"></p>
<h5 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h5><p><img src="/home/alex/图片/外部.png" alt="upload ssful"></p>
<h4 id="Peak-Memory-Utilization"><a href="#Peak-Memory-Utilization" class="headerlink" title="Peak Memory Utilization"></a>Peak Memory Utilization</h4><p><img src="/home/alex/图片/per.png" alt="upload susful"></p>
<h4 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h4><h5 id="how-to-free"><a href="#how-to-free" class="headerlink" title="how to free"></a>how to free</h5><p><img src="/home/alex/图片/implementation.png" alt="upload successf"></p>
<p>pointer 前面用一个word记录block size</p>
<p>free的时候，访问指针前一个word就可以知道blocksize了</p>
<h5 id="keeping-track-of-free-blocks"><a href="#keeping-track-of-free-blocks" class="headerlink" title="keeping track of free blocks"></a>keeping track of free blocks</h5><p><img src="/home/alex/图片/how.png" alt="uploadsuccessful"></p>
<h5 id="implicit-free-lists"><a href="#implicit-free-lists" class="headerlink" title="implicit free lists"></a>implicit free lists</h5><p><img src="/home/alex/图片/2018-72.png" alt="filename alredy exists, renamed"></p>
<p>因为每一个block是8-byte alignment的，因此最后3位必定都是0，所以可以利用最后一位来存储该块是否已经分配</p>
<h5 id="example"><a href="#example" class="headerlink" title="example"></a>example</h5><p><img src="/home/alex/图片/2018-73.png" alt="filenamey exists, renamed"></p>
<h5 id="Finding-a-free-block"><a href="#Finding-a-free-block" class="headerlink" title="Finding a free block"></a>Finding a free block</h5><p><img src="/home/alex/图片/2018-74.png" alt="filename already exists, renamd"></p>
<p>这里的 <em>p &amp; -2 -&gt;  </em>p &amp; 1111111…110 即得到block的size ，i.e mask out the last bit</p>
<h5 id="allocating-in-free-block"><a href="#allocating-in-free-block" class="headerlink" title="allocating in free block"></a>allocating in free block</h5><p><img src="/home/alex/图片/alloc.png" alt="upload succesul"></p>
<h5 id="freeing-a-block"><a href="#freeing-a-block" class="headerlink" title="freeing a block"></a>freeing a block</h5><p><img src="/home/alex/图片/freeing.png" alt="upload cessful"></p>
<h5 id="Coalescing"><a href="#Coalescing" class="headerlink" title="Coalescing"></a>Coalescing</h5><p><img src="/home/alex/图片/coalescing.png" alt="upload succsful"></p>
<p>next pointer points to where 2 stores</p>
<p>如果2开头的block是空的，那么 <em>p = </em>p +*next</p>
<p>意思就是说4 = 4+2 = 6</p>
<h5 id="Explicit-Free-Lists"><a href="#Explicit-Free-Lists" class="headerlink" title="Explicit Free Lists"></a>Explicit Free Lists</h5><p><img src="/home/alex/图片/VM.png" alt="upload succeful"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="Alex Chiu" />
            
              <p class="site-author-name" itemprop="name">Alex Chiu</p>
              <p class="site-description motion-element" itemprop="description">Alex's personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Chiu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
