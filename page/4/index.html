<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Alex&apos;s personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex Chiu">
<meta property="og:url" content="http://AlexanderChiuluvB.github.io/page/4/index.html">
<meta property="og:site_name" content="Alex Chiu">
<meta property="og:description" content="Alex&apos;s personal blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex Chiu">
<meta name="twitter:description" content="Alex&apos;s personal blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://AlexanderChiuluvB.github.io/page/4/"/>





  <title>Alex Chiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex Chiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/07/程序的机器级表示与执行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/程序的机器级表示与执行/" itemprop="url">CSAPP-异常控制流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T19:30:00+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CPU所执行的指令的地址序列称为CPU的控制流，通过下述两种方式得到的控制流为正常控制流。</p>
<p>1.按顺序取下一条指令执行。</p>
<p>2.通过CALL/RET/Jcc/JMP等指令跳转到转移目标地址处执行</p>
<h3 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h3><p><img src="/home/alex/图片/ctrlc.png" alt="upload sucessful"></p>
<p>硬件层面有两种情况：</p>
<p>1.执行指令的硬件发现指令有异常。eg:除0</p>
<p>2.外部中断 ctrl+c</p>
<p>异常控制流形成原因（1.2硬件层面）</p>
<p>1.内部异常：缺页，越权，越级，整除0，溢出等，都是CPU可以发现的。</p>
<p>2.外部中断（Ctrl-C，打印缺纸，DMA结束等）由外界请求信号通知CPU</p>
<p>3.进程的上下文切换（发生在操作系统层）</p>
<p>4.一个进程直接发送信号给另外一个进程（发生在应用软件层）</p>
<h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><p><img src="/home/alex/图片/程序和进程.png" alt="uplod successful"></p>
<p><img src="/home/alex/图片/PROCESS.png" alt="upload sucessful"></p>
<p><img src="/home/alex/图片/XITONG.png" alt="pload successful"></p>
<p>vm_area_struct  是一个线性链表</p>
<h4 id="引入进程的好处"><a href="#引入进程的好处" class="headerlink" title="引入进程的好处"></a>引入进程的好处</h4><p><img src="/home/alex/图片/2018-42.png" alt="ilename already exists, renamed"></p>
<p>独立的逻辑控制流意味着进程不会感觉到其他进程的存在，使得其不容易受其他进程打乱</p>
<h4 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h4><p><img src="/home/alex/图片/2018-43.png" alt="filename eady exists, renamed"></p>
<p> 进程p1，A12，打断一次</p>
<p> 进程p2，A24，打断一次</p>
<h4 id="进程与上下文切换"><a href="#进程与上下文切换" class="headerlink" title="进程与上下文切换"></a>进程与上下文切换</h4><p>什么叫进程的上下文？<br><img src="/home/alex/图片/chuliqi.png" alt="upload sucessful"></p>
<p><img src="/home/alex/图片/js.png" alt="upload succeul"></p>
<p><strong><em>用户级上下文地址空间和系统级上下文地址空间一起构成了一个进程的整个存储器映像</em></strong></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>以下内容引用<br><a href="https://wdxtub.com/2016/04/16/thin-csapp-5/" target="_blank" rel="noopener">https://wdxtub.com/2016/04/16/thin-csapp-5/</a></p>
<p>进程才是程序（指令和数据）的真正运行实例。之所以重要，是因为进程给每个应用提供了两个非常关键的抽象：一是逻辑控制流，二是私有地址空间。逻辑控制流通过称为上下文切换(context switching)的内核机制让每个程序都感觉自己在独占处理器。私有地址空间则是通过称为虚拟内存(virtual memory)的机制让每个程序都感觉自己在独占内存。这样的抽象使得具体的进程不需要操心处理器和内存的相关适宜，也保证了在不同情况下运行同样的程序能得到相同的结果。</p>
<p><img src="/home/alex/图片/2018-68.png" alt="filename already exists, ramed"></p>
<p>左边是单进程的模型，内存中保存着进程所需的各种信息，因为该进程独占 CPU，所以并不需要保存寄存器值。而在右边的单核多进程模型中，虚线部分可以认为是当前正在执行的进程，因为我们可能会切换到其他进程，所以内存中需要另一块区域来保存当前的寄存器值，以便下次执行的时候进行恢复（也就是所谓的上下文切换）。整个过程中，CPU 交替执行不同的进程，虚拟内存系统会负责管理地址空间，而没有执行的进程的寄存器值会被保存在内存中。切换到另一个进程的时候，会载入已保存的对应于将要执行的进程的寄存器值。</p>
<p>我们所讲的“双核”</p>
<p><img src="/home/alex/图片/double.png" alt="upload success"></p>
<p><img src="/home/alex/图片/进程.png" alt="upload successfu"></p>
<p>上下文切换是指把运行内核代码的环境调出来，然后把用户代码的环境（PC，寄存器等）保存起来</p>
<h4 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h4><p>虚拟地址空间由内核空间和用户空间两部分组成。用户空间（32位）都从0x08048000组成。<br><img src="/home/alex/图片/、、.png" alt="upload successfl"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 errno 这个全局变量来表示错误的原因。使用的时候记住两个规则：</p>
<p>1.对于每个系统调用都应该检查返回值<br>2.当然有一些系统调用的返回值为 void，在这里就不适用</p>
<p>fork函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void unix_error(char *msg) /* Unix-style error */</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pid_t Fork(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    if ((pid = fork()) &lt; 0)</span><br><span class="line">        unix_error(&quot;Fork error&quot;);</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取进程信息"><a href="#获取进程信息" class="headerlink" title="获取进程信息"></a>获取进程信息</h4><p>我们可以用下面两个函数获取进程的相关信息：</p>
<p>1.pid_t getpid(void) - 返回当前进程的 PID<br>2.pid_t getppid(void) - 返回当前进程的父进程的 PID</p>
<p>我们可以认为，进程有三个主要状态：</p>
<p>1.运行 Running<br>        正在被执行、正在等待执行或者最终将会被执行<br>2.停止 Stopped<br>        执行被挂起，在进一步通知前不会计划执行<br>3.终止 Terminated<br>        进程被永久停止</p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p><img src="/home/alex/图片/2018-44.png" alt="filename alredy exists, renamed"></p>
<h3 id="程序的加载和运行"><a href="#程序的加载和运行" class="headerlink" title="程序的加载和运行"></a>程序的加载和运行</h3><p><img src="/home/alex/图片/taipei.png" alt="upload succesful"></p>
<p><img src="/home/alex/图片/jiazai.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/2018-45.png" alt="filename alrdy exists, renamed"></p>
<p><img src="/home/alex/图片/ke.png" alt="upload succesul"></p>
<p>entry point 是可执行目标文件ELF头 的entry point</p>
<p>所以程序的加载和运行就是一个进程切换到另外一个进程，中间要进行上下文切换。切换新进程的时候先要创建一个进程（fork），然后exec，然后运行main</p>
<p><img src="/home/alex/图片/fork.png" alt="upload successful"></p>
<p>第一个参数先压栈，最后一个参数最后压栈，注意上图，argv是一个指针，指向一个数组，即图中argv【0】处，每一个元素又本身是一个指针，指向一个字符串，envp也是一个指针数组，每一个元素指向一个环境变量。</p>
<p>然后如果main函数调用了其它函数，就会又长出一个栈帧，这就是程序加载与运行的过程。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>可以用kill函数发射信号</p>
<p>子进程陷入无限循环，则父进程发射KILL信号，终结子进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void forkandkill()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid[N];</span><br><span class="line">    int i;</span><br><span class="line">    int child_status;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">        if ((pid[i] = fork()) == 0)</span><br><span class="line">            while(1) ;  // 死循环</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Killing process %d\n&quot;, pid[i]);</span><br><span class="line">        kill(pid[i], SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid_t wpid = wait(&amp;child_status);</span><br><span class="line">        if (WIFEXITED(child_status))</span><br><span class="line"> printf(&quot;Child %d terminated with exit status  %d\n&quot;,wpid,WEXITSTATUS(child_status));</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Child %d terminated abnormally\n&quot;, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>所有上下文切换都是通过调用某个异常处理器（exception handler）完成的，内核会计算对易于某个进程p的pnb值：pnb=pending&amp;~blocked</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void unix_error(char *msg) /* Unix-style error */</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sigint_handler(int sig) // SIGINT 处理器</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;想通过 ctrl+c 来关闭我？\n&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    sleep(1);</span><br><span class="line">    printf(&quot;OK. :-)\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 设定 SIGINT 处理器</span><br><span class="line">    if (signal(SIGINT, sigint_handler) == SIG_ERR)</span><br><span class="line">        unix_error(&quot;signal error&quot;);</span><br><span class="line">        </span><br><span class="line">    // 等待接收信号</span><br><span class="line">    pause();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/maye.png" alt="upload succeful"></p>
<p>信号处理器的工作流程可以认为是和当前用户进程“并发”的同一个伪进程。</p>
<h4 id="并行与并发的区别"><a href="#并行与并发的区别" class="headerlink" title="并行与并发的区别"></a>并行与并发的区别</h4><p>并行：多个CPU同时执行程序</p>
<p>并发(concurrent)：即使只有一个CPU，但操作系统能够把程序的执行单位细化，然后分开执行。是一种伪并行执行</p>
<h4 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h4><p>内核会阻塞与当前在处理的信号同类型的其他正在等待的信号，也就是说一个SIGINT信号处理是不能被另外一个SIGINT信号中断的。</p>
<p>如果要显示阻塞，需要用sigprocmask函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sigset_t mask, prev_mask;</span><br><span class="line">Sigemptyset(&amp;mask); // 创建空集</span><br><span class="line">Sigaddset(&amp;mask, SIGINT); // 把 SIGINT 信号加入屏蔽列表中</span><br><span class="line">// 阻塞对应信号，并保存之前的集合作为备份</span><br><span class="line">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line">...</span><br><span class="line">... // 这部分代码不会被 SIGINT 中断</span><br><span class="line">...</span><br><span class="line">// 取消阻塞信号，恢复原来的状态</span><br><span class="line">Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL);</span><br></pre></td></tr></table></figure>
<p>并行访问可能会导致数据毁坏问题，以下是一些编写程序的规则。</p>
<pre><code>规则 1：信号处理器越简单越好
    例如：设置一个全局的标记，并返回
规则 2：信号处理器中只调用异步且信号安全(async-signal-safe)的函数
    诸如 printf, sprintf, malloc 和 exit 都是不安全的！
规则 3：在进入和退出的时候保存和恢复 errno
    这样信号处理器就不会覆盖原有的 errno 值
规则 4：临时阻塞所有的信号以保证对于共享数据结构的访问
    防止可能出现的数据损坏
规则 5：用 volatile 关键字声明全局变量
    这样编译器就不会把它们保存在寄存器中，保证一致性
规则 6：用 volatile sig_atomic_t 来声明全局标识符(flag)
    这样可以防止出现访问异常
</code></pre><p>异步信号安全：指的是如下两类函数：</p>
<p>1.所有的变量都保存在栈帧当中<br>2.不会被信号中断的函数</p>
<h3 id="非本地跳转-Non-local-jump"><a href="#非本地跳转-Non-local-jump" class="headerlink" title="非本地跳转 Non local jump"></a>非本地跳转 Non local jump</h3><p>从一个函数跳转到另一个函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setjmp 保存当前程序的堆栈上下文环境(stack context)，注意，这个保存的堆栈上下文环境仅在调用 setjmp 的函数内有效，如果调用 setjmp 的函数返回了，这个保存的堆栈上下文环境就失效了。调用 setjmp 的直接返回值为 0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">longjmp 将会恢复由 setjmp 保存的程序堆栈上下文，即程序从调用 setjmp 处重新开始执行，不过此时的 setjmp 的返回值将是由 longjmp 指定的值。注意longjmp 不能指定0为返回值，即使指定了 0，longjmp 也会使 setjmp 返回 1。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf env;</span><br><span class="line">P1()</span><br><span class="line">&#123;</span><br><span class="line">    if (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">        // 跳转到这里</span><br><span class="line">    &#125; else </span><br><span class="line">    &#123;</span><br><span class="line">        P2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">P2()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    P2();</span><br><span class="line">    ...</span><br><span class="line">    P3();</span><br><span class="line">&#125;</span><br><span class="line">P3()</span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/kundao.png" alt="uploadccessful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf env;</span><br><span class="line">P1()</span><br><span class="line">&#123;</span><br><span class="line">    P2(); P3();</span><br><span class="line">&#125;</span><br><span class="line">P2()</span><br><span class="line">&#123;</span><br><span class="line">    if (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">        // 跳转到这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P3()</span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为P2在跳转的时候，已经在P3前返回了，内存已经清理了其对应的栈帧，所以P3的longjmp不能实现期望的操作。</p>
<h4 id="CSAPP-家庭作业"><a href="#CSAPP-家庭作业" class="headerlink" title="CSAPP 家庭作业"></a>CSAPP 家庭作业</h4><p>waitpid函数的作用：</p>
<p>当指定等待的子进程以及停止运行或者结束了，waitpid函数会立即返回，如果子进程还没有停止运行或者结束，调用waitpid的父进程会被祖塞，暂停运行</p>
<p>8.18<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void end()&#123;</span><br><span class="line">  </span><br><span class="line">      printf(&quot;2&quot;);fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">     if(fork()==0)</span><br><span class="line">        atexit(end);</span><br><span class="line">     if(fork()==0)&#123;</span><br><span class="line">        printf(&quot;0&quot;);fflush(stdout);</span><br><span class="line">      &#125;</span><br><span class="line">     else&#123;</span><br><span class="line">        printf(&quot;1&quot;);fflush(stdout);</span><br><span class="line">     &#125;</span><br><span class="line">      exit(0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个子进程的atexit函数把end函数添加到函数列表中，那么这个子进程生成的两个子进程的堆栈中也会有end函数，但是另外父进程则独立，不受影响，即使wxit也不会有反应。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/07/IA-32-linux中的地址转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/IA-32-linux中的地址转换/" itemprop="url">CSAPP-IA-32/linux中的地址转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T15:28:00+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/home/alex/图片/2018-32.png" alt="filename alrady exists, renamed"></p>
<p><img src="/home/alex/图片/IA32.png" alt="upload succeful"></p>
<p>1.逻辑地址-》线性地址是 分段<br>2.线性地址-》内存地址是 分页</p>
<p>这里的8是偏移量A<br>%ebp是基址寄存器B，%esp是变址寄存器I，4是比例因子S</p>
<h3 id="分段过程"><a href="#分段过程" class="headerlink" title="分段过程"></a>分段过程</h3><p>线性地址的计算</p>
<p><img src="/home/alex/图片/duanxuanze.png" alt="upload sucsful"></p>
<p>段选择符是在上图的段寄存器里面的</p>
<p><img src="/home/alex/图片/dizhizhuanhuan.png" alt="upload success"></p>
<p>段选择符就相当于index位，分段方式中有一个”段表“（在主存），段表记录了段的长度，段开始的地方，存取权限等。</p>
<p>线性地址 = 段基址+有效地址</p>
<p>有效地址 = 基址寄存器+变址寄存器×比例因子</p>
<p>有效地址实际上是一个段内的偏移量，首地址+段内偏移量 = 线性地址。</p>
<p><img src="/home/alex/图片/duan.png" alt="upload succesful"></p>
<p>得到的线性地址再通过分页，通过页表转换为主存地址</p>
<h3 id="段寄存器的含义"><a href="#段寄存器的含义" class="headerlink" title="段寄存器的含义"></a>段寄存器的含义</h3><p><img src="/home/alex/图片/2018-33.png" alt="filename already exists, rend"></p>
<p>RPL： 最后两位表示管理状态（request privilege level）</p>
<p><img src="/home/alex/图片/2018-35.png" alt="filename alreadmed"></p>
<h3 id="段描述符和段描述符表"><a href="#段描述符和段描述符表" class="headerlink" title="段描述符和段描述符表"></a>段描述符和段描述符表</h3><p><img src="/home/alex/图片/2018-36.png" alt="filename already exists, renamed"></p>
<p>什么叫任务状态段？</p>
<p>这里的任务指的是进程，就是进程执行到某个阶段的时候，CS.SS.EIP，ESP，GPR内容等信息（代码算段，堆栈段，指令指针，栈指针，通用寄存器内容等）</p>
<p>中断门描述符记录了处理中断等异常处理的程序的首地址</p>
<p><img src="/home/alex/图片/logical.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/2018-37.png" alt="filename already enamed"></p>
<p>为了减少从主存中找段描述符，使用cache</p>
<p><img src="/home/alex/图片/cc.png" alt="upload succsful"></p>
<p><img src="/home/alex/图片/2018-38.png" alt="upload suessful"></p>
<p>TSS描述符在进行进程切换的时候，TR里面的内容也要进行切换。</p>
<p>所有表的起始地址是放在GDR，而所有异常中断程序的首地址放在IDT，IDT的首地址也放在IDTR里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GDT和IDT只有一个，GDTR 和 IDTR指向各自起始的地方，根据TR取GDT中的TSS描述符的时候，GDTR给出首地址</span><br></pre></td></tr></table></figure>
<h4 id="Linux的全局段描述符表"><a href="#Linux的全局段描述符表" class="headerlink" title="Linux的全局段描述符表"></a>Linux的全局段描述符表</h4><p><img src="/home/alex/图片/GDT.png" alt="upload sucssful"></p>
<p>最后两位是RPL,都为0表示其在第0环，位于内核</p>
<p>倒数第三位表示这个描述符在GDT中，剩下的位便是索引号，<br>TSS索引是0x0010,即全局描述符表的第16项，LDT索引是0x0011，是第17项</p>
<p>因此在上上图中，操作系统会分别把0x80与0x88放在TR与LDTR中</p>
<h4 id="逻辑地址向线性地址转换"><a href="#逻辑地址向线性地址转换" class="headerlink" title="逻辑地址向线性地址转换"></a>逻辑地址向线性地址转换</h4><p><img src="/home/alex/图片/GDTR.png" alt="upload succesful"></p>
<p>逻辑地址（48位）=》 线性地址（32位）</p>
<p>16位的段选择符，根据TI选择去GDT还是去LDT，其中GDT，LDT的首地址分别存储在GDTR和LDTR里面，（不可见寄存器）</p>
<p><strong><em>段描述符 = 首地址+8×段选择符的索引</em></strong></p>
<p>所以得到的段基地址加上段偏移量，就得到32位线性地址</p>
<p>段描述符只有在第一次进行访问，访问过后就放在了cache里面，所以之后求线性地址，只需要在cache里面取基地址然后相加就行</p>
<p><img src="/home/alex/图片/risc.png" alt="upoad successful"></p>
<p>1.就是初始化时候上述4个段描述符放在GDT中<br>2.每个段都被初始化在0-4GB的线性地址空间中</p>
<p><img src="/home/alex/图片/ldtgdt.png" alt="uploauccessful"></p>
<p><img src="/home/alex/图片/2018-39.png" alt="filename already exists, reamed"></p>
<p>有效地址（偏移量） = 基址寄存器+变址寄存器×比例因子</p>
<p><img src="/home/alex/图片/2018-40.png" alt="filename alreay exists, renamed"></p>
<p>所以<strong><em>线性地址就等于EA = 有效地址 </em></strong></p>
<p>线性地址 = 基地址+有效地址</p>
<p>所谓EA其实只是一个segment内的一个段内偏移量</p>
<p><img src="/home/alex/图片/logic.png" alt="upload succeul"></p>
<p>指令的线性地址 = 代码段基地址+有效地址，而linux编译器默认了代码段基地址位0，因此指令的线性地址就等于有效地址就等于段的偏移量。</p>
<p>而数据的线性地址 = 数据段基地址+EA =0+ R[ECX]+R[EDX]*4</p>
<p>0X8048A00+(400)的16进制，注意进制的转换</p>
<h3 id="分页过程（线性地址-》物理地址）"><a href="#分页过程（线性地址-》物理地址）" class="headerlink" title="分页过程（线性地址-》物理地址）"></a>分页过程（线性地址-》物理地址）</h3><p>如果页大小为4KB，每个页表项占4B则理论上一个页表大小：</p>
<p>项个数：2^32/2^12 = 2^20 ，因此每个页表大小位4MB</p>
<p>比页还要大，因此采用多级页表方式来存储</p>
<p>—————————————————————————————————————————</p>
<p><img src="/home/alex/图片/2018-41.png" alt="filename already exists, red"></p>
<p>IA-32采用二级页表方式来存储</p>
<p><img src="/home/alex/图片/yedizhi.png" alt="upload sucssful"></p>
<p>每个页表起始位置按4KB对齐意思就是每个页表起始的20位都是相同的，只有后面的12位（4KB）不同</p>
<p><img src="/home/alex/图片/mmu.png" alt="upload"></p>
<p><img src="/home/alex/图片/imge.png" alt="upload succeul"></p>
<p>MMU 完成从逻辑地址到线性地址的过程</p>
<h3 id="CPL-RPL-DPL区别与联系"><a href="#CPL-RPL-DPL区别与联系" class="headerlink" title="CPL,RPL,DPL区别与联系"></a>CPL,RPL,DPL区别与联系</h3><p>1.CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。
　　</p>
<p>2.RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。
　　　　</p>
<p>3.DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。<br>当进程访问一个段时，需要进程特权级检查，一般要求DPL &gt;= max {CPL, RPL}</p>
<p>下面打一个比方，中国官员分为6级国家主席1、总理2、省长3、市长4、县长5、乡长6，假设我是当前进程，级别总理（CPL=2）,我去聊城市(DPL=4)考察(呵呵),我用省长的级别(RPL=3 这样也能吓死他们:-))去访问,可以吧，如果我用县长的级别，人家就不理咱了(你看看电视上的微服私访，呵呵)，明白了吧！为什么采用RPL，是考虑到安全的问题，就好像你明明对一个文件用有写权限，为什么用只读打开它呢，还不是为了安全！</p>
<p>ref：<a href="https://blog.csdn.net/better0332/article/details/3416749" target="_blank" rel="noopener">https://blog.csdn.net/better0332/article/details/3416749</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/06/CSAPP-Virtural-Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/CSAPP-Virtural-Memory/" itemprop="url">CSAPP-Virtural Memory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T20:12:21+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>为每个进程提供了一个大的，一致的和私有的地址空间。</p>
<p>1.把主存看成是一个存储在磁盘上的地址空间的高速缓存</p>
<p>2.为每个进程提供了一致的地址空间，简化了内存管理</p>
<p>3.保护每个进程的地址空间不被其他进程破坏</p>
<h3 id="早期分页方式的概念"><a href="#早期分页方式的概念" class="headerlink" title="早期分页方式的概念"></a>早期分页方式的概念</h3><p>大白话：程序是在逻辑空间上写的，而是在物理空间上运行，所以要解决逻辑空间与物理空间之间的映射。</p>
<p><img src="/home/alex/图片/page.png" alt="upload successf"></p>
<p>就是程序可能会有2^16byte长，但是物理容量只有4K</p>
<p><img src="/home/alex/图片/2018-26.png" alt="filename alrady exists, renamed"></p>
<p>这个区号意思就是说，地址空间0-4095对应page 1，4096-8192对应page2</p>
<p><strong><em>区间就是页(page)，主存中存放页的区域成为页框</em></strong></p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p><img src="/home/alex/图片/paging.png" alt="upload succesul"></p>
<p><img src="/home/alex/图片/dazi.png" alt="upad successful"></p>
<p>逻辑地址 1：30  1作为地址空间索引号（页号），30作为内容</p>
<p>14代表页框号 </p>
<p>所以页表就是用来映射页号和物理地址中的页框号</p>
<p><img src="/home/alex/图片/durian.png" alt="upload successl"></p>
<p>页框之间内容可以离散，页框内部内容连续</p>
<h3 id="虚拟存储系统"><a href="#虚拟存储系统" class="headerlink" title="虚拟存储系统"></a>虚拟存储系统</h3><p>大白话：程序可能很长，但是主存容量有限，于是把活跃的程序段放到主存中运行，然后自动进行切换</p>
<p>实质：</p>
<p>1.程序员在比实际主存空间大得多的逻辑地址空间中编写程序</p>
<p>2.程序执行的时候，要把当前需要的程序段以及相应的数据块调入主存当中，不用的部分放在磁盘上</p>
<h4 id="虚拟存储技术的实质"><a href="#虚拟存储技术的实质" class="headerlink" title="虚拟存储技术的实质"></a>虚拟存储技术的实质</h4><p>进程调入物理主存的空间（程序中活跃的片段占用了主存的物理空间）</p>
<p><img src="/home/alex/图片/xuange.png" alt="upload successl"></p>
<p>每个程序会有一个页表来说明它这一页的情况<br>（在磁盘上/内存上/空页）</p>
<p><img src="/home/alex/图片/vmm.png" alt="upload successl"></p>
<p>cpu拿到的是虚拟地址，要求转化为主存地址，而这个过程是在执行指令的时候完成的，只能通过硬件来完成</p>
<p><img src="/home/alex/图片/2018-27.png" alt="filename already exists, med"></p>
<p>加载一个可执行文件，执行的时候，不会实际上把数据都加载到内存当中，而是生成该程序对应的一个页表。然后按照按需调页原则，通过pageFault异常来实现，把数据装入到内存当中。</p>
<h4 id="主存–磁盘"><a href="#主存–磁盘" class="headerlink" title="主存–磁盘"></a>主存–磁盘</h4><p><img src="/home/alex/图片/images.png" alt="upload successl"></p>
<p>因为访问磁盘的时间会比较长，因此要尽可能减少磁盘的次数</p>
<p>write back 只写主存，不写磁盘</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>用结构数组来实现</p>
<p><img src="/home/alex/图片/vlid.png" alt="upload successfu"></p>
<p>装入位-&gt;valid bit</p>
<p>修改位-&gt;dirty bit</p>
<p>替换控制位-&gt;根据其使用情况，决定该page是淘汰掉还是保留<br>eg（LRU.LMU）</p>
<p>实页号-&gt;页框号</p>
<p><strong>每个进程有一个页表，其中有装入位，dirty位，替换控制位，访问权限位（确定是否可读/可写）还有禁止缓存位，实页号</strong></p>
<p>一个页数的项数有什么来决定？<strong>虚拟地址空间大小来决定</strong></p>
<p>项数 = 虚拟地址空间大小 / 页大小</p>
<p>4GB/4KB = 2^20 项</p>
<p>每个进程的页表大小一样吗？</p>
<p><strong><em>各个进程有相同虚拟空间，所以理论上一样。实际大小看具体实现方式，如“空洞：页面如何处理</em></strong></p>
<p><img src="/home/alex/图片/2018-28.png" alt="fil"></p>
<p>页表分三种</p>
<p><img src="/home/alex/图片/ju.png" alt="upload successl"></p>
<h4 id="逻辑地址转换为物理地址"><a href="#逻辑地址转换为物理地址" class="headerlink" title="逻辑地址转换为物理地址"></a>逻辑地址转换为物理地址</h4><p><img src="/home/alex/图片/VA.png" alt="upload success"></p>
<p>VA：VIRTUAL ADDRESS</p>
<p>类比于全相连cache，地址只有两部分，高位的tag，低位的偏移量。这里也是类似，page no,表示页表索引，页表基址存放在一个寄存器当中，<strong><em>页表的地址 = 基址+页表索引×页框大小</em></strong> </p>
<p>PF： frame no. ，即物理页号，其加上disp偏移量就等于PA，物理地址。</p>
<p>V = 0时，发生缺页。</p>
<h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p>这个时候就需要操作系统来帮忙处理</p>
<p><img src="/home/alex/图片/vm2.png" alt="upload success"></p>
<h4 id="TLB（快表）"><a href="#TLB（快表）" class="headerlink" title="TLB（快表）"></a>TLB（快表）</h4><p><img src="/home/alex/图片/um.png" alt="upload sssful"></p>
<p>全相连中，tag = 标签号，没有组号</p>
<p>组相连当中，虚页号高位作为tag，低位作为组号（index）</p>
<p><img src="/home/alex/图片/TLB.png" alt="upload succe"></p>
<p>1.从virtual page中得到虚页号，把虚页号与TLB中的tag作比较，如果valid=0 or valid = 1 but tag!=VA,then 发生缺页。</p>
<p>2.于是从主存的页表(慢表)开始寻找，由于页表中的表项是按照索引号排列的，所以并不需要tag号。如果V=0，还找不到，则时候就要到外存当中的磁盘找对应的表项。</p>
<p>3.如果找到了，可以直接从page frame中生成物理地址号，这样就不需要访问向前面部分介绍的那样，访问主存。</p>
<p><strong><em>所以引入快表（在cache）目的就是减少主存的访问次数，提高逻辑地址与物理地址转换的速度。</em></strong></p>
<p><img src="/home/alex/图片/cmt.png" alt="upload successfl"></p>
<p>最理想路径： VA-&gt;HIT1-&gt;HIT3-&gt;CPU 不用访问主存</p>
<p>如果发生了TLB缺失（miss1），在主存中的的页表中寻找，如果找到了就是hit2，继续送到cache里面，否则就是miss 2 ，发生page fault</p>
<p>如果送到cache，cache miss了，就发生miss 3，从主存那里找。</p>
<h5 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h5><p><img src="/home/alex/图片/2018-30.png" alt="filename already exists, renaed"></p>
<p>最上面那一段属于页表，中间段属于TLB，下面那一段是cache</p>
<p>大概过程：虚拟地址从TLB表中寻找，如果找不到就去页表找，然后映射为物理地址后，物理地址在cache中找，找不到就访问主存，从主存中找。</p>
<p>虚拟地址分为20位的虚拟页号，12位的页内地址</p>
<p>上图中由于是组相连，因此虚拟页号分为tag标记以及组索引，当v=1而且TLB标记等于标记号的时候，就找到了物理页号，然后物理页号与虚拟地址的业内地址结合起来，就找到了物理地址。然后物理地址就又分为标记号，组索引以及块内地址，于cache中寻找所要寻找的字节。</p>
<p><img src="/home/alex/图片/ca.png" alt="upload successl"></p>
<p>缺页处理是由操作系统来作的</p>
<p><img src="/home/alex/图片/HMM.png" alt="upload ful"></p>
<p>如果不在页表当中，就绝对不可能再快表当中；如果页表缺失，说明信息不在主存，cache也一定不可能有！</p>
<p>三个都miss过程：</p>
<p>1.快表miss，去页表（在主存）中找，访存1次</p>
<p>2.页表miss，只能从磁盘中寻找，访问磁盘一次</p>
<p>3.cache miss，从主存当中寻找，访存第二次</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="/home/alex/图片/lee.png" alt="upload succesul"></p>
<p>页表项数： 虚拟地址大小 / 页大小</p>
<p><img src="/home/alex/图片/phy.png" alt="upload succesl"></p>
<p>虚拟地址中，高8位就是虚拟页号，低6位就是偏移量。</p>
<p>物理地址中，高6位是实页号，低6号是偏移量。</p>
<p>快表：</p>
<p><img src="/home/alex/图片/bufen.png" alt="upload successl"></p>
<p>16个TLB项，4路组相连，说明TLBI是2，剩下6位就是tag位</p>
<p>快表中0A34数据有误，因为其VPN就是tag+set号</p>
<p> tag是0A,set是03，所以VPN为 00101011 就是0x2B</p>
<p>但是在慢表中，0x2Bvalid位是0，所以说明数据有误</p>
<p>cache：</p>
<p><img src="/home/alex/图片/china.png" alt="upload succesful"></p>
<p>一共有16行，所以CI是4，偏移量是2（主存块4B）</p>
<p><img src="/home/alex/图片/jizz.png" alt="upload succesul"></p>
<p>VPN = 0xF TLBI = 0x3 TLBT = 0x3</p>
<p>即在快表的第三组中找tag==3的，找到了，说明其命中，没有page fault，PPN是0D</p>
<p>0D = 1101</p>
<p>所以物理地址为（PPN+VPO）<br>001101010100</p>
<p>C0 = 00<br>CI = 0101<br>CT = 001101</p>
<p>在cache中找第5行，tag为001101的16位数据</p>
<p>B0 = 36 B1 = 72</p>
<p>所以要找的数据是7236(小端，高位数据在高位)</p>
<h4 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h4><p>分段方式很好管理，但是占的空间多，储存空间管理不好管理。</p>
<p><img src="/home/alex/图片/fenduan.png" alt="oad successful"></p>
<p><img src="/home/alex/图片/2018-31.png" alt="file already exists, renamed"></p>
<h4 id="段页式存储器"><a href="#段页式存储器" class="headerlink" title="段页式存储器"></a>段页式存储器</h4><p><img src="/home/alex/图片/ta.png" alt="upload succful"></p>
<h5 id="练习题9-5"><a href="#练习题9-5" class="headerlink" title="练习题9.5"></a>练习题9.5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">char *bufp</span><br><span class="line"></span><br><span class="line">//fd 为open函数返回的文件描述符</span><br><span class="line">void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offset)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建一个包含size字节的只读，私有，请求二进制0的虚拟内存区域，如果调用成功，bufp则为新区域的地址</span><br><span class="line">bufp = Mmap(NULL,size,PROT_READ,MAP_PRIVATE|MAP_ANON,0,0);</span><br></pre></td></tr></table></figure>
<p>用以上函数，讲一个任意大小的磁盘文件复制到stdout，文件名作为一个命令行参数传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;csapp.h&gt;</span><br><span class="line"></span><br><span class="line">void mmapcopy(int fd,int size)&#123;</span><br><span class="line">    char *bufp;</span><br><span class="line">    bufp = Mmap(NULL,size,PROT_READ,MAP_PRIVATE,fd,0);</span><br><span class="line">    Write(1,bufp,size);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">    if(argc!=2)&#123;</span><br><span class="line">        printf(&quot;usage: %s &lt;filename&gt;\n&quot;,argv[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int fd;</span><br><span class="line">    struct stat stat;</span><br><span class="line">    fd = Open(argv[0],O_RDONLY,0);</span><br><span class="line">    fstat(fd,&amp;stat);</span><br><span class="line">    mmapcopy(fd,stat.st_size);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//文件描述符的用法<br>//<a href="https://blog.csdn.net/u012736748/article/details/74626145" target="_blank" rel="noopener">https://blog.csdn.net/u012736748/article/details/74626145</a></p>
<p>文件描述符是一个索引，指向内核为每一个进程所维护的该进程打开文件的记录表。</p>
<h4 id="删除虚拟地址"><a href="#删除虚拟地址" class="headerlink" title="删除虚拟地址"></a>删除虚拟地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int mummap（void *start,size_t length）;</span><br></pre></td></tr></table></figure>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><h4 id="usage-of-malloc-package"><a href="#usage-of-malloc-package" class="headerlink" title="usage of malloc package"></a>usage of malloc package</h4><p><img src="/home/alex/图片/mallocz.png" alt="upload scessful"></p>
<p><img src="/home/alex/图片/2018-71.png" alt="fildy existsenamed"></p>
<p>可以通过诸如malloc,new等方法让程序运行的时候得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，叫做堆。</p>
<p>分配器以块为单位来维护堆，可以进行分配或者释放。有两种类型：</p>
<pre><code>1.显式分配器：应用分配并且回收空间（malloc &amp; free）
2.隐式分配器，只负责分配，但是不负责回收（JAVA中的垃圾收集）
</code></pre><p>过程如下：</p>
<p><img src="/home/alex/图片/malloc.png" alt="upload "></p>
<p><img src="/home/alex/图片/gg.png" alt="upload"></p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>假设给定一个malloc和free的请求的序列目标是尽可能提高吞吐量和内存利用率。</p>
<p>吞吐量： 单位时间内完成的请求数量。</p>
<p>内存利用率：主要影响因素是内存碎片。</p>
<h5 id="内部碎片"><a href="#内部碎片" class="headerlink" title="内部碎片"></a>内部碎片</h5><p><img src="/home/alex/图片/内存碎片.png" alt="upld successful"></p>
<h5 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h5><p><img src="/home/alex/图片/外部.png" alt="upload ssful"></p>
<h4 id="Peak-Memory-Utilization"><a href="#Peak-Memory-Utilization" class="headerlink" title="Peak Memory Utilization"></a>Peak Memory Utilization</h4><p><img src="/home/alex/图片/per.png" alt="upload susful"></p>
<h4 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h4><h5 id="how-to-free"><a href="#how-to-free" class="headerlink" title="how to free"></a>how to free</h5><p><img src="/home/alex/图片/implementation.png" alt="upload successf"></p>
<p>pointer 前面用一个word记录block size</p>
<p>free的时候，访问指针前一个word就可以知道blocksize了</p>
<h5 id="keeping-track-of-free-blocks"><a href="#keeping-track-of-free-blocks" class="headerlink" title="keeping track of free blocks"></a>keeping track of free blocks</h5><p><img src="/home/alex/图片/how.png" alt="uploadsuccessful"></p>
<h5 id="implicit-free-lists"><a href="#implicit-free-lists" class="headerlink" title="implicit free lists"></a>implicit free lists</h5><p><img src="/home/alex/图片/2018-72.png" alt="filename alredy exists, renamed"></p>
<p>因为每一个block是8-byte alignment的，因此最后3位必定都是0，所以可以利用最后一位来存储该块是否已经分配</p>
<h5 id="example"><a href="#example" class="headerlink" title="example"></a>example</h5><p><img src="/home/alex/图片/2018-73.png" alt="filenamey exists, renamed"></p>
<h5 id="Finding-a-free-block"><a href="#Finding-a-free-block" class="headerlink" title="Finding a free block"></a>Finding a free block</h5><p><img src="/home/alex/图片/2018-74.png" alt="filename already exists, renamd"></p>
<p>这里的 <em>p &amp; -2 -&gt;  </em>p &amp; 1111111…110 即得到block的size ，i.e mask out the last bit</p>
<h5 id="allocating-in-free-block"><a href="#allocating-in-free-block" class="headerlink" title="allocating in free block"></a>allocating in free block</h5><p><img src="/home/alex/图片/alloc.png" alt="upload succesul"></p>
<h5 id="freeing-a-block"><a href="#freeing-a-block" class="headerlink" title="freeing a block"></a>freeing a block</h5><p><img src="/home/alex/图片/freeing.png" alt="upload cessful"></p>
<h5 id="Coalescing"><a href="#Coalescing" class="headerlink" title="Coalescing"></a>Coalescing</h5><p><img src="/home/alex/图片/coalescing.png" alt="upload succsful"></p>
<p>next pointer points to where 2 stores</p>
<p>如果2开头的block是空的，那么 <em>p = </em>p +*next</p>
<p>意思就是说4 = 4+2 = 6</p>
<h5 id="Explicit-Free-Lists"><a href="#Explicit-Free-Lists" class="headerlink" title="Explicit Free Lists"></a>Explicit Free Lists</h5><p><img src="/home/alex/图片/VM.png" alt="upload succeful"></p>
<h3 id="一些区别"><a href="#一些区别" class="headerlink" title="一些区别"></a>一些区别</h3><p>explicit empty list &amp; implicit empty list</p>
<p>隐式的话，分配时间是块总数线性时间，而显式的话，是空闲块数量的线性时间，一般来说显式会比隐式更快。</p>
<p>first fit &amp;&amp; next fit &amp;&amp; best fit</p>
<p>首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。</p>
<p>下一次适配：从上一次搜索结束的位置开始搜索。</p>
<p>最佳适配：检索每一个空闲块，选择适合需求的最小空闲块。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/06/Stack-Pointer-Frame-Pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Stack-Pointer-Frame-Pointer/" itemprop="url">Stack Pointer/Frame Pointer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T14:16:08+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Stack-Frame"><a href="#Stack-Frame" class="headerlink" title="Stack Frame"></a>Stack Frame</h3><p><img src="/home/alex/图片/2018-18.png" alt="fil"></p>
<p>firstly, callee stack save the old caller ‘s stack ‘s ebp</p>
<p>lastly, the argument build means the arguments for calling any other function </p>
<p><img src="/home/alex/图片/2.png" alt="upload successfl"></p>
<p>pushl $zip2,$zip1 把参数压进栈顶，然后call swap，会把caller的return address压入栈</p>
<h3 id="whole-code"><a href="#whole-code" class="headerlink" title="whole code"></a>whole code</h3><p><img src="/home/alex/图片/whole.png" alt="upload succesful"></p>
<h4 id="set-up-code"><a href="#set-up-code" class="headerlink" title="set up code"></a>set up code</h4><p><img src="/home/alex/图片/2018-19.png" alt="filename already exists, amed"></p>
<p>一. push %ebp 把caller的 bast pointer 的数值压栈</p>
<p>二.movl %esp,%ebp （把esp 移动到ebp，即设置ebp = esp，这一步是设置callee的base pointer）</p>
<p>三.%ebx 是swap过程中可能会调用的参数</p>
<p><a href="https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html</a></p>
<p>附上：EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。</p>
<p>EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。</p>
<p>ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</p>
<p>EDX 则总是被用来放整数除法产生的余数。</p>
<p>但是对于　%eax,%ecx,%edx　不能像ｅｂｘ一样，保存在callee中</p>
<h4 id="body-code"><a href="#body-code" class="headerlink" title="body code"></a>body code</h4><p><img src="/home/alex/图片/ebp.png" alt="upload successfl"></p>
<h4 id="finish-code"><a href="#finish-code" class="headerlink" title="finish code"></a>finish code</h4><p><img src="/home/alex/图片/sp.png" alt="upload sucu"></p>
<ol>
<li>%ebp-4 就是 old %ebx 的地址 ，把-4（%ebp）移到%ebx，相当于把原来的%ebx复原</li>
</ol>
<p>2.第二是 把 %ebp 移到 %esp，即现在%esp指向%ebp</p>
<p>(第一第二条指令相当于 pop %ebx)<br><img src="/home/alex/图片/d.png" alt="upload successf"></p>
<p>3.popl %ebp<br>本质上是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0(%esp),%ebp </span><br><span class="line">%esp +4</span><br></pre></td></tr></table></figure></p>
<p>这个时候base pointer复原，变回caller stack　的数值</p>
<p>４.ret 根据返回地址返回</p>
<p>其中leave instruction<br>等价于<br>mov ％ebp,%esp</p>
<p>popl %ebp</p>
<h3 id="register-saving-convention"><a href="#register-saving-convention" class="headerlink" title="register saving convention"></a>register saving convention</h3><p><img src="/home/alex/图片/tong.png" alt="upload succesul"></p>
<p>yoo当中，我们希望%edx不会因为调用了who函数之后发生改变，问题是，who调用过程中，%edx是可能发生改变的。</p>
<p>因此我们要制定convention，在使用这些寄存器之前先保存他们！</p>
<p><img src="/home/alex/图片/2018-20.png" alt="filename already exists, rnamed"></p>
<p>分类如下<br><img src="/home/alex/图片/2018-21.png" alt="fileame already exists, renamed"></p>
<p>%eax save the return address so it is caller saved register</p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p><img src="/home/alex/图片/2018-22.png" alt="filename already exis, renamed"></p>
<p><img src="/home/alex/图片/you.png" alt="upload successf"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.pushl %ebp #save the caller&apos;s ebp</span><br><span class="line"></span><br><span class="line">2.movl %esp,%ebp  #set callee&apos;s ebp</span><br><span class="line"></span><br><span class="line">3.subl $16,%esp   # add 16 bytes, add temporary space</span><br><span class="line"></span><br><span class="line">4.movl 8(%ebp),%edx  # set edx = x</span><br><span class="line"></span><br><span class="line">5.movl $1,-4(%ebp)</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/2018-23.png" alt="filename already eists, renamed"></p>
<p>两个pushl 相当于把 s_helper函数的两个参数传了进去</p>
<p>&amp;val始终指向val，当函数结束的时候，返回的值就保存在了-4(%ebp)当中</p>
<p><img src="/home/alex/图片/st.png" alt="upload sucessful"></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>1.若调用函数有多个参数，stack从下到上，依次为第一个，第二个函数。</p>
<p>2.函数调用的参数在stack的上方，就是在caller准备好参数后再调用callee,就是说argument 是caller saved 的</p>
<p>3.函数结果返回在%eax</p>
<p>4.local variable 是存放在 callee-saved registers那里</p>
<h3 id="x86-64-conventions"><a href="#x86-64-conventions" class="headerlink" title="x86-64 conventions"></a>x86-64 conventions</h3><p>在x86 中，由于registers 的数目变多，因此可以把local variable 和argument存储在register当中，那样就可以减少对stack 的使用了</p>
<p>下图是16个 8-byte gpr<br><img src="/home/alex/图片/2018-24.png" alt="filename exists, rena"></p>
<p>黄色的是caller saved</p>
<p>绿色的是 callee saved</p>
<h4 id="specifications"><a href="#specifications" class="headerlink" title="specifications"></a>specifications</h4><p><img src="/home/alex/图片/dij.png" alt="up"></p>
<p>1.用callq 而不用call，因为要返回一个64-bit address,also decrement 8而不是4（8 bytes）</p>
<p>2.因为gpr实现了ebp / rbp 功能，因此不需要使用stack来更新 ，而且rsp能代替实现frame pointer 的功能</p>
<p>3.由于gpr只有6个argument register，所以当函数参数少于六个的时候，不需要用到栈结构</p>
<h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><p><img src="/home/alex/图片/y.png" alt="upload successfu"></p>
<p>q - 8byte - 64bits</p>
<p>l - 4byte - 32bits</p>
<p>w - 2byte - 16bits</p>
<p>b - 1byte - 8bits</p>
<p><img src="/home/alex/图片/2018-25.png" alt="filename already exists, rena"></p>
<h4 id="prepare-for-the-arguments"><a href="#prepare-for-the-arguments" class="headerlink" title="prepare for the arguments"></a>prepare for the arguments</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movq $1,%rdi</span><br><span class="line">leaq 16(%rsp),%rsi</span><br><span class="line">movl $2,%rdx</span><br><span class="line">leaq 24(%rsp),%rcx</span><br><span class="line">movl $3,%r8</span><br><span class="line">leaq 28(%rsp),%r9</span><br><span class="line">movl $4,(%rsp)     #Arg 7</span><br><span class="line">leaq 31(%rsp),%rax</span><br><span class="line">movq %rax,8(%rsp)  #Arg 8</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/cltq.png" alt="upload succesul"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movswl 28(%rsp),%eax # %eax = x3</span><br><span class="line"></span><br><span class="line">movsbl 31(%rsp),%edx # %edx = x4</span><br><span class="line"></span><br><span class="line">s 表示 signextend</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/11/14/CSAPP-MIPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/CSAPP-MIPS/" itemprop="url">CSAPP-MIPS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-14T21:00:00+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="Registers-寄存器"><a href="#Registers-寄存器" class="headerlink" title="Registers 寄存器"></a>Registers 寄存器</h5><hr>
<p>1.一共有32个general register</p>
<p>2.有两种使用方法: 直接使用对应的编号或者是对应的寄存器名称</p>
<table>
<thead>
<tr>
<th>寄存器编号</th>
<th>寄存器名称</th>
<th>寄存器用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>zero</td>
<td>return 0</td>
</tr>
<tr>
<td>1</td>
<td>$at</td>
<td>汇编保留寄存器</td>
</tr>
<tr>
<td>2-3</td>
<td>$v0-$v1</td>
<td>（value）存储表达式或者是函数的返回值</td>
</tr>
<tr>
<td>4-7</td>
<td>$a0-$a3</td>
<td>(Argument) 存储子程序前四个参数，调用时不保存</td>
</tr>
<tr>
<td>8-15</td>
<td>$t0-$t7</td>
<td>临时变量，调用时不保存，调用完成后要恢复</td>
</tr>
<tr>
<td>16-23</td>
<td>$s0-$s7</td>
<td>函数调用的时候必须保存，调用完成后需要恢复</td>
</tr>
<tr>
<td>24-25</td>
<td>$t8-$t9</td>
<td>属性和$t0-$t7一致</td>
</tr>
<tr>
<td>26-27</td>
<td>$k0-$k1</td>
<td>（kernel）中断函数返回值</td>
</tr>
<tr>
<td>28</td>
<td>$gp</td>
<td>global pointer 指向64K大小的静态数据块的中间地址</td>
</tr>
<tr>
<td>29</td>
<td>$sp</td>
<td>stack pointer</td>
</tr>
<tr>
<td>30</td>
<td>$fp/$s8</td>
<td>frame pointer</td>
</tr>
<tr>
<td>31</td>
<td>$ra</td>
<td>return address</td>
</tr>
</tbody>
</table>
<hr>
<h5 id="Program-Structure-程序结构"><a href="#Program-Structure-程序结构" class="headerlink" title="Program Structure 程序结构"></a>Program Structure 程序结构</h5><hr>
<p>本质其实就只是数据声明+普通文本+程序编码（文件后缀为.s，或者.asm也行） 数据声明在代码段之后（其实在其之前也没啥问题，也更符合高级程序设计的习惯）<br>Data Declarations 数据声明</p>
<pre><code>数据段以 .data为开始标志
声明变量后，即在主存中分配空间。
</code></pre><p>Code 代码</p>
<pre><code>代码段以 .text为开始标志
其实就是各项指令操作
程序入口为main：标志
程序结束标志（详见下文）
</code></pre><h6 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		.data  # 数据变量声明</span><br><span class="line">		</span><br><span class="line">        .text  #代码段</span><br><span class="line">        </span><br><span class="line">main:   主函数入口</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h5><p>example</p>
<p>var1:   &emsp;  .word 3     </p>
<p>array:  &emsp;  .byte ‘a’,’b’  # 声明一个存储两个字符的数组array1，并赋值’a’,’b’</p>
<p>array1:  &emsp;  .space 40    #为变量array2 分配40个未使用的连续空间</p>
<hr>
<h6 id="其他指令汇总"><a href="#其他指令汇总" class="headerlink" title="其他指令汇总"></a>其他指令汇总</h6><hr>
<p><a href="https://blog.csdn.net/king523103/article/details/45967991" target="_blank" rel="noopener">MIPS入门</a></p>
<h5 id="实战-冒泡排序"><a href="#实战-冒泡排序" class="headerlink" title="实战-冒泡排序"></a>实战-冒泡排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">array: .space 1024</span><br><span class="line">input_msg: .asciiz &quot;Enter the number of integers:\n&quot;</span><br><span class="line">input_int_msg: .asciiz &quot;Enter integers to be sorted\n&quot;</span><br><span class="line">output_msg: .asciiz &quot;the sorted numbers are\n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">	la $a0,input_msg</span><br><span class="line">	li $v0,4</span><br><span class="line">	syscall</span><br><span class="line">	 </span><br><span class="line">	li $v0,5  #接受用户输入的数组长度</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	la $t6,array #数组首地址</span><br><span class="line">	move $t7,$zero #循环变量i</span><br><span class="line">	move $t8,$zero #循环变量j</span><br><span class="line">	move $t9,$v0  #数组长度</span><br><span class="line"></span><br><span class="line">	addi $t3,$zero,1</span><br><span class="line">	beq $v0,$t3,special</span><br><span class="line">			</span><br><span class="line">input:</span><br><span class="line"></span><br><span class="line">	la $a0,input_int_msg</span><br><span class="line">	li $v0,4</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	li $v0,5  </span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	#for(int i=0;i&lt;num;i++)</span><br><span class="line">        #cin&gt;&gt;arr[i];</span><br><span class="line">        </span><br><span class="line">        move $t0,$t7 #$t0 is i</span><br><span class="line">        sll $t0,$t0,2 #i become byte offset</span><br><span class="line">        move $t1,$t6 #$t1 is &amp;array[0]</span><br><span class="line">        add $t1,$t1,$t0 #$t1 is &amp;array[i]</span><br><span class="line">        sw $v0,0($t1) #cin&gt;&gt;array[i]</span><br><span class="line">	</span><br><span class="line">	addi $t7,$t7,1</span><br><span class="line">	blt $t7,$t9,input #if ++i&lt;length</span><br><span class="line"> </span><br><span class="line">	move $t7,$zero</span><br><span class="line">	</span><br><span class="line">loop1:	# 每次外层循环比内层循环的循环变量设为0</span><br><span class="line">	move $t8,$zero</span><br><span class="line">loop2:</span><br><span class="line">	#read arr[j+1] and arr[j]</span><br><span class="line">	</span><br><span class="line">	move $t2,$t8 #t2 is j</span><br><span class="line">	sll $t2,$t2,2 #j=*4;</span><br><span class="line">	addu $t1,$t2,$t6 #&amp;arr[j]</span><br><span class="line">	lw $t4,0($t1)  #arr[j]</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	addi $t2,$t8,1 #j+1</span><br><span class="line">	sll $t2,$t2,2 #(j+1)*4</span><br><span class="line">	addu $t0,$t2,$t6 #&amp;arr[j+1]</span><br><span class="line">	lw   $t5,0($t0) #$t5 = arr[j+1]</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	bge $t5,$t4,skip #if arr[j+1]&gt;arr[j] skip</span><br><span class="line"></span><br><span class="line">	sw  $t5,0($t1)</span><br><span class="line">	sw  $t4,0($t0)</span><br><span class="line">	</span><br><span class="line">skip:</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	addi $t8,$t8,1 #j++</span><br><span class="line">	subi $t1,$t9,1 #t1 = num-1</span><br><span class="line">	sub  $t1,$t1,$t7 #t1 = num-1-i</span><br><span class="line">	blt  $t8,$t1,loop2 # if j&lt;num-i-1 t2=1</span><br><span class="line">	addi $t7,$t7,1 #i++</span><br><span class="line">	sub  $t3,$t9,1</span><br><span class="line">	blt  $t7,$t3,loop1  #if i&lt;num-1 then continue loop1</span><br><span class="line">	j output</span><br><span class="line">	</span><br><span class="line">special:</span><br><span class="line">	la $a0,input_int_msg</span><br><span class="line">	li $v0,4</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	li $v0,5  </span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	#for(int i=0;i&lt;num;i++)</span><br><span class="line">        #cin&gt;&gt;arr[i];</span><br><span class="line">        </span><br><span class="line">        move $t0,$t7 #$t0 is i</span><br><span class="line">        sll $t0,$t0,2 #i become byte offset</span><br><span class="line">        move $t1,$t6 #$t1 is &amp;array[0]</span><br><span class="line">        add $t1,$t1,$t0 #$t1 is &amp;array[i]</span><br><span class="line">        sw $v0,0($t1) #cin&gt;&gt;array[i]</span><br><span class="line">	</span><br><span class="line">output:</span><br><span class="line">	</span><br><span class="line">	la $a0,output_msg</span><br><span class="line">	li $v0,4</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	move $t7,$zero</span><br><span class="line">print:</span><br><span class="line">	</span><br><span class="line">	move $t0,$t7</span><br><span class="line">	</span><br><span class="line">	sll $t0,$t0,2</span><br><span class="line">	</span><br><span class="line">	add $t1,$t6,$t0</span><br><span class="line">	</span><br><span class="line">	lw $a0,0($t1) #argument a0</span><br><span class="line">	</span><br><span class="line">	li $v0,1</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	addi $t7,$t7,1</span><br><span class="line">	blt $t7,$t9,print</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/11/14/算法-Sliding-Window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/算法-Sliding-Window/" itemprop="url">算法-(2018-11-14) Sliding Window&Dijkstra枚举</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-14T15:58:00+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="sliding-window-leetcode-239"><a href="#sliding-window-leetcode-239" class="headerlink" title="sliding window leetcode 239"></a>sliding window leetcode 239</h5><p><a href="https://leetcode.com/problems/sliding-window-maximum/description/" target="_blank" rel="noopener">https://leetcode.com/problems/sliding-window-maximum/description/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">method 1: time complexity O(Nlog(k))</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        multiset&lt;int&gt;st;</span><br><span class="line">        vector&lt;int&gt;vec;</span><br><span class="line">        list&lt;int&gt; lst;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(i-k&gt;=0)&#123;</span><br><span class="line">                int top = lst.front();</span><br><span class="line">                lst.pop_front();</span><br><span class="line">                st.erase(st.find(top));</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            lst.push_back(nums[i]);</span><br><span class="line">            st.insert(nums[i]);</span><br><span class="line">              if(i-k&gt;=-1)&#123;</span><br><span class="line">                vec.push_back(*st.rbegin());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return vec;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">method 2</span><br><span class="line"></span><br><span class="line">1. use a deque to store the index in the window , each window must fall in the range(i-k+1,i). so whenever an index smaller than i-k+1,pop_front() to discard the element; </span><br><span class="line"></span><br><span class="line">2. when insert a new element nums[i], compare it with the top of the queue , until q[front]&gt;nums[i] ,that is to say, q[front] is always the max element in the window</span><br><span class="line"></span><br><span class="line">  vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">       </span><br><span class="line">         deque&lt;int&gt;dq;</span><br><span class="line">         vector&lt;int&gt;res;</span><br><span class="line">         if(nums.empty())</span><br><span class="line">             return res;</span><br><span class="line">         for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            while(!dq.empty()&amp;&amp;dq.front()&lt;i-k+1)&#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            //remove smaller elements in window</span><br><span class="line">            while(!dq.empty()&amp;&amp;nums[dq.back()]&lt;=nums[i])&#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">             dq.push_back(i);</span><br><span class="line">             if(i-k+1&gt;=0)&#123;</span><br><span class="line">                 res.push_back(nums[dq.front()]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里sliding window就是移动窗口的时候，每次把最左边的值pop掉，然后不断比较最右边的值与新插入的值，保证新插入的值是最好的candidate，那么窗口最左边的值就会是最大值。</p>
<p>Kattis</p>
<p>#include <algorithm></algorithm></p>
<p>#include <set></set></p>
<p>#include <iostream></iostream></p>
<p>#include <queue></queue></p>
<p>#include <vector></vector></p>
<p>#include <string></string></p>
<p>#include <map></map></p>
<p>using namespace std;</p>
<p>struct edge{<br>    int from;<br>    int to;<br>    int weight;<br>};</p>
<p>typedef pair&lt;int,int&gt; ip;</p>
<p>#define INF 0x3f3f3f3f</p>
<p>void dijkstra(vector&lt;vector<ip>&gt;&amp;adj,vector<int>&amp;dist,int source){</int></ip></p>
<pre><code>priority_queue&lt;ip,vector&lt;ip&gt;,greater&lt;ip&gt;&gt; q;
q.push({0,source});
dist[source] = 0;
while(!q.empty()){
    auto top = q.top();
    q.pop();
    int u = top.second;
    for(auto p:adj[u]){
        int v = p.first;
        int weight = p.second;
        if(dist[v]==INF||dist[v]&gt;dist[u]+weight){
            dist[v] = dist[u]+weight;
            q.push(make_pair(dist[v],v));
        }
    }
}
</code></pre><p>}</p>
<p><a href="https://open.kattis.com/problems/flowerytrails" target="_blank" rel="noopener">https://open.kattis.com/problems/flowerytrails</a></p>
<p><strong><em>对于有多条最短路，并且求所有最短路的路径之和</em></strong></p>
<p>1.分别对起始点和终点跑DIjkstra</p>
<p>2.枚举每一条初始点与终点分别到这条边距离，分别为d1,d2，如果d1+d2+w==shortestPath,则ans+=w;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int P,T;</span><br><span class="line">    cin&gt;&gt;P&gt;&gt;T;</span><br><span class="line">    vector&lt;vector&lt;ip&gt;&gt; adj(P);</span><br><span class="line">    vector&lt;vector&lt;ip&gt;&gt; parent(P);</span><br><span class="line">    vector&lt;int&gt;distStart(P,INF);</span><br><span class="line">    vector&lt;int&gt;distEnd(P,INF);</span><br><span class="line">    vector&lt;tuple&lt;int,int,int&gt;&gt;edgeVec;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;T;i++)&#123;</span><br><span class="line">        int from,to,w;</span><br><span class="line">        cin&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">        edgeVec.push_back(make_tuple(from,to,w));</span><br><span class="line">        adj[from].push_back(make_pair(to,w));</span><br><span class="line">        adj[to].push_back(make_pair(from,w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dijkstra(adj,distStart,0);</span><br><span class="line">    dijkstra(adj,distEnd,P-1);</span><br><span class="line"></span><br><span class="line">    int shortestPath = distStart[P-1];</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=0;i&lt;T;i++)&#123;</span><br><span class="line">        int from = get&lt;0&gt;(edgeVec[i]);</span><br><span class="line">        int to = get&lt;1&gt;(edgeVec[i]);</span><br><span class="line">        int weight = get&lt;2&gt;(edgeVec[i]);</span><br><span class="line"></span><br><span class="line">        if(distStart[to]+distEnd[from]+weight==shortestPath||</span><br><span class="line">        distStart[from]+distEnd[to]+weight==shortestPath)&#123;</span><br><span class="line">            ans+=weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans*2;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/29/DS-Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/DS-Graph/" itemprop="url">DS-Topo,Bipartite,max flow&min cut</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-29T10:38:37+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h3><h4 id="ver1-DFS"><a href="#ver1-DFS" class="headerlink" title="ver1 DFS"></a>ver1 DFS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">for each unvisited node u in V:</span><br><span class="line">	DFS(u)</span><br><span class="line">    for each neighbour h of u:</span><br><span class="line">    	if(!visited)</span><br><span class="line">        	DFS(h)</span><br><span class="line">    finish DFS(u) // push_back u to the list</span><br><span class="line">reverse the list!</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/topo.png" alt="upload successl"></p>
<h4 id="ver2-BFS-Khan"><a href="#ver2-BFS-Khan" class="headerlink" title="ver2 BFS (Khan)"></a>ver2 BFS (Khan)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">push vertices with no incoming edges to the queue</span><br><span class="line">while(!q.empty):</span><br><span class="line">	u = q.top </span><br><span class="line">    q.pop</span><br><span class="line">    for each neighbor x of u</span><br><span class="line">    	delete u-&gt;x</span><br><span class="line">        if x has no incoming edges,then push x to the queu</span><br><span class="line">//done</span><br></pre></td></tr></table></figure>
<h3 id="Bipartite"><a href="#Bipartite" class="headerlink" title="Bipartite"></a>Bipartite</h3><h4 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h4><p><img src="/home/alex/图片/def.png" alt="upload successfl"></p>
<p>1.说白了就是图的所有点可以分为两个set，每个set之间互相没有边，只有set与set之间的点有边。</p>
<p>2.应用于无向图。</p>
<h4 id="Bipartite-checker"><a href="#Bipartite-checker" class="headerlink" title="Bipartite checker"></a>Bipartite checker</h4><h4 id="ver1-DFS-1"><a href="#ver1-DFS-1" class="headerlink" title="ver1 DFS"></a>ver1 DFS</h4><p>每个点的邻居与它不同色（就是不同一个set）</p>
<p>每个点与它的邻居的邻居同色，它邻居的邻居与它在同一个set</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for each unvisited vertex in u:</span><br><span class="line">	dfs(u)</span><br><span class="line">    for each neighbor v in u:</span><br><span class="line">    	if(v is unvisited)</span><br><span class="line">        	assign u as different color</span><br><span class="line">        else if u and v has same color</span><br><span class="line">        	break!</span><br><span class="line">            it is not a bipartite</span><br></pre></td></tr></table></figure>
<h4 id="ver2-BFS"><a href="#ver2-BFS" class="headerlink" title="ver2 BFS"></a>ver2 BFS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push vertexs with no incoming edged to queue</span><br><span class="line">while(!queue.empty())</span><br><span class="line">	u = queue.top</span><br><span class="line">    q.pop</span><br><span class="line">    for v in neighbor in u</span><br><span class="line">    	if(v.color==u.color)</span><br><span class="line">        	exit;//no bipartite</span><br><span class="line">        else if unvisited </span><br><span class="line">        	assign different color to v</span><br></pre></td></tr></table></figure>
<h3 id="max-flow"><a href="#max-flow" class="headerlink" title="max flow"></a>max flow</h3><h4 id="intro-to-mincut-problem"><a href="#intro-to-mincut-problem" class="headerlink" title="intro to mincut problem"></a>intro to mincut problem</h4><p><img src="/home/alex/图片/2018-46.png" alt="filename already exists, renmed"></p>
<h4 id="intro-to-maxflow-problem"><a href="#intro-to-maxflow-problem" class="headerlink" title="intro to maxflow problem"></a>intro to maxflow problem</h4><p><img src="/home/alex/图片/2018-47.png" alt="filename already exists, rename"></p>
<h3 id="Ford-Fulkerson-Algorithm"><a href="#Ford-Fulkerson-Algorithm" class="headerlink" title="Ford-Fulkerson Algorithm"></a>Ford-Fulkerson Algorithm</h3><p>mincut 和 maxflow problem 实际上是等价的，解决了其中一个，另外一个就自然解决了。</p>
<p><img src="/home/alex/图片/2018-49.png" alt="filename already exists, reamed"></p>
<p>如上图，a为开始点。各边左数字为capacity，右边数字为flow</p>
<p>a-&gt;b满了，a-&gt;b有一个cut</p>
<p>a-&gt;c不满，即（flow&lt;capacity）</p>
<p>c-&gt;e满了（flow==capacity）</p>
<p>c-&gt;d满了（flow==capacity）</p>
<p>设点a,c为集合P，其余所有点为集合P‘</p>
<p>则capacity of P-&gt;P’ 就等于maximum flow </p>
<p><img src="/home/alex/图片/2018-50.png" alt="filename already exists, renaed"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start with 0 flow</span><br><span class="line">while there exists an augmenting path:</span><br><span class="line">	find an augmenting path</span><br><span class="line">    compute bottleneck capacity</span><br><span class="line">    increase flow on that path by bottleneck 	 capacity</span><br></pre></td></tr></table></figure>
<h5 id="Augmenting-Path"><a href="#Augmenting-Path" class="headerlink" title="Augmenting Path:"></a>Augmenting Path:</h5><p>find an <strong><em>undirected</em></strong> path from s to t such that:</p>
<pre><code>can increase flow on forward edges(not full.)
can decrease flow on backward edge(not empty.)
</code></pre><h5 id="termination"><a href="#termination" class="headerlink" title="termination"></a>termination</h5><p>all paths from s to t are blocked by either a:</p>
<p>full forward edge</p>
<p>empty backward edge</p>
<h5 id="relationship-between-flow-and-cuts"><a href="#relationship-between-flow-and-cuts" class="headerlink" title="relationship between flow and cuts"></a>relationship between flow and cuts</h5><p><img src="/home/alex/图片/flow.png" alt="upload succesful"></p>
<p><img src="/home/alex/图片/lizi.png" alt="upload succsful"></p>
<h5 id="network-of-flow"><a href="#network-of-flow" class="headerlink" title="network of flow"></a>network of flow</h5><p><img src="/home/alex/图片/shenzong.png" alt="upload succeful"></p>
<p><img src="/home/alex/图片/ziyou.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/path.png" alt="upload successf"></p>
<p><img src="/home/alex/图片/pm.png" alt="upload succsful"></p>
<p><img src="/home/alex/图片/max.png" alt="upload succeful"></p>
<p>so how to find mincut from maxflow f?</p>
<p>start from s,find the forward edge that is not full or backward edge that is not empty</p>
<p><img src="/home/alex/图片/bengk.png" alt="upload succesl"></p>
<h3 id="Ford-fulkerson算法"><a href="#Ford-fulkerson算法" class="headerlink" title="Ford-fulkerson算法"></a>Ford-fulkerson算法</h3><p>Ford-fulkerson算法就是： 不断在残留网络中找增广路，直到没有为止。</p>
<p> Time complexity : O(C*E) ,C 是容量和</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time complexity of the above algorithm is O(max_flow * E). We run a loop while there is an augmenting path. In worst case, we may add 1 unit flow in every iteration. Therefore the time complexity becomes O(max_flow * E).</span><br></pre></td></tr></table></figure>
<h4 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h4><p>Dinic: 每次寻找最短的增广路until找不到，可证明最多能找V次。</p>
<p>Time complexity : O（V^2E）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) Initialize residual graph G as given graph.</span><br><span class="line">1) Do BFS of G to construct a level graph (or</span><br><span class="line">   assign levels to vertices) and also check if </span><br><span class="line">   more flow is possible.</span><br><span class="line">    a) If more flow is not possible, then return.</span><br><span class="line">    b) Send multiple flows in G using level graph </span><br><span class="line">       until blocking flow is reached. Here using </span><br><span class="line">       level graph means, in every flow,</span><br><span class="line">       levels of path nodes should be 0, 1, 2...</span><br><span class="line">       (in order) from s to t.</span><br></pre></td></tr></table></figure>
<p>A flow is <strong><em>Blocking Flow</em></strong> if no more flow can be sent using level graph, i.e., no more s-t path exists such that path vertices have current levels 0, 1, 2… in order. </p>
<h3 id="Dinic-code-Kattis-maximum-flow"><a href="#Dinic-code-Kattis-maximum-flow" class="headerlink" title="Dinic code-Kattis maximum flow"></a>Dinic code-Kattis maximum flow</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define M 50</span><br><span class="line">#define N 50</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//https://www.geeksforgeeks.org/dinics-algorithm-maximum-flow/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Edge &#123;</span><br><span class="line"></span><br><span class="line">    int to;</span><br><span class="line">    unsigned long rev;//store index of reverse edge in adjacency</span><br><span class="line">    int flow, cap;//cap is capacity</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dinic &#123;</span><br><span class="line">    using AdjacencyList=vector&lt; vector&lt;Edge&gt; &gt;;</span><br><span class="line"></span><br><span class="line">    bool bfs() &#123;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        q.push(source);</span><br><span class="line">        fill(begin(levels), end(levels), -1);</span><br><span class="line">        levels[source] = 0;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            const auto now = q.front(); q.pop();</span><br><span class="line">            for (const auto&amp; e : adjList[now]) &#123;</span><br><span class="line">                if (levels[e.to] == -1 &amp;&amp; e.flow &lt; e.cap) &#123;</span><br><span class="line">                    q.push(e.to);</span><br><span class="line">                    levels[e.to] = levels[now] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return levels[sink] != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //a dfs based function to send flow after BFS</span><br><span class="line">//has figured out that there is a possible flow</span><br><span class="line">//and constructed levels.This function called multiple times for a</span><br><span class="line">//a single call of BFS</span><br><span class="line">//flow: current flow sent by parent function call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int dfs(int v, int flow) &#123;</span><br><span class="line">        if (flow == 0) return 0;</span><br><span class="line">        if (v == sink) return flow;</span><br><span class="line">        for (int &amp; i = currentEdge[v]; i &lt; (int) adjList[v].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; edge = adjList[v][i];</span><br><span class="line">            if (levels[v] + 1 == levels[edge.to]) &#123;</span><br><span class="line">                const auto minimalFlow = dfs(edge.to, min(flow, edge.cap - edge.flow));</span><br><span class="line">                if (minimalFlow &gt; 0) &#123;</span><br><span class="line">                    //add flow to current edge</span><br><span class="line">                    edge.flow += minimalFlow;</span><br><span class="line">                    //subtract flow from reverse edge</span><br><span class="line">                    adjList[edge.to][edge.rev].flow -= minimalFlow;</span><br><span class="line">                    return minimalFlow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; levels, currentEdge;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int source, sink;</span><br><span class="line">    AdjacencyList adjList;</span><br><span class="line"></span><br><span class="line">    void AddEdge(int a, int b, int cap) &#123;</span><br><span class="line">        //ADJList动态变化，节省空间</span><br><span class="line">        if (max(a, b) &gt;= (int) adjList.size()) &#123;</span><br><span class="line">            adjList.resize(max(a, b) + 1);</span><br><span class="line">            levels.resize(max(a, b) + 1);</span><br><span class="line">            currentEdge.resize(max(a, b) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        const auto rev_a = adjList[b].size();</span><br><span class="line">        const auto rev_b = adjList[a].size();</span><br><span class="line">        adjList[a].push_back(&#123;b, rev_a, 0, cap&#125;);</span><br><span class="line">        adjList[b].push_back(&#123;a, rev_b, 0, 0&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int MaxFlow(int s, int t) &#123;</span><br><span class="line">        source = s;</span><br><span class="line">        sink = t;</span><br><span class="line">        int flow = 0;</span><br><span class="line">        //augment the flow while there is path</span><br><span class="line">        //from source to sink</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int m = bfs();</span><br><span class="line">            if (!m) break;</span><br><span class="line">            fill(begin(currentEdge), end(currentEdge), 0);</span><br><span class="line">            while (int pushed = dfs(source, INT_MAX)) &#123;</span><br><span class="line">                flow += pushed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int n,m,s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    Dinic d;</span><br><span class="line">    d.sink =s;</span><br><span class="line">    d.source = t;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;flow(n,vector&lt;int&gt;(n,0));</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        int u,v,c;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;</span><br><span class="line">        //flow[u][v] = c;</span><br><span class="line">        d.AddEdge(u,v,c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;d.MaxFlow(s,t)&lt;&lt;&quot; &quot;;</span><br><span class="line">    //SIZE is the number of edges used in the solution</span><br><span class="line">    //</span><br><span class="line">    int size = 0;</span><br><span class="line">    vector&lt;tuple&lt;int,int,int&gt;&gt;ans;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(auto &amp;e:d.adjList[i])&#123;</span><br><span class="line">            if(e.flow&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                size++;</span><br><span class="line">                ans.push_back(&#123;i,e.to,e.flow&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    for(auto &amp;t:ans)&#123;</span><br><span class="line">        int from = get&lt;0&gt;(t);</span><br><span class="line">        int to = get&lt;1&gt;(t);</span><br><span class="line">        int f = get&lt;2&gt;(t);</span><br><span class="line">        cout&lt;&lt;from&lt;&lt;&quot; &quot;&lt;&lt;to&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/27/stack-and-heap-and-memory-leak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/stack-and-heap-and-memory-leak/" itemprop="url">CSAPP-进程控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-27T23:40:00+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>每个进程都有一个唯一的正数进程ID，getpid函数返回调用进程的PID，getppid函数返回它的父进程的PID（创建调用进程的进程）</p>
<h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>1.运行 </p>
<p>2.停止</p>
<p>3.终止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	pid_t pid;</span><br><span class="line">    int x= 1;</span><br><span class="line">    </span><br><span class="line">    pid = Fork();</span><br><span class="line">    if(pid==0)&#123;</span><br><span class="line">		printf(&quot;child : x=%d\n&quot;,++x);    </span><br><span class="line">    	exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;parent: x=%d\n&quot;,--x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<p>1.fork函数只调用一次，但是会返回两次，一次是在父进程中，另外一次是在子进程中。</p>
<p>2.父进程总会返回子进程的PID，在子进程当中，fork总会返回0</p>
<p>3.并发执行，内核能够一任意方式交替执行它们逻辑控制流中的指令<br>在x86上，先完成父进程，再完成子进程,这个顺序不同的系统会不同，画出进程图，所有拓扑排序序列都可以。</p>
<p>4.相同但是独立的地址空间，每个进程都有相同的用户栈，相同的本地变量值，堆等“环境”，但却是独立的，就是说一个进程改变内部的环境不会影响另外一个进程</p>
<p>5.共享文件共享文件</p>
<p>结果如下<br><img src="/home/alex/图片/2018-65.png" alt="filename  exists, renamed"></p>
<p>所以上面程序的分析：</p>
<p>pid==0，即子进程</p>
<p>那如果是以下程序呢？</p>
<p><img src="/home/alex/图片/pro.png" alt="upload succful"></p>
<p><img src="/home/alex/图片/2018-66.png" alt="filename ready exists, renamed"></p>
<p>解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">先调用父进程，x=1，所以输出--x=0;</span><br><span class="line">然后调用子进程，子进程除了会执行if内的printf语句，同时还会执行if外的printf语句。</span><br></pre></td></tr></table></figure>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当一个进程由于某种原因中止的时候，内核不会立刻把它从系统中清除，而是保存在一个已经终止的状态中，等待被父进程回收。</p>
<p>所以一个终止了的但是还没有被回收的进程，成为僵死进程</p>
<p>如果父进程终止了，内核会安排init进程成为它孤儿进程的养父，init进程的PID位1，是系统启动的时候由内核创建的，不会终止，是所有进程的祖先。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid,int *statsup,int options)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pid参数用来判断等待集合的成员。</p>
<p>如果pid&gt;0，那么等待集合就是一个单独的子进程，它的进程ID等于pid</p>
<p>如果pid=-1，那么等待集合是由父进程的所有子进程组成的</p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><p>wait函数是waitpid函数的简单版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *statusp); // = waitpid(-1,&amp;status,0);</span><br></pre></td></tr></table></figure>
<h3 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h3><p>//返回要休眠的秒数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int sleep(unsigned int secs);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pause (void)</span><br><span class="line"></span><br><span class="line">让函数休眠，知道进程收到一个信号</span><br><span class="line">//always return -1</span><br></pre></td></tr></table></figure>
<h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p>execve函数在当前进程上下文当中加载并且运行一个新程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execve(const char *filename,const char *argv[],const char *envp[])</span><br></pre></td></tr></table></figure></p>
<p>execve函数加载并且运行可执行目标文件，且带参数列表argv和环境变量envp，只有当出现错误例如找不到filename的时候，execve才会返回到调用程序。</p>
<p>execve函数调用一次，而且从不返回</p>
<p>当execve加载了filename后，启动代码设置栈，并将控制传递给新程序的主函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char *argv,char **envp)</span><br></pre></td></tr></table></figure>
<p>1.argc argv[]数组中非空指针的数量</p>
<p>2.argv argb[]数组中的第一个条目</p>
<p>3.envp 指向argv[]数组的第一个条目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *getenv(const char *name) 函数</span><br><span class="line"></span><br><span class="line">搜索字符串 name==value,找到就返回一个指向其的指针，否则返回NULL；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int setenv(const char *name,const char *newvalue,int overwrite)//当overwrite非0的时候，如果name不存在，那么setenv把“name=newvalue&quot;添加到数组当中</span><br><span class="line"></span><br><span class="line">unsetenv就是会删除它</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//查看函数的命令行参数和环境变量</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[],char *envp[])</span><br><span class="line">  &#123;</span><br><span class="line">      int i;</span><br><span class="line">      printf(&quot;command-line arguments:\n&quot;);</span><br><span class="line">      for(i=0;argv[i]!=NULL;i++)&#123;</span><br><span class="line">  </span><br><span class="line">          printf(&quot;    argv[%2d]: %s\n&quot;,i,argv[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;\n&quot;);</span><br><span class="line">      printf(&quot;environmental variables:\n&quot;);</span><br><span class="line">      for(i=0;envp[i]!=NULL;i++)&#123;</span><br><span class="line">  </span><br><span class="line">          printf(&quot;    envp[%2d]: %s\n&quot;,i,envp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      exit(0);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户栈的组织结构"><a href="#用户栈的组织结构" class="headerlink" title="用户栈的组织结构"></a>用户栈的组织结构</h3><p>动态链接器变量下的envp,argv,与argc是libc_start_main的栈帧</p>
<p><img src="/home/alex/图片/yonghu.png" alt="upload succful"></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>def：一条通知进程系统发生了一个某种类型事件的小信息</p>
<p>传送一个信号到目的进程由两个不同步骤组成：</p>
<h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><h5 id="进程组："><a href="#进程组：" class="headerlink" title="进程组："></a>进程组：</h5><p>每个进程属于一个进程组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpgrp(void); return id of id group</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setpgid(pid_t pid,pit_t pgid);</span><br></pre></td></tr></table></figure>
<h5 id="用-bin-kill发送信号"><a href="#用-bin-kill发送信号" class="headerlink" title="用/bin/kill发送信号"></a>用/bin/kill发送信号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/kill -9 15213</span><br><span class="line"></span><br><span class="line">/bin/kill -9 -15213 负的PID会导致信号被发送到进程组PID中的每个进程</span><br></pre></td></tr></table></figure>
<h5 id="从键盘发射信号"><a href="#从键盘发射信号" class="headerlink" title="从键盘发射信号"></a>从键盘发射信号</h5><p>作业（job）用来表示为一条命令行求值而创建的进程，在任何时候，至多只有一个前台作业和0个或多个后台作业。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | sort //会创建一个由两个进程组成的前台作业</span><br></pre></td></tr></table></figure>
<h5 id="用kill发射信号"><a href="#用kill发射信号" class="headerlink" title="用kill发射信号"></a>用kill发射信号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int kill (pid_t pid,int sig);</span><br><span class="line">成功则返回0，错误则返回-1</span><br><span class="line"></span><br><span class="line">如果pid大于0，则kill函数发送信号号码sig给进程pid，如果pid为0，则kill发送信号sig给调用进程所在进程组的每个进程，如果pid小于0，kill发送信号sig给进程组pig绝对值中的每个进程</span><br></pre></td></tr></table></figure>
<h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>1.内核位每个进程在pending位向量维护着待处理信号的集合，而在blocked位向量维护着被阻塞的信号集合。所以任何时刻一种类型的信号只会被接收一次，在处理它的时候，会先把该类型的信号block，进程可以忽略信号，也可以捕捉这个信号，执行信号处理程序。</p>
<p>2.当内核从一个异常处理程序返回的时候，准备吧控制传递给某个进程p的时候，会检查进程p违背阻塞的待处理信号集合。如果这个集合不为空，那么内核选择集合中的某个信号k（越小越好，因为linux里面编号越小，优先级越高），并且进入k的处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 改变blocked向量的值，若oldset!=null，会用来保存以前blocked向量的值 */ </span><br><span class="line"></span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line"></span><br><span class="line">/* 初始化set为空集 */ int sigemptyset(sigset_t *set); /* 初始化set全为1，每个信号都填入blocked向量 */ </span><br><span class="line"></span><br><span class="line">int sigfillset(sigset *set); </span><br><span class="line"></span><br><span class="line">/* 添加、删除signum到set */ </span><br><span class="line">int sigaddset(sigset_t *set, int signum); int sigdelset(sigset_t *set, int signum);</span><br><span class="line"></span><br><span class="line">/* set中对应signum是否置1 */ </span><br><span class="line"></span><br><span class="line">int sigismember(const sigset_t *set, int signum);</span><br><span class="line">--------------------- </span><br><span class="line"></span><br><span class="line">原文：https://blog.csdn.net/WMLWONDER/article/details/53728630</span><br></pre></td></tr></table></figure>
<p>singal函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sighandler_t signal(int signum,sighandler_t handler)</span><br></pre></td></tr></table></figure>
<p>如果handler不是SIG_IGN或者SIG_DFL，handler 就是用户定义的函数的地址，这个函数叫做信号处理程序。这个过程叫<strong><em>设置信号处理程序</em></strong>，调用过程叫做捕获信号，执行信号处理过程叫做处理信号</p>
<h5 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h5><p>隐式阻塞：例如信号s对应程序S，当在处理程序S的时候，如果发送进程一个信号s，那么直到S返回，s会一直是待处理而不被接收。</p>
<p>显式阻塞：使用sigprocmask函数和其辅助函数，明确阻塞和解除阻塞选定的信号。</p>
<h5 id="临时阻塞一个信号"><a href="#临时阻塞一个信号" class="headerlink" title="临时阻塞一个信号"></a>临时阻塞一个信号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sigset_t mask,prev_mask;</span><br><span class="line">Sigemptyset(&amp;mask);</span><br><span class="line">Sigaddset(&amp;mask,SIGINT);</span><br><span class="line"></span><br><span class="line">//block sigint and save previous blocked set</span><br><span class="line"></span><br><span class="line">Sigprocmask(SIG_BLOCK，&amp;mask，&amp;prev_mask);</span><br><span class="line"></span><br><span class="line">	//Code region that will not be interrupt by SIGINT</span><br><span class="line">    </span><br><span class="line">Sigprocmask(SIG_SETMASK,&amp;prev_mask,NULL);</span><br></pre></td></tr></table></figure>
<h5 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h5><p><img src="/home/alex/图片/2018-67.png" alt="filename aready exists, renamed"></p>
<p>一些原则：</p>
<p>1.注意保存与恢复errno</p>
<p>2.当访问一个全局数据结构的时候，阻塞所有的信号</p>
<p>3.用volatile声明全局变量，告诉编译器不要缓存这个变量，那么每次引用g的时候，都要从内存中读取g的数值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/27/中断与异常的来源/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/中断与异常的来源/" itemprop="url">CSAPP中断与异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-27T22:48:00+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="adjustment-to-the-CPU"><a href="#adjustment-to-the-CPU" class="headerlink" title="adjustment to the CPU"></a>adjustment to the CPU</h5><p><img src="/home/alex/图片/cpu.png" alt="upload success"></p>
<p><em>when the results computed by ALU shows that there is an error,<br>then add a signal path from ALU to PC UPDATE</em></p>
<p><em>now PC update have 3 choice to update its value:</em></p>
<p>1.PC+4</p>
<p>2.JUMP instruction PC+offset*4</p>
<p>3.when the error signal is valid PC -&gt; 0  ,which means it turns to address 0 ,execute few instructions from address 0 to rectify the mistakes or show there is an error.</p>
<p>you can also record the PC value then error occurs, so next time you can jump back to the PC value and then continue the execution.</p>
<h5 id="what-is-interruption-and-exception"><a href="#what-is-interruption-and-exception" class="headerlink" title="what is interruption and exception"></a>what is interruption and exception</h5><p><img src="/home/alex/图片/excep.png" alt="upload successl"></p>
<h5 id="the-original-way-to-handle-exception-and-interruptoin"><a href="#the-original-way-to-handle-exception-and-interruptoin" class="headerlink" title="the original way to handle exception and interruptoin"></a>the original way to handle exception and interruptoin</h5><p><img src="/home/alex/图片/modify.png" alt="upload succel"></p>
<h4 id="interrupt-vector"><a href="#interrupt-vector" class="headerlink" title="interrupt vector"></a>interrupt vector</h4><p>how intel 8086 divide its address space?</p>
<p><img src="/home/alex/图片/mm.png" alt="upload success"></p>
<p>中断向量用来存储address which process the interruption</p>
<p><img src="/home/alex/图片/vector.png" alt="upload successf"></p>
<p>IP 存放在指令指针寄存器<br>CS 存放在代码段寄存器</p>
<p>IP，CS寄存器参见<a href="https://blog.csdn.net/qq_35212671/article/details/52752808" target="_blank" rel="noopener">https://blog.csdn.net/qq_35212671/article/details/52752808</a></p>
<p>总的来说，CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址。</p>
<p>当要执行一个可执行文件的时候，shell程序会把CS：IP寄存器设置这个程序的初始地址,然后CPU从这个地址开始读取指令</p>
<h5 id="逻辑地址生成物理地址"><a href="#逻辑地址生成物理地址" class="headerlink" title="逻辑地址生成物理地址"></a>逻辑地址生成物理地址</h5><p><img src="/home/alex/图片/img.png" alt="upload su"></p>
<p><img src="/home/alex/图片/xuanzang.png" alt="upload success"></p>
<p>中断向量表要在系统启动的时候进行初始化</p>
<p>一个中断向量占4个字节，1共有1KB空间用来存放中断向量，因此一共有256个中断向量。</p>
<p>CPU发现中断的时候，如果是1号，转向1号中断向量。由于中断向量的位置是固定的，CPU只需要通过硬件电路来访问中断向量，不需要通过软件。而且CS是段基值，IP是偏移量，根据段偏移计算方法：</p>
<p>对应地址为43006H<br>因此转到存储器里面的40996H，执行处理1号中断的服务程序。</p>
<p><em>注意终端服务程序存放顺序不固定</em></p>
<h5 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h5><p><img src="/home/alex/图片/2018-12.png" alt="flename already exists, renamed"></p>
<p>中断类型码就是中断向量序号，由于第0个中断向量是存放在地址0的，因此中断向量码与其存放地址的关系就是 地址 = 向量码×4</p>
<p>10H 20H 对应IP寄存器  30H 40H 对应CS寄存器</p>
<p>因此地址为 4030:2010H</p>
<p><img src="/home/alex/图片/biaoxi.png" alt="upload succes"></p>
<p>23 40 对应CS寄存器<br>78 90 对应IP寄存器</p>
<p>因此字节单元对应的内容分别为</p>
<p>23</p>
<p>40</p>
<p>78</p>
<p>90</p>
<p>(从上往下地址减少)</p>
<h4 id="中断向量表的发展"><a href="#中断向量表的发展" class="headerlink" title="中断向量表的发展"></a>中断向量表的发展</h4><p><img src="/home/alex/图片/huigu.png" alt="upload su"></p>
<p>1.回顾一下，实模式下，地址是有CS寄存器×4 + IP寄存器 来产生一个20位的地址来实现的</p>
<p>2.但是现在EIP的寻址能力和32位地址线寻址范围是对应的，因此保护模式下寻址方式和实模式有所不同。</p>
<h5 id="IA-32的存储器寻址"><a href="#IA-32的存储器寻址" class="headerlink" title="IA-32的存储器寻址"></a>IA-32的存储器寻址</h5><p>1.保护模式下，段基址不在CS中，而在内存中</p>
<p><img src="/home/alex/图片/2018-13.png" alt="upload successful"></p>
<p>为什么会有8192个描述符？</p>
<p>因为CS寄存器寻址能力是16位，可以寻找2^16也就是64K个地址，也就是8192个描述符</p>
<p>而这时候由于不知道起始地址，因此需要一个GDTR寄存器，来存储描述符0所在的地址。这是一个系统寄存器，在系统启动的时候就写好。</p>
<p>#####总结流程：</p>
<p>1.GDTR 结合 CS 寄存器，用来访问存储器中的描述符</p>
<p>2.然后从描述符当中提取出4个保存着基地址的字节，把得到的基地址与EIP指针寄存器结合，得到所要访问的寄存器的地址</p>
<h4 id="保护模式的中断操作"><a href="#保护模式的中断操作" class="headerlink" title="保护模式的中断操作"></a>保护模式的中断操作</h4><p>中断向量表</p>
<p><img src="/home/alex/图片/zhongduan.png" alt="upload succe"></p>
<p>这时候由于地址不是从0开始的，因此与上图类似，CPU需要一个IDTR来记录描述符0所在的地址。</p>
<p>这时候CPU把 <strong>(中断类型号 * 8 + IDTR)</strong>，得到描述符的地址，然后从描述符中选取2个段选择符字节放到CS寄存器，字节0,1,6,7放到EIP寄存器，（理解为偏移量）。记住实模式下，段基址并不是在CS中，而是需要用CS到内存中寻找。</p>
<p>所以当从中断向量取回CS与EIP后，要利用CS和GDTR结合，来寻找段基址，再把段基址与EIP结合，这样最后才能得到<strong>中断服务程序</strong>的入口地址</p>
<p>与实模式下的不同:</p>
<p><em>实模式下中断向量4个字节，其中低位的两个放到IP寄存器，高位的两个放到CS寄存器</em></p>
<h4 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h4><p><img src="/home/alex/图片/zhongd.png" alt="upload successf"></p>
<p><img src="/home/alex/图片/chenju.png" alt="upload succeful"></p>
<p><img src="/home/alex/图片/googl.png" alt="upload"></p>
<p><img src="/home/alex/图片/accu.png" alt="uploada"></p>
<p><img src="/home/alex/图片/man.png" alt="upload"></p>
<p><img src="/home/alex/图片/m.png" alt="upload succ"></p>
<p><img src="/home/alex/图片/2018-14.png" alt="filename already exists, remed"></p>
<p>根据上图： 发生中断的时候先压栈，保存好处理完中断后应该返回的地址的信息。</p>
<p>Flags保存好标志，以免处理的时候会改变某些标志位。</p>
<p>清楚IF-TF 起到关中断的作用？？？</p>
<p>然后再从存储器找到中断向量，取到CS、IP之后就找到了终端服务程序的入口地址。</p>
<p><img src="/home/alex/图片/shixi.png" alt="upload succul"></p>
<p>总结：</p>
<p><img src="/home/alex/图片/ZONGJIE.png" alt="upload succes"></p>
<p>集中内部中断的类型：</p>
<p><img src="/home/alex/图片/s.png" alt="upload succesl"></p>
<p><img src="/home/alex/图片/juanzi.png" alt="upload succ"></p>
<p>注意上述两种中断类型的时机是不同的哦。</p>
<p>中断类型0 是在检测出异常的时候立即发生，而内部中断需要自己主动执行INTO指令才可以检测出来</p>
<p><img src="/home/alex/图片/danbu.png" alt="upload successfl"></p>
<p><img src="/home/alex/图片/shangji.png" alt="upload success"></p>
<p>为什么INT n是两字节指令？ 因为 INT 指令操作码 首先占一个字节 ，然后n范围是0-255 需要8位来表示，所以用2个字节。</p>
<p>那为啥INT 3用1个字节呢？</p>
<p>因为x86地址最短的就是一个字节。如果INT 3 是两个字节或以上，可能会覆盖掉下面的指令的一些字节。</p>
<p>例如：</p>
<p>OFFSET      instruction 1, one byte</p>
<p>OFFSET+1    instruction 2, one byte</p>
<p>如果在inst1设置断点，则而且inst1内容是跳到inst2，则替换的时候INT 3会把inst2某些字节覆盖掉。那么就不能实现跳到inst2的指令了。</p>
<p>OFFSET     INT3……………….</p>
<p>OFFSET+1    ………………….</p>
<p>详情参考 <a href="http://www.cs.columbia.edu/~junfeng/09sp-w4118/lectures/int3/int3.txt" target="_blank" rel="noopener">http://www.cs.columbia.edu/~junfeng/09sp-w4118/lectures/int3/int3.txt</a></p>
<p><img src="/home/alex/图片/2018-15.png" alt="upload successful"></p>
<p><img src="/home/alex/图片/duandian.png" alt="upload success"></p>
<p><img src="/home/alex/图片/duandian2.png" alt="upload succe"></p>
<p>INT 3对应的中断服务程序可以查看 AL寄存器的值 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/20/CSAPP-Cache-Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/20/CSAPP-Cache-Lab/" itemprop="url">CSAPP -Cache Lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-20T23:11:27+08:00">
                2018-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><p>引用<br><a href="https://blog.csdn.net/xbb224007/article/details/81103995?utm_source=blogxgwz0" target="_blank" rel="noopener">https://blog.csdn.net/xbb224007/article/details/81103995?utm_source=blogxgwz0</a></p>
<p><img src="/home/alex/图片/原函数misses过多原因分析.png" alt="upload successl"></p>
<h5 id="2-6就是常说的“抖动”"><a href="#2-6就是常说的“抖动”" class="headerlink" title="2-6就是常说的“抖动”"></a>2-6就是常说的“抖动”</h5><p>就是A，B数组下标相同的元素会映射到同一个cache块当中。</p>
<p>这里不命中本质上是因为访问同一个block的两个元素的时候，由于中间访问了其他块，导致已经加载的块被驱逐，进而导致第二次访问时候不命中。</p>
<p>解决办法： 同时把一个block若干个元素取出来，即省去了中间访问其他块导致驱逐的过程。利用blocking思想</p>
<p>CMU 文章<br><a href="http://csapp.cs.cmu.edu/2e/waside/waside-blocking.pdf" target="_blank" rel="noopener">http://csapp.cs.cmu.edu/2e/waside/waside-blocking.pdf</a></p>
<pre><code>1、A数组访问A[0][0]，冷不命中，将块11装入cache。

 2、B数组访问B[0][0]，虽然B[0][0]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。

 3、A数组访问A[0][1]，虽然A[0][1] 所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。

 4、B数组访问B[1][0]，虽然B[1][0]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。

 5、A数组访问A[0][2]，虽然A[0][2]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。

 6、B数组访问B[2][0]，B[2][0] 所映射的块12不在cache中，冷不命中，将数组B对应的块12装入cache。

 7、A数组访问A[0][3]，A[0][3]所映射的块11在cache中，且标记位相同，故命中。

 8、B数组访问B[3][0]，B[3][0]所映射的块12在cache中，且标记位相同，故命中。

 9、A数组访问A[1][0]，A[1][0]所映射的块11在cache中，且标记位相同，故命中。

 10、B数组访问B[0][1]，虽然B[0][1] 所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。

 11、A数组访问A[1][1]，虽然A[1][1]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。

 12、B数组访问B[1][1]，虽然B[1][1]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。

 13、A数组访问A[1][2]，虽然A[1][2]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。

 14、B数组访问B[2][1]，B[2][1] 所映射的块12在cache中，且标记位相同，故命中。

 15、A数组访问A[1][3]，A[1][3]所映射的块11在cache中，且标记位相同，故命中。
</code></pre><h4 id="本实验的Cache"><a href="#本实验的Cache" class="headerlink" title="本实验的Cache"></a>本实验的Cache</h4><p>b = 5,s = 5，E=1</p>
<p>B  =2^b = 2^5 = 32</p>
<p>S  =2^s  =2^5  =32</p>
<p>所以就是有32个块，每个块能存 32 bytes，就是8个int</p>
<h4 id="先分析-32X32"><a href="#先分析-32X32" class="headerlink" title="先分析 32X32"></a>先分析 32X32</h4><p>一行32个元素，所以一行4个block，一共32个block，所以cache能应付8行。</p>
<p>所以每8行就会遇到冲突。<strong>就是两个int之间相差8行的整数倍，那么读取这两个元素所在的block就会发生替换</strong></p>
<p>所以使用 8 * 8 blocking ，这样可以避免冲突</p>
<h5 id="注意处理对角线的情况"><a href="#注意处理对角线的情况" class="headerlink" title="注意处理对角线的情况"></a>注意处理对角线的情况</h5><p>因为矩阵转置之后，A【i,j】 = B【j,i】是相等的。</p>
<p>所以会发生冲突，可以采取的方法是，遇到对角线上的元素先不放到B，等block的其他七个元素写完之后，再把这个元素写到目的地。避免了由于中间加载B块，导致A块被驱逐所引起的命中冲突。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if(M==32)</span><br><span class="line">&#123;   //separate the the 32X32 block into 8X8 , decrease the number of misses</span><br><span class="line">    for(row_Block = 0;row_Block &lt; N ;row_Block+=8)&#123;</span><br><span class="line">        for(col_Block =0 ;col_Block &lt; M; col_Block+=8)&#123;</span><br><span class="line">            for(i=row_Block ; i&lt;row_Block+8;i++)&#123;</span><br><span class="line">                for(j=col_Block;j&lt;col_Block+8;j++)&#123;</span><br><span class="line">                    if(i!=j)&#123;</span><br><span class="line">                        B[j][i] = A[i][j];</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        tmp = A[i][j];                  //i==j means is the diagonal. if we set B right now ,the  misses and evictions will increase . because the cache set of B is same to A.</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(col_Block == row_Block)&#123;             //just set B on the diagonal. other than shouldn&apos;t set the B</span><br><span class="line">                    B[index][index] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析-61-x-67-情况"><a href="#分析-61-x-67-情况" class="headerlink" title="分析 61 x 67 情况"></a>分析 61 x 67 情况</h4><p>尝试 8<em>8,16</em>16,17*17等各种情况即可。</p>
<p>最难的就是</p>
<h4 id="64-X-64-情况"><a href="#64-X-64-情况" class="headerlink" title="64 X 64 情况"></a>64 X 64 情况</h4><p>一行用掉8个block，所以每4行就会发生冲突。</p>
<p>1.先要想清楚，转置的时候，对A数组是按行访问的，而对与B数组是按列访问的。</p>
<p>我们先来分析一下，如果在64 x 64情况下 ，采用8分块，那列访问B的时候，前四行和后四行映射的块是相同的。</p>
<p>所以会发生这种情况：</p>
<p>1.访问前4行第一列之后，再访问后4行的第一列，会发生冲突，使得原来的块被驱逐。</p>
<p>2.再回去访问前四行的第二列，由于原来的块被驱逐，又会导致冲突不命中，</p>
<p>3.访问后4行第二列又产生冲突不命中。</p>
<p>如果采用 4 X 4 分块</p>
<p>对于B 数组而言，访问顺序为<br>前四行前四列-》后四行前四列-》前四行后四列-》后四行后四列</p>
<p><strong><em>这里有点不懂</em></strong></p>
<p>参考文章提到，后四行前四列所在的块会覆盖前四行前四列的块，后面两次访问又会有一次不命中。为什么是2次？不是3次？</p>
<p>因此采取的策略：</p>
<p><img src="/home/alex/图片/qing.png" alt="upload success"></p>
<p><img src="/home/alex/图片/up.png" alt="upload successf"></p>
<p><img src="/home/alex/图片/2018-11.png" alt="filename alread"></p>
<p>按照这个顺序，对于B数组每一个块的元素，只会有一次不命中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if(M==64)&#123;</span><br><span class="line">     for (i = 0; i &lt; N; i+=8) &#123;</span><br><span class="line">         for (j = 0; j &lt; M; j+=8) &#123;</span><br><span class="line">             for(x=i;x&lt;i+4;x++)&#123;</span><br><span class="line"></span><br><span class="line">                 x1 = A[x][j];</span><br><span class="line">                 x2 = A[x][j+1];</span><br><span class="line">                 x3 = A[x][j+2];</span><br><span class="line">                 x4 = A[x][j+3];</span><br><span class="line">                 x5 = A[x][j+4];</span><br><span class="line">                 x6 = A[x][j+5];</span><br><span class="line">                 x7 = A[x][j+6];</span><br><span class="line">                 x8 = A[x][j+7];</span><br><span class="line">                 //leftup as usual</span><br><span class="line">                 B[j][x] = x1;</span><br><span class="line">                 B[j+1][x] = x2;</span><br><span class="line">                 B[j+2][x] = x3;</span><br><span class="line">                 B[j+3][x] = x4;</span><br><span class="line">                 B[j][x+4] = x5;</span><br><span class="line">                 B[j+1][x+4] = x6;</span><br><span class="line">                 B[j+2][x+4] = x7;</span><br><span class="line">                 B[j+3][x+4] = x8;</span><br><span class="line">             &#125;</span><br><span class="line">             for(y=j;y&lt;j+4;y++)&#123;</span><br><span class="line">                 </span><br><span class="line">                 x1 = A[i+4][y];</span><br><span class="line">                 x2 = A[i+5][y];</span><br><span class="line">                 x3 = A[i+6][y];</span><br><span class="line">                 x4 = A[i+7][y];</span><br><span class="line">                 x5 = B[y][i+4];</span><br><span class="line">                 x6 = B[y][i+5];</span><br><span class="line">                 x7 = B[y][i+6];</span><br><span class="line">                 x8 = B[y][i+7];</span><br><span class="line"></span><br><span class="line">                 B[y][i+4] = x1;</span><br><span class="line">                 B[y][i+5] = x2;</span><br><span class="line">                 B[y][i+6] = x3;</span><br><span class="line">                 B[y][i+7] = x4;</span><br><span class="line">                 B[y+4][i] = x5; </span><br><span class="line">                 B[y+4][i+1] = x6;</span><br><span class="line">                 B[y+4][i+2] = x7;</span><br><span class="line">                 B[y+4][i+3] = x8;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             for(x = i+4;x&lt;i+8;x++)&#123;</span><br><span class="line">                 x1 = A[x][j+4];</span><br><span class="line">                 x2 = A[x][j+5];</span><br><span class="line">                 x3 = A[x][j+6];</span><br><span class="line">                 x4 = A[x][j+7];</span><br><span class="line"></span><br><span class="line">                 B[j+4][x] = x1;</span><br><span class="line">                 B[j+5][x] = x2;</span><br><span class="line">                 B[j+6][x] = x3;</span><br><span class="line">                 B[j+7][x] = x4;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就是：</p>
<ol>
<li><p>B数组访问前4行</p>
</li>
<li><p>B数组访问前四行后四列，和后四行前四列</p>
</li>
<li><p>B数组最后把后四行后四列转置</p>
</li>
</ol>
<p>我感觉就是先把一行的数据处理完再去处理下一行，尽量不要交替着4行访问数据，这样会导致块被驱逐，加载，增加了总的冲突次数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="Alex Chiu" />
            
              <p class="site-author-name" itemprop="name">Alex Chiu</p>
              <p class="site-description motion-element" itemprop="description">Alex's personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Chiu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
