<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Alex&apos;s personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex Chiu">
<meta property="og:url" content="http://AlexanderChiuluvB.github.io/page/3/index.html">
<meta property="og:site_name" content="Alex Chiu">
<meta property="og:description" content="Alex&apos;s personal blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex Chiu">
<meta name="twitter:description" content="Alex&apos;s personal blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://AlexanderChiuluvB.github.io/page/3/"/>





  <title>Alex Chiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex Chiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/18/僵尸进程和孤儿进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/僵尸进程和孤儿进程/" itemprop="url">僵尸进程和孤儿进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-18T10:09:29+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<p>　　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<p>3、问题及危害</p>
<p>　　unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p>
<p>　　孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p>
<p>　　任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p><img src="/home/alex/图片/手痒.png" alt="upload succesul"> </p>
<p>b</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/17/CSAPP-习题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/17/CSAPP-习题/" itemprop="url">CSAPP-习题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-17T10:36:00+08:00">
                2018-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/home/alex/图片/2018-93.png" alt="filename already exists, renmed"></p>
<p>C。读写锁只能同时由多个读者或者一个写者拥有，而且读和写是排他的，两者不能共存。</p>
<p><img src="/home/alex/图片/vpn.png" alt="uplo successful"></p>
<p>页大小大概占10位，那么虚拟地址分为虚拟页号和虚拟页偏移量，那么后10位就是偏移量，剩下的位就是索引位，对应在页表中的索引，那么所以说他们的索引一样，物理位置的物理页号一样，而物理偏移量A总是小于B</p>
<p><img src="/home/alex/图片/asd.png" alt="upload succesul"></p>
<p>*（x+2） = A[2];</p>
<p><img src="/home/alex/图片/100.png" alt="upload sussful"></p>
<p>b</p>
<p><img src="/home/alex/图片/11.png" alt="upload successl"></p>
<p>d</p>
<p>Size of a pointer should be 8 byte on any 64-bit C/C++ compiler, but not necessarily size of int.</p>
<h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;  //静态变量，外部链接性</span><br><span class="line">static int b = 4;  //静态变量，内部链接性</span><br><span class="line"> </span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">	static int c = 5;  //静态变量，无链接性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部链接性： 多个文件共享</p>
<p>内部链接性： 只有所属的文件可用</p>
<p>无连接性： 只有该代码段内可用</p>
<p>外部链接性的静态变量</p>
<p><img src="/home/alex/图片/waibu.png" alt="upload successful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 2;</span><br><span class="line"> </span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 3;  //这是自动变量，会覆盖掉全局静态变量a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部链接性的静态变量"><a href="#内部链接性的静态变量" class="headerlink" title="内部链接性的静态变量"></a>内部链接性的静态变量</h3><p><img src="/home/alex/图片/2018-94.png" alt="filename alrey exists, renamed"></p>
<h3 id="无连接性的静态变量"><a href="#无连接性的静态变量" class="headerlink" title="无连接性的静态变量"></a>无连接性的静态变量</h3><p><img src="/home/alex/图片/wulianjie.png" alt="upload succsful"></p>
<h3 id="CSAPP6-34-6-35"><a href="#CSAPP6-34-6-35" class="headerlink" title="CSAPP6.34/6.35"></a>CSAPP6.34/6.35</h3><p>cache共有两个block，分别位于两个set中，设他们为b1和b2。每个block可以放下4个int类型的变量，也就是数组中的一行。在这一题中，源数组和目的数组是相邻排列的。所以内存和cache的映射情况是这样的：</p>
<p>b1 : src[0][] src[2][] dst[0][] dst[2][]</p>
<p>b2 : src[1][] src[3][] dst[1][] dst[3][]</p>
<p><img src="/home/alex/图片/GAOCUOLE.png" alt="upload succeful"></p>
<p>这里搞错了，应该是dst数组全是m，src数组是左边的样子。</p>
<p><img src="/home/alex/图片/2018-95.png" alt="filename already exists,named"></p>
<p>a</p>
<p><img src="/home/alex/图片/8byte.png" alt="upld successful"><br>An object that is “8 bytes aligned” is stored at a memory address that is a multiple of 8.</p>
<p>so choose c</p>
<h3 id="理解cache中的block，cache和line"><a href="#理解cache中的block，cache和line" class="headerlink" title="理解cache中的block，cache和line"></a>理解cache中的block，cache和line</h3><p><img src="/home/alex/图片/block.png" alt="upload succeful"></p>
<p>line就是block</p>
<p>directed mapped 就是一个set只有一个line</p>
<p>2way就是一个set可以放2个line</p>
<p>4way，就是一个set可以放4个line</p>
<p>fully associated 就是只有一个set，所以不需要中间位的index，来作为line index</p>
<h4 id="为什么要用中间位来做索引？"><a href="#为什么要用中间位来做索引？" class="headerlink" title="为什么要用中间位来做索引？"></a>为什么要用中间位来做索引？</h4><p>空间局部性。</p>
<p><img src="/home/alex/图片/4way.png" alt="upload succeful"></p>
<h4 id="fork函数到底复制了啥？"><a href="#fork函数到底复制了啥？" class="headerlink" title="fork函数到底复制了啥？"></a>fork函数到底复制了啥？</h4><p>“子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。”</p>
<p><img src="/home/alex/图片/linux环境.png" alt="upload succeful"></p>
<p><img src="/home/alex/图片/2018-96.png" alt="filename already exists, ramed"></p>
<p>子进程得到的只是全局变量的副本，该题应该选b</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/15/CSAPP-proxy-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/15/CSAPP-proxy-lab/" itemprop="url">CSAPP-proxy lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-15T21:43:43+08:00">
                2018-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Implementing-a-sequential-web-proxy"><a href="#Implementing-a-sequential-web-proxy" class="headerlink" title="Implementing a sequential web proxy"></a>Implementing a sequential web proxy</h3><p>先搞清listen socket 和 connected socket 的区别。</p>
<p><img src="/home/alex/图片/taojiezidui.png" alt="upload succful"></p>
<p>一个套接字对标记着一个客户端和服务器的链接。</p>
<p>客户端是发起连接请求的主动实体，而内核会认为socket函数创建的套接字是主动套接字，而服务器就是要调用listen函数告诉内核，该套接字是被服务器而不是客户端使用的，即listen函数将一个主动套接字转化为<strong><em>监听套接字</em></strong>。</p>
<p>服务器通过accept函数等待来自客户端的连接请求到达监听套接字，并返回一个<strong><em>已连接套接字</em></strong>，这个connfd可以被用来与客户端进行通讯。</p>
<p>实验过程如下：</p>
<p><img src="/home/alex/图片/实验过程.png" alt="upload successful"></p>
<h4 id="some-def"><a href="#some-def" class="headerlink" title="some def"></a>some def</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* You won&apos;t lose style points for including this long line in your code */</span><br><span class="line">static const char *user_agent_hdr = &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;;</span><br><span class="line">static const char *conn_hdr = &quot;Connection: close\r\n&quot;;</span><br><span class="line">static const char *prox_hdr = &quot;Proxy-Connection: close\r\n&quot;;</span><br><span class="line">static const char *hostFormat = &quot;Host: %s\r\n&quot;;</span><br><span class="line">static const char *requestHeaderFormat = &quot;GET %s HTTP/1.0\r\n&quot;;</span><br><span class="line">static const char *endof_hdr = &quot;\r\n&quot;;</span><br><span class="line">static const char *connection_key = &quot;Connection&quot;;</span><br><span class="line">static const char *user_agent_key= &quot;User-Agent&quot;;</span><br><span class="line">static const char *proxy_connection_key = &quot;Proxy-Connection&quot;;</span><br><span class="line">static const char *hostKey = &quot;Host&quot;;</span><br><span class="line"></span><br><span class="line">void doit(int fd);</span><br><span class="line">void parse_uri(char *uri,char *hostname,char *path,int *port);</span><br><span class="line">void buildHTTPHeader(char *http_header,char *hostname,char *path,int port,rio_t *client_rio);</span><br><span class="line">int connectEndServer(char *hostname,int port,char *httpHeader);</span><br><span class="line">void *thread(void *vargp);</span><br><span class="line">void initCache();</span><br><span class="line">int reader(int fd,char *uri);</span><br><span class="line">void writer(char *uri,char *buf);</span><br><span class="line">//reference: https://zhuanlan.zhihu.com/p/37902495</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char *buf;</span><br><span class="line">    char *uri;</span><br><span class="line">&#125;cacheLine;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    cacheLine* objects;</span><br><span class="line">    int count;</span><br><span class="line">&#125;Cache;</span><br><span class="line"></span><br><span class="line">Cache cache;</span><br><span class="line">int readCount;</span><br><span class="line">sem_t mutex,wmutex;</span><br><span class="line">//用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制</span><br></pre></td></tr></table></figure>
<p>main 函数，参考课本的tiny服务器，注意的是这里pthread_create是传值而不是引用，是为了避免竞争。（传值是传一个独立的副本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int listenfd,connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    char hostname[MAXLINE];</span><br><span class="line">    char port[MAXLINE];</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    if(argc!=2)&#123;</span><br><span class="line">        fprintf(stderr,&quot;usage %s &lt;port&gt;\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    initCache();</span><br><span class="line">    //ignore the SIGPIPE signal</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    //transfrom the fd to listenfd</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        clientlen = sizeof(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">        //ip-&gt;host name</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr,clientlen,hostname,MAXLINE,port,MAXLINE,0);</span><br><span class="line">        printf(&quot;Accepted connection from (%s %s)\n&quot;,hostname,port);</span><br><span class="line">        //pass value of connfd to create function to avoid competition</span><br><span class="line">        Pthread_create(&amp;tid,NULL,thread,(void*)connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void *thread(void *vargp)&#123;</span><br><span class="line">    int connfd = (int)vargp;</span><br><span class="line">    //要把线程分离出去，让这个线程计数结束之后自己回收资源，避免内存泄露。</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    doit(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doit"><a href="#doit" class="headerlink" title="doit"></a>doit</h3><p>函数逻辑：</p>
<p>1.得到解析后的请求行和请求头</p>
<p>2.然后去连接对应的服务器，发送请求</p>
<p>3.建立连接后，返回信息会在描述符中，也就是endServerFd</p>
<p>4.再把信息从endServerFd中读取出来，直接写进客户端对应的描述符fd就可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//对客户端请求的HTTP header 进行处理，首先获得request header</span><br><span class="line">//eg: GET http://www.zhihu.com HTTP/1.1</span><br><span class="line">//然后对于请求URL进行分析，获取需要连接的服务器的hostname，port，</span><br><span class="line">//修改客户端的HTTP，让proxy充当客户端把信息转发给正确的服务器，然后接收服务器</span><br><span class="line">//的返回并转发给正确的客户端</span><br><span class="line">void doit(int connfd)&#123;</span><br><span class="line"></span><br><span class="line">    char buf[MAXLINE],uri[MAXLINE],method[MAXLINE],version[MAXLINE];</span><br><span class="line">    //parseRequest(fd,&amp;requestLine,headers,&amp;numHead);</span><br><span class="line">    char endServerHTTP [MAXLINE];</span><br><span class="line">    char hostname[MAXLINE],path[MAXLINE];</span><br><span class="line">    char objectBUF[MAX_OBJECT_SIZE];</span><br><span class="line">    int port,endServerFd;</span><br><span class="line"></span><br><span class="line">    rio_t rio,serverRio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio,connfd);</span><br><span class="line">    Rio_readlineb(&amp;rio,buf,MAXLINE);</span><br><span class="line">    //read GET http://www.zhihu.com HTTP/1.1</span><br><span class="line">    //format read function</span><br><span class="line">    sscanf(buf,&quot;%s %s %s&quot;,method,uri,version);</span><br><span class="line">    </span><br><span class="line">    if(strcasecmp(method,&quot;GET&quot;))&#123;</span><br><span class="line">        printf(&quot;Proxy does not implement the method&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //parse the uri and save the hostname,path,port number to the argument</span><br><span class="line">    parse_uri(uri,hostname,path,&amp;port);</span><br><span class="line"></span><br><span class="line">    //build the http header which will send to the end server</span><br><span class="line">    buildHTTPHeader(endServerHTTP,hostname,path,port,&amp;rio);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    strcpy(uri,hostname);</span><br><span class="line">    strcpy(uri+strlen(uri),path);</span><br><span class="line">    if(reader(connfd,uri))&#123;</span><br><span class="line">        fprintf(stdout,&quot;%s from cache\n&quot;,uri);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int totalSize = 0;</span><br><span class="line">    //connect to the end server;</span><br><span class="line">    endServerFd = connectEndServer(hostname,port);</span><br><span class="line">    if(endServerFd&lt;0)&#123;</span><br><span class="line">        printf(&quot;connection failed&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Rio_readinitb(&amp;serverRio,endServerFd);</span><br><span class="line">    Rio_writen(endServerFd,endServerHTTP,strlen(endServerHTTP));</span><br><span class="line"></span><br><span class="line">    //receive message from end server and send to client</span><br><span class="line">    size_t n;</span><br><span class="line">    while((n=Rio_readlineb(&amp;serverRio,buf,MAXLINE)))&#123;</span><br><span class="line">        printf(&quot;proxy received %ld bytes,then send.\n&quot;,n);</span><br><span class="line">        Rio_writen(connfd,buf,n);</span><br><span class="line">        strcpy(objectBUF+totalSize,buf);</span><br><span class="line">        totalSize+=n;</span><br><span class="line">    &#125;</span><br><span class="line">   //each objectBUF save all info of the request</span><br><span class="line">    if(totalSize&lt;MAX_OBJECT_SIZE)</span><br><span class="line">        writer(uri,objectBUF);</span><br><span class="line">    Close(endServerFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="build-HTTP-that-send-to-the-end-server"><a href="#build-HTTP-that-send-to-the-end-server" class="headerlink" title="build HTTP that send to the end server"></a>build HTTP that send to the end server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void buildHTTPHeader(char *http_header,char *hostname,char *path,int port,rio_t *client_rio)&#123;</span><br><span class="line"></span><br><span class="line">    char buf[MAXLINE],requestHeader[MAXLINE],otherHeader[MAXLINE],hostHeader[MAXLINE];</span><br><span class="line"></span><br><span class="line">    //request line</span><br><span class="line">    //static const char *requestHeaderFormat = &quot;GET %s HTTP/1.0\r\n&quot;;</span><br><span class="line">    //把path内容按照格式写入requestHeader</span><br><span class="line">    sprintf(requestHeader,requestHeaderFormat,path);</span><br><span class="line">    while(Rio_readlineb(client_rio,buf,MAXLINE)&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">        if(!strcmp(buf,endof_hdr))&#123;</span><br><span class="line">            break; //EOF</span><br><span class="line">        &#125;</span><br><span class="line">        //Host</span><br><span class="line">        if(!strncasecmp(buf,hostKey,strlen(hostKey)))&#123;</span><br><span class="line">            strcpy(hostHeader,buf);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!strncasecmp(buf,connection_key,strlen(connection_key))&amp;&amp;!</span><br><span class="line">            strncasecmp(buf,proxy_connection_key,strlen(proxy_connection_key)),</span><br><span class="line">            !strncasecmp(buf,user_agent_key,strlen(user_agent_key)))&#123;</span><br><span class="line">            //把两个串连接起来</span><br><span class="line">            strcat(otherHeader,buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if(strlen(hostHeader)==0)&#123;</span><br><span class="line">        sprintf(hostHeader,hostFormat,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    //static const char *user_agent_hdr = &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;;</span><br><span class="line">    //static const char *conn_hdr = &quot;Connection: close\r\n&quot;;</span><br><span class="line">    //static const char *prox_hdr = &quot;Proxy-Connection: close\r\n&quot;;</span><br><span class="line">    //static const char *endof_hdr = &quot;\r\n&quot;;</span><br><span class="line">    </span><br><span class="line">    //put all header to http_header</span><br><span class="line">    sprintf(http_header,&quot;%s%s%s%s%s%s%s&quot;,requestHeader,hostHeader,</span><br><span class="line">            conn_hdr,prox_hdr,user_agent_hdr,otherHeader,endof_hdr);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parseuri"><a href="#parseuri" class="headerlink" title="parseuri"></a>parseuri</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void parse_uri(char *uri,char *hostname,char *path,int *port)&#123;</span><br><span class="line"></span><br><span class="line">    //strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。</span><br><span class="line">    //如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。</span><br><span class="line"></span><br><span class="line">    *port = 80;</span><br><span class="line">    char *pos1 = strstr(uri,&quot;//&quot;);</span><br><span class="line"></span><br><span class="line">    if(pos1)&#123;</span><br><span class="line">        pos1 =  pos1+2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        pos1 = uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char *pos2 = strstr(pos1,&quot;:&quot;);</span><br><span class="line">    //case the uri has the port info</span><br><span class="line">    if(pos2)&#123;</span><br><span class="line"></span><br><span class="line">        //          userinfo     host        port</span><br><span class="line">        //          ┌─┴────┐ ┌────┴────────┐ ┌┴┐</span><br><span class="line">        //  https://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top</span><br><span class="line">        //  └─┬─┘ └───────┬────────────────────┘└─┬─────────────┘└──┬───────────────────────┘└┬─┘</span><br><span class="line">        //  scheme     authority                 path              query                      fragment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //initalize the head of pos2 is \0 i.e clean the pos2</span><br><span class="line">        *pos2 = &apos;\0&apos;;</span><br><span class="line">        sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">        sscanf(pos2+1,&quot;%d%s&quot;,port,path);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        //</span><br><span class="line">        //telnet://192.0.2.16:80/xxx</span><br><span class="line">        //└──┬─┘ └──────┬──────┘│</span><br><span class="line">        //scheme    authority  path</span><br><span class="line">        // no port info</span><br><span class="line">        pos2 = strstr(pos1,&quot;/&quot;);</span><br><span class="line">        if(pos2)&#123;</span><br><span class="line">            sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">            *pos2 = &apos;/&apos;;</span><br><span class="line">            sscanf(pos2,&quot;%s&quot;,path);</span><br><span class="line">        &#125;</span><br><span class="line">        //only hostname info</span><br><span class="line">        else&#123;</span><br><span class="line">            sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="connect-end-server"><a href="#connect-end-server" class="headerlink" title="connect end server"></a>connect end server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline int connectEndServer(char *hostname,int port)&#123;</span><br><span class="line"></span><br><span class="line">    char portStr[100];</span><br><span class="line">    sprintf(portStr,&quot;%d&quot;,port);</span><br><span class="line">    return Open_clientfd(hostname,portStr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>采用读者-写者模型，可以让多个线程同时来读。</p>
<p>没有实现LRU，只是简单地把1MiB内存分为十块，每次接受请求并解析之后，先去cache看看有没有对应的web object，如果有直接返回给客户端，没有再从服务端请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int reader(int fd,char *uri)&#123;</span><br><span class="line"></span><br><span class="line">    //here uri = each server&apos;s hostname+path</span><br><span class="line">    int Found = 0;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    readCount++;</span><br><span class="line">    if(readCount==1)&#123;</span><br><span class="line">        P(&amp;wmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        if(!strcmp(cache.objects[i].uri,uri))&#123;</span><br><span class="line">            Rio_writen(fd,cache.objects[i].buf,MAX_OBJECT_SIZE);</span><br><span class="line">            Found=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    readCount--;</span><br><span class="line">    if(readCount==0)&#123;</span><br><span class="line">        V(&amp;wmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">    return Found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer(char *uri,char *buf)&#123;</span><br><span class="line"></span><br><span class="line">    P(&amp;wmutex);</span><br><span class="line">    strcpy(cache.objects[cache.count].uri,uri);</span><br><span class="line">    strcpy(cache.objects[cache.count].buf,buf);</span><br><span class="line">    ++cache.count;</span><br><span class="line">    V(&amp;wmutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//simple cache no use LRU,just split the memory to 10 block,</span><br><span class="line">//each time use a loop to find whether the uri of the request is in the block</span><br><span class="line">//在server和client之间加入代理的好处之一，就可以实现cache化。</span><br><span class="line">//因为，经常有很多对同一个资源多次请求的情况，如果每次都从服务端获取，那样服务器会很累。</span><br><span class="line">//如果可以在代理部分就实现一个cache，</span><br><span class="line">//将最近客户端请求过的数据给存储起来，那样就不需要每次都要从服务器请求了，进而提高服务器的效率。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void initCache()&#123;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;mutex,0,1);</span><br><span class="line">    sem_init(&amp;wmutex,0,1);</span><br><span class="line">    cache.objects = (cacheLine*)malloc(sizeof(cacheLine)*10);</span><br><span class="line">    cache.count=0;</span><br><span class="line">    readCount=0;</span><br><span class="line">    for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        cache.objects[i].buf = malloc(sizeof(char)*MAXLINE);</span><br><span class="line">        cache.objects[i].uri = malloc(sizeof(char)*MAX_OBJECT_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ul>
<li><p>use ./free-port.sh to get a free port, like 4501</p>
</li>
<li><p>open a terminal, nc -l 4501</p>
<ul>
<li>this is to start netcat as a server listening on port you get</li>
</ul>
</li>
<li><p>open a terminal </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --proxy http://localhost:23885/ http://localhost:4501/</span><br></pre></td></tr></table></figure>
<ul>
<li>open a terminal </li>
</ul>
<p>./proxy 23885</p>
<p><img src="/home/alex/图片/2018-91.png" alt="filename alady exists, renamed"></p>
<p>netcat is listening on 4501,proxy is listening on 23885,here netcat serves as a server,print sth in the ‘nc -l’ window,then you can see the exact sth print on the ‘curl’ window</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p><a href="https://blog.csdn.net/u012336567/article/details/52056089" target="_blank" rel="noopener">https://blog.csdn.net/u012336567/article/details/52056089</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37902495" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37902495</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/15/SAPP-Synchronization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/15/SAPP-Synchronization/" itemprop="url">CSAPP-Synchronization</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-15T13:50:00+08:00">
                2018-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现代操作系统提供三种构造并发程序的方法：</p>
<p>1.进程</p>
<p>2.I/O多路复用</p>
<p>3.线程</p>
<h3 id="基于进程的并发编程"><a href="#基于进程的并发编程" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h3><p>1.内核自动管理多个逻辑流</p>
<p>2.每个进程有私有的地址空间（进程切换的时候要保存和载入数据）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void sigchld_handler(int sig)&#123;</span><br><span class="line">    while (waitpid(-1, 0, WNOHANG) &gt; 0)</span><br><span class="line">        ;</span><br><span class="line">    return;</span><br><span class="line">    // Reap all zombie children</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        if (Fork() == 0) &#123;</span><br><span class="line">            Close(listenfd); // Child closes its listening socket</span><br><span class="line">            echo(connfd); // Child services client</span><br><span class="line">            Close(connfd); // Child closes connection with client</span><br><span class="line">            exit(0); // Child exits</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); // Parent closes connected socket (important!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器在accept函数中等待连接请求，然后客户端通过调用connect函数发送连接请求，最后服务器在accept中返回connfd并且fork一个子进程来处理客户端链接，链接就建立在listenfd和connfd之间。</p>
<ul>
<li><p>每个客户端由独立的子进程处理，而且必须回收僵尸进程，避免内存泄漏</p>
</li>
<li><p>不同进程之间不共享数据</p>
</li>
<li><p>父进程和子进程都有listenfd和connfd，所以父进程中要关闭connfd，子进程要关闭listenfd</p>
<ul>
<li>内核会保存对每个socket的引用计数，(refcnt(connfd)=2)，所以父进程需要关闭connfd，这样在子进程结束后引用计数才会变为0</li>
</ul>
</li>
</ul>
<p>优点：只共享已打开的file table，无论是descriptor还是全局变量都不共享，不容易造成同步问题。</p>
<p>缺点：带来额外的进程管理开销，进程间通信需要用IPC</p>
<h3 id="基于事件-I-O-multiplexing"><a href="#基于事件-I-O-multiplexing" class="headerlink" title="基于事件 I/O multiplexing"></a>基于事件 I/O multiplexing</h3><p>1.由程序员手动控制多个逻辑流。</p>
<p>2.所有逻辑流共享同一个地址空间</p>
<h3 id="基于线程"><a href="#基于线程" class="headerlink" title="基于线程"></a>基于线程</h3><p>内核自动管理多个逻辑流</p>
<p>每个线程共享地址空间</p>
<p>属于基于进程和基于事件的混合体</p>
<h3 id="传统观点下的进程"><a href="#传统观点下的进程" class="headerlink" title="传统观点下的进程"></a>传统观点下的进程</h3><p><img src="/home/alex/图片/jincheng.png" alt="upload sessful"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程有多个线程，每个线程有自己的线程id，有自己的逻辑控制流，也有自己用来保存局部变量的栈（其他线程可以修改）。而且共享所有代码，数据和内核上下文。</p>
<p><img src="/home/alex/图片/xiancheng.png" alt="upload sucssful"></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><img src="/home/alex/图片/duoxianc.png" alt="upload sussful"></p>
<p>概念上的</p>
<p><img src="/home/alex/图片/gainian.png" alt="upload sessful"></p>
<p>实际上的</p>
<p><img src="/home/alex/图片/globaland.png" alt="upload sucsful"></p>
<p>不同线程之间的数据其实可以相互访问</p>
<h3 id="Shared-variable"><a href="#Shared-variable" class="headerlink" title="Shared variable"></a>Shared variable</h3><p>a variable x is shared if and only if multiple threads reference some instance of x </p>
<h4 id="global-amp-local-variable"><a href="#global-amp-local-variable" class="headerlink" title="global &amp; local variable"></a>global &amp; local variable</h4><p><img src="/home/alex/图片/stat.png" alt="upload sful"></p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p><img src="/home/alex/图片/example.png" alt="upload suessful"></p>
<p>ptr是全局变量，shared by main thread and thread 1&amp;2</p>
<p>i is only referenced by main, so not shared</p>
<p>msgs is referenced by all 3 threads, so is is shared </p>
<p>myid is only referenced by thread 1 &amp; 2 seperately</p>
<p>static int cnt is referenced by both 1 &amp;2</p>
<p>so if <strong><em>multiple threads reference the same x instance, the x is shared </em></strong></p>
<p><img src="/home/alex/图片/shared.png" alt="upload succful"></p>
<h3 id="bad-example"><a href="#bad-example" class="headerlink" title="bad example"></a>bad example</h3><p><img src="/home/alex/图片/badeg.png" alt="upload successful"></p>
<p>看loop的汇编代码</p>
<p><img src="/home/alex/图片/2018-86.png" alt="filename ady exists, renamed"></p>
<p>正常结果</p>
<p><img src="/home/alex/图片/zhengchang.png" alt="upload succful"></p>
<p>下图是线程2提前Load了cnt，结果rdx2为0，正确结果是等到线程1store之后线程2再load</p>
<p><img src="/home/alex/图片/dang.png" alt="upload succeful"></p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</p>
<h3 id="再看信号量"><a href="#再看信号量" class="headerlink" title="再看信号量:"></a>再看信号量:</h3><p><img src="/home/alex/图片/sss.png" alt="upload sussful"></p>
<p>信号量的提出，是为了解决<strong><em>同步不同执行线程问题</em></strong>的方法。</p>
<p>什么是信号量？</p>
<p>信号量<strong>s</strong>是一个具有非负值的全局变量。</p>
<p>只能由两种特殊操作P，V来处理</p>
<p>P，V原理如上图</p>
<p><img src="/home/alex/图片/xinhaol.png" alt="uploadccessful"></p>
<p>定义P和V，为了确保一个正在运行的程序绝不可能进入s是负值的状态，这个属性叫<strong><em>信号量不变性</em></strong></p>
<h3 id="使用信号量实现互斥"><a href="#使用信号量实现互斥" class="headerlink" title="使用信号量实现互斥"></a>使用信号量实现互斥</h3><p><img src="/home/alex/图片/jiasuo.png" alt="upload cessful"></p>
<p><img src="/home/alex/图片/2018-87.png" alt="filename alrey exists, renamed"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">volatile int cnt=0; </span><br><span class="line">sem_t mutex; //声明信号量mutex</span><br><span class="line"></span><br><span class="line">Sem_init(&amp;mutex,0,1);//主线程中初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在线程例程中对共享变量cnt的更新包围P和V操作，从而保护他们</span><br><span class="line">for(i=0;i&lt;niters;i++)&#123;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用信号量来调度共享资源"><a href="#使用信号量来调度共享资源" class="headerlink" title="使用信号量来调度共享资源"></a>使用信号量来调度共享资源</h3><h4 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h4><p><img src="/home/alex/图片/yuanli.png" alt="upload cessful"></p>
<h4 id="读者和写者问题"><a href="#读者和写者问题" class="headerlink" title="读者和写者问题"></a>读者和写者问题</h4><p><img src="/home/alex/图片/duzhe.png" alt="load successful"></p>
<p><img src="/home/alex/图片/esa.png" alt="upload sucsful"></p>
<p><img src="/home/alex/图片/2018-88.png" alt="filename exists, renamed"></p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>一个函数如果被多个并发线程反复调用的时候，会一直产生正确的结果，否则就是线程不安全的。</p>
<p>1.不保护共享变量的函数</p>
<p>解决方案，利用P,V这样的同步操作来保护共享的变量</p>
<p>2.保持跨越多个调用状态的函数</p>
<p><img src="/home/alex/图片/jiang.png" alt="uoad successful"></p>
<p>3.返回指向静态变量的指针的函数</p>
<p><img src="/home/alex/图片/hanshu.png" alt="upload scessful"></p>
<p>4.调用线程不安全函数的函数。</p>
<p> 1.如果函数f调用线程不安全函数g。那么f可能不安全。<br> 2.如果g是第二类，那么f一定不安全，也没有办法去修正，只能改变g.<br> 3.如果g是第一，三类，可以用加锁-拷贝技术来解决。</p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点，就会发生竞争。</p>
<p>1.通常，竞争发生的理由是因为程序员假定某种特殊的轨迹线穿过执行状态空间。</p>
<p><img src="/home/alex/图片/face.png" alt="u successful"></p>
<p><img src="/home/alex/图片/2018-89.png" alt="filename alry exists, renamed"></p>
<p><img src="/home/alex/图片/sisuo.png" alt="upload successf"></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="/home/alex/图片/2018-90.png" alt="filename ady exists, renamed"></p>
<p><img src="/home/alex/图片/pindong.png" alt="uploaessful"></p>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>判断 myid会不会出现竞争</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 版本一</span><br><span class="line">void *foo(void *vargp)</span><br><span class="line">&#123;</span><br><span class="line">    int myid;</span><br><span class="line">    myid = *((int *)vargp);</span><br><span class="line">    Free(vargp);</span><br><span class="line">    printf(&quot;Thread %d\n&quot;, myid);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[2];</span><br><span class="line">    int i, *ptr;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; 2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = Malloc(sizeof(int));</span><br><span class="line">        *ptr = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], 0, foo, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    Pthread_join(tid[0], 0);</span><br><span class="line">    Pthread_join(tid[1], 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环中每次创建不同的指针，两个线程不是共享同一个变量。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 版本二</span><br><span class="line">void *foo(void *vargp)</span><br><span class="line">&#123;</span><br><span class="line">    int myid;</span><br><span class="line">    myid = *((int *)vargp);</span><br><span class="line">    printf(&quot;Thread %d\n&quot;, myid);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[2];</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; 2; i++)</span><br><span class="line">        Pthread_create(&amp;tid[i], NULL, foo, &amp;i);</span><br><span class="line">    Pthread_join(tid[0], NULL);</span><br><span class="line">    Pthread_join(tid[1], NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个线程共享i变量，而i++和myid = <em>((int </em>)vargp)<br>会发生竞争，当然前提是传的是引用&amp;i，因为这样的话foo函数会改变i本身的值，若如果是传值i，则只会改变i的一个副本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-Network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-Network/" itemprop="url">CSAPP-Network</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T20:19:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p><img src="/home/alex/图片/socket.png" alt="upload sucsful"></p>
<h4 id="socket-address-structures"><a href="#socket-address-structures" class="headerlink" title="socket address structures"></a>socket address structures</h4><p><img src="/home/alex/图片/sas.png" alt="upload suful"></p>
<p><img src="/home/alex/图片/2018-82.png" alt="filename aly exists, renamed"></p>
<p>发明套接字接口的时候，还没有void*,为了兼容，可以定义套接字函数要求一个指向通用sockaddr结构的指针，然后要求应用程序将与协议特定的结构的指针强制转换成这个通用的结构。</p>
<h3 id="socket-Interface"><a href="#socket-Interface" class="headerlink" title="socket Interface"></a>socket Interface</h3><p><img src="/home/alex/图片/socketInterface.png" alt="upload succesl"></p>
<p>1.开启服务器</p>
<ul>
<li>（open_listenfd函数，做好接收请求的准备）</li>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>accept</li>
</ul>
<p>2.开启客户端</p>
<ul>
<li>getaddrinfo</li>
<li>socket</li>
<li>connect</li>
</ul>
<ol start="3">
<li>交换数据</li>
</ol>
<p>4.关闭客户端</p>
<p>5.断开客户端</p>
<h4 id="getaddrinfo："><a href="#getaddrinfo：" class="headerlink" title="getaddrinfo："></a>getaddrinfo：</h4><p>设置服务器的相关信息</p>
<h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h4><p>创建socket descriptor ，也就是之后用来读写的file descriptor</p>
<p><img src="/home/alex/图片/socf.png" alt="upload cessful"></p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>请求kernel把socket address 和 socket descriptor绑定</p>
<p>Bind is kernel call to designate which service this program will be hosting</p>
<p>告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来，对于socket和connect，最好方法是用getaddrinfo来为bind提供参数</p>
<p><img src="/home/alex/图片/2018-83.png" alt="filename alrey exists, renamed"></p>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>由于客户端是发起连接要求的主动实体，服务器是被动等待连接请求的，所以默认条件下，内核会认为socket函数创建的描述符对应于主动套接字，它存在于一个连接的客户端。服务器调用listen函数告诉内核，描述符是被服务器而不是客户端使用的。</p>
<p>也就是说listen函数把sockfd从一个主动套接字转化为一个监听套接字，这个套接字可以接受来自客户端的连接请求。</p>
<p><img src="/home/alex/图片/listen.png" alt="upload succeul"></p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><p>等待来自客户端的连接请求到达listenfd，然后在addr中填写客户端的套接字地址，并且返回一个已连接描述符，这个描述符可以用来利用Unix I/O 函数与客户端通信。</p>
<p><img src="/home/alex/图片/accept.png" alt="upload succeul"></p>
<p><img src="/home/alex/图片/2018-84.png" alt="filename ady exists, renamed"></p>
<h4 id="connect-client-side"><a href="#connect-client-side" class="headerlink" title="connect (client side)"></a>connect (client side)</h4><p>connect 函数试图与套接字地址为addr的服务器建立一个因特网链接，其中addrlen是sizeof（sockaddr_in）connect函数会阻塞，一直到连接成功或者发现错误。</p>
<p><img src="/home/alex/图片/connect.png" alt="uploessful"></p>
<h3 id="diff-of-connected-amp-listening-descriptors"><a href="#diff-of-connected-amp-listening-descriptors" class="headerlink" title="diff of connected &amp; listening descriptors"></a>diff of connected &amp; listening descriptors</h3><p><img src="/home/alex/图片/connected.png" alt="upload successful"></p>
<h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p><img src="/home/alex/图片/get.png" alt="upload succesl"></p>
<h3 id="Host-and-service-connection"><a href="#Host-and-service-connection" class="headerlink" title="Host and service connection"></a>Host and service connection</h3><p><img src="/home/alex/图片/host.png" alt="uload successful"></p>
<p>result 指向addrinfo结构的链表</p>
<h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p><img src="/home/alex/图片/info.png" alt="upload succesul"></p>
<h3 id="LLR-by-getinfo"><a href="#LLR-by-getinfo" class="headerlink" title="LLR by getinfo"></a>LLR by getinfo</h3><p><img src="/home/alex/图片/adddd.png" alt="upload sussful"></p>
<h4 id="addrinfo-struct（代码实现）"><a href="#addrinfo-struct（代码实现）" class="headerlink" title="addrinfo struct（代码实现）"></a>addrinfo struct（代码实现）</h4><p><img src="/home/alex/图片/daimashixian.png" alt="upload succel"></p>
<p>以下函数是用来把域名转化为IP地址的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line"></span><br><span class="line">	struct addrinfo *p,*listp,hints;</span><br><span class="line">	char buf[MAXLINE];</span><br><span class="line">	int rc,flags;</span><br><span class="line"></span><br><span class="line">	if(argc!=2)&#123;</span><br><span class="line">		fprintf(stderr,&quot;usage: %s &lt;domain name&gt;\n&quot;,argv[0]);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//get a list of addinfo records</span><br><span class="line">	memset(&amp;hints,0,sizeof(struct addrinfo));</span><br><span class="line">	hints.ai_family = AF_INET;</span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	if((rc=getaddrinfo(argv[1],NULL,&amp;hints,&amp;listp))!=0)&#123;</span><br><span class="line">		fprintf(stderr,&quot;getaddrinfo error: %s\n&quot;,gai_strerror(rc));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	flags = NI_NUMERICHOST;</span><br><span class="line"></span><br><span class="line">	for(p=listp;p;p = p-&gt;ai_next)&#123;</span><br><span class="line">		Getnameinfo(p-&gt;ai_addr,p-&gt;ai_addrlen,buf,MAXLINE,NULL,0,flags);</span><br><span class="line">		printf(&quot;%s\n&quot;,buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Freeaddrinfo(listp);</span><br><span class="line"></span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p><img src="/home/alex/图片/cline.png" alt="upload sssful"></p>
<p>web server return content to clients,in 2 different ways:</p>
<p>1.取磁盘文件，并把他的内容返回给客户端，磁盘文件称为静态内容，返回文件给客户端叫服务静态内容。</p>
<p>2.运行一个可执行文件，把输出返回给客户端，运行的时候输出内容叫做动态内容，而运行程序并返回输出内容叫做服务动态内容。</p>
<p>web服务器返回的内容都是和它管理的某个文件相关联的，这些文件中的每一个都有一个唯一的名字叫<strong><em>URL，通用资源定位符。</em></strong></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议</p>
<h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>通用网关接口，用来处理服务器向客户端提供动态内容的问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-UNIX-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-UNIX-IO/" itemprop="url">CSAPP-UNIX/IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T16:45:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Unix-I-O-Overview"><a href="#Unix-I-O-Overview" class="headerlink" title="Unix I/O Overview"></a>Unix I/O Overview</h3><p>1.A linux file is a sequence of m bytes</p>
<p>  B0,B1..Bm-1</p>
<p>2.all I/O devices and even the kernel are represented as files</p>
<p>/dev/sda2 (/usr disk partition)<br>/dev/tty2 (terminal)</p>
<p><img src="/home/alex/图片/2018-76.png" alt="filename aady exists, renamed"></p>
<h3 id="File-Types"><a href="#File-Types" class="headerlink" title="File Types"></a>File Types</h3><p>1.regular file</p>
<p>2.directory</p>
<p>3.<strong>socket</strong> for communicating with a process on another machine</p>
<h4 id="regular-files"><a href="#regular-files" class="headerlink" title="regular files"></a>regular files</h4><p>Kernel doesn’t know the difference between text files and regular files</p>
<h3 id="pathname"><a href="#pathname" class="headerlink" title="pathname"></a>pathname</h3><h4 id="absolute-pathname"><a href="#absolute-pathname" class="headerlink" title="absolute pathname"></a>absolute pathname</h4><p>starts with ‘/‘ and denotes path from root</p>
<p>/home/droh/a.c</p>
<h4 id="relative-pathname"><a href="#relative-pathname" class="headerlink" title="relative pathname"></a>relative pathname</h4><p>../home/droh/a.c</p>
<p><img src="/home/alex/图片/ics.png" alt="upload succsful"></p>
<h3 id="open-amp-closing-file"><a href="#open-amp-closing-file" class="headerlink" title="open&amp;closing file"></a>open&amp;closing file</h3><p><img src="/home/alex/图片/open.png" alt="upload successul"></p>
<p><img src="/home/alex/图片/1.png" alt="upload suessful"></p>
<h3 id="Reading-Files"><a href="#Reading-Files" class="headerlink" title="Reading Files"></a>Reading Files</h3><p><img src="/home/alex/图片/rf.png" alt="upload succful"></p>
<h3 id="Writing-Files"><a href="#Writing-Files" class="headerlink" title="Writing Files"></a>Writing Files</h3><p><img src="/home/alex/图片/2018-77.png" alt="filenameady exists, renamed"></p>
<h3 id="Simple-Unix-I-O-example"><a href="#Simple-Unix-I-O-example" class="headerlink" title="Simple Unix I/O example"></a>Simple Unix I/O example</h3><h4 id="bad-case"><a href="#bad-case" class="headerlink" title="bad case"></a>bad case</h4><p>Each while loop, execute 2 operating system function,that means you have to go to the kernel,go through,context switch,do whatever you wants,then switch back. in a word,it is too <strong>expensive</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line"></span><br><span class="line">    while(Read(STDIN_FILENO, &amp;c, 1) != 0)</span><br><span class="line">        Write(STDOUT_FILENO, &amp;c, 1);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="short-counts"><a href="#short-counts" class="headerlink" title="short counts"></a>short counts</h3><p><img src="/home/alex/图片/2018-78.png" alt="filename y exists, renamed"></p>
<h3 id="File-Metadata"><a href="#File-Metadata" class="headerlink" title="File Metadata"></a>File Metadata</h3><p><img src="/home/alex/图片/file metadata.png" alt="upload essful"></p>
<h3 id="File-Sharing"><a href="#File-Sharing" class="headerlink" title="File Sharing"></a>File Sharing</h3><p><img src="/home/alex/图片/fileSharing.png" alt="upload succesul"></p>
<p><img src="/home/alex/图片/2018-79.png" alt="filename ady exists, renamed"></p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><img src="/home/alex/图片/output.png" alt="upload scessful"></p>
<p><img src="/home/alex/图片/2018-80.png" alt="filename aldy exists, renamed"></p>
<p>内核用三个相关的数据结构来表示打开的文件</p>
<p>1.每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的，每个打开的描述符表项指向文件表一个表项。</p>
<p>2.文件表。是所有进程共享的，保存当前文件位置，引用计数（当前指向该表项的描述符表项数），以及一个指向vnode表对应表项的指针</p>
<p>3.vnode表，所有进程共享</p>
<h3 id="I-O-Redirection"><a href="#I-O-Redirection" class="headerlink" title="I/O Redirection"></a>I/O Redirection</h3><p><img src="/home/alex/图片/ioredi.png" alt="upload cessful"></p>
<h4 id="steps-1"><a href="#steps-1" class="headerlink" title="steps 1"></a>steps 1</h4><p><img src="/home/alex/图片/steps1.png" alt="upload sucessful"></p>
<h4 id="steps-2"><a href="#steps-2" class="headerlink" title="steps 2"></a>steps 2</h4><p><img src="/home/alex/图片/samefile.png" alt="upload essful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fd(5,0)</span><br></pre></td></tr></table></figure>
<p>就是把重定向标准输入到描述符5</p>
<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p><img src="/home/alex/图片/ggg.png" alt="upload succeful"></p>
<p>fd3重定向到了fd2，所以他们指向同样的open file table项，c2是第一个字符a，而c3在此基础上读下一个字符，所以是b。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-malloc-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-malloc-lab/" itemprop="url">CSAPP-malloc lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T14:43:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>所用策略：Segregated lists + best fits + explicit free list</p>
<p><img src="/home/alex/图片/disanwei.png" alt="upload sucssful"></p>
<p>堆的结构：<br>地址从上到下是从低到高<br><img src="/home/alex/图片/heap.png" alt="upload successful"></p>
<p><img src="/home/alex/图片/fenlishipei.png" alt="upload ful"></p>
<p>分离适配的原理：</p>
<p>allocator 维护一个空闲链表的数组，每个空闲链表是和一个大小类相关联的，被组织成某种类型的显式或者隐式链表，每个链表包含潜在的大小不同的块。</p>
<p>为了分配，要先确定请求的大小的类，并且对适当的空闲链表做首次适配，如果找到，就分割，并把剩余部分查到空闲链表。如果找不到，就搜索下一个更大的类，如果还是没有，就向操作系统请求额外的堆内存，然后从这个堆内存中分配出一个块，并把剩余部分放在适当的大小类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* single word (4) or double word (8) alignment */</span><br><span class="line">#define ALIGNMENT 8</span><br><span class="line"></span><br><span class="line">/* rounds up to the nearest multiple of ALIGNMENT */</span><br><span class="line">#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define WSIZE 4 //word and header/footer size</span><br><span class="line">#define DSIZE 8 //double word size (bytes)</span><br><span class="line"></span><br><span class="line">#define INITCHUNKSIZE (1&lt;&lt;6) //the size of extended heap </span><br><span class="line">#define CHUNKSIZE (1&lt;&lt;12) //extend heap </span><br><span class="line"></span><br><span class="line">#define MAX(x,y) ((x)&gt;(y))?(x):(y)</span><br><span class="line">#define MIN(x,y) ((x)&lt;(y))?(x):(y)</span><br><span class="line"></span><br><span class="line">#define PACK(size,alloc) ((size)|(alloc))</span><br><span class="line"></span><br><span class="line">//read and write a word at addr p</span><br><span class="line">#define GET(p) (*(unsigned int*)(p))</span><br><span class="line">#define PUT(p,val) (*(unsigned int*)(p) = (val))</span><br><span class="line"></span><br><span class="line">#define SET_PTR(p,ptr) (*(unsigned int*)(p) = (unsigned int)(ptr))</span><br><span class="line"></span><br><span class="line">#define GET_SIZE(p)  (GET(p)&amp;~0x7)</span><br><span class="line">#define GET_ALLOC(p)  (GET(p)&amp;0x1)</span><br><span class="line"></span><br><span class="line">//given block ptr bp,compute address of its header and footer</span><br><span class="line">#define HDRP(bp)  ((char*)(bp)-WSIZE)</span><br><span class="line">// (char*bp)+size -wsize= next&apos;s block&apos;s bp &apos;s position,-DSIZE,that means </span><br><span class="line">//  previous block&apos;s foot address</span><br><span class="line">#define FTRP(bp)  ((char*)(bp)+GET_SIZE(HDRP(bp))-DSIZE)</span><br><span class="line"></span><br><span class="line">#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp)-WSIZE))</span><br><span class="line">#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp)-DSIZE))</span><br><span class="line"></span><br><span class="line">#define PRED_PTR(ptr) ((char*)(ptr))</span><br><span class="line">#define SUCC_PTR(ptr) ((char*)(ptr)+WSIZE)</span><br><span class="line"></span><br><span class="line">#define PRED(ptr) (*(char **)(ptr))</span><br><span class="line">#define SUCC(ptr) (*(char **)(SUCC_PTR(ptr)))</span><br><span class="line"></span><br><span class="line">#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span><br><span class="line">#define LIST_SIZE 16</span><br></pre></td></tr></table></figure>
<p>全局函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void *extend_heap(size_t words);</span><br><span class="line">static void *coalesce(void *bp);</span><br><span class="line">static void *place(void *bp,size_t asize);</span><br><span class="line">static void insert(void *bp,size_t size);</span><br><span class="line">static void delete(void *bp);</span><br></pre></td></tr></table></figure></p>
<p>初始化列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * mm_init - initialize the malloc package.</span><br><span class="line"> */</span><br><span class="line">int mm_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *heap;</span><br><span class="line">    if((heap=mem_sbrk(4*WSIZE))==(void*)-1)</span><br><span class="line">        return -1;</span><br><span class="line">    </span><br><span class="line">    int idx;</span><br><span class="line">	</span><br><span class="line">    //initialize the list</span><br><span class="line">    for(idx=0;idx&lt;LIST_SIZE;idx++)&#123;</span><br><span class="line">        list[idx] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //alignment padding</span><br><span class="line">    //按照上图堆的结构来初始化</span><br><span class="line">    PUT(heap,0);</span><br><span class="line">    PUT(heap+(1*WSIZE),PACK(DSIZE,1));  //prologue header</span><br><span class="line">    PUT(heap+(2*WSIZE),PACK(DSIZE,1)); //prologue footer</span><br><span class="line">    PUT(heap+(3*WSIZE),PACK(0,1)); //Epilogue header</span><br><span class="line"></span><br><span class="line">    if(extend_heap(INITCHUNKSIZE)==NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span><br><span class="line"> *     Always allocate a block whose size is a multiple of the alignment.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void *mm_malloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    //ignore spurious requeses</span><br><span class="line">    if(size==0)</span><br><span class="line">        return NULL;</span><br><span class="line">    </span><br><span class="line">    if(size&lt;=DSIZE)</span><br><span class="line">        size = 2*DSIZE;</span><br><span class="line">    else</span><br><span class="line">        size = ALIGN(size+DSIZE);</span><br><span class="line"></span><br><span class="line">    int idx = 0;</span><br><span class="line">    size_t ssize = size;</span><br><span class="line">    void *ptr = NULL;</span><br><span class="line"></span><br><span class="line">    while(idx&lt;LIST_SIZE)&#123;</span><br><span class="line">		//链表类的大小分别是 1 1 2 4 8 16 32...</span><br><span class="line">        // 分别存储 &#123;0&#125;,&#123;1&#125;,&#123;2,3&#125;,&#123;4,5,6,7&#125;..</span><br><span class="line">        // 通过循环 ssize&gt;&gt;=1 与idx,找到该分配的</span><br><span class="line">        //字节大小所在的链表</span><br><span class="line">        //然后再内嵌一个循环，在这个链表中寻找大小适			//合的pointer</span><br><span class="line">        if((ssize&lt;=1)&amp;&amp;(list[idx]!=NULL))&#123;</span><br><span class="line">            ptr = list[idx];</span><br><span class="line">            while(ptr&amp;&amp;((size&gt;GET_SIZE(HDRP(ptr)))))&#123;</span><br><span class="line">                ptr = PRED(ptr);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果找到了就break</span><br><span class="line">            if(ptr!=NULL)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        ssize&gt;&gt;=1;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果找不到，向系统申请额外的堆内存</span><br><span class="line">    if(ptr==NULL)&#123;</span><br><span class="line">        int extendsize = MAX(size,CHUNKSIZE);</span><br><span class="line">        if((ptr=extend_heap(extendsize))==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //在free块中allocate size大小的块</span><br><span class="line">    ptr = place(ptr,size);</span><br><span class="line"></span><br><span class="line">    return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void mm_free(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">	//把该块头脚末位都标注为0，说明这一块是free</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, 0));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, 0));</span><br><span class="line"></span><br><span class="line">    /* 插入分离空闲链表 */</span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    /* 合并 */</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/13/并发与并行区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/并发与并行区别/" itemprop="url">并发与并行区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T17:15:32+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.cnblogs.com/liqiuhao/p/8082246.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiuhao/p/8082246.html</a></p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>程序加载到内存中执行，（这时变成进程），操作系统会通过虚拟内存机制，通过让它和其他进程分时段占用CPU，使其产生独占CPU的假象。在CPU执行一个进程的指令的时候，被执行的许多指令连接起来，就构成了逻辑控制流。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>就是两个逻辑控制流交替进行</p>
<p><img src="/home/alex/图片/bingfa.png" alt="upload succe"></p>
<p>A与B，A与C并发</p>
<p><strong><em>并发与CPU个数或者计算机个数无关</em></strong></p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p><strong><em>如果两个逻辑控制流同时（一个cpu时段内）在不同的cpu（多核）或者计算机上被执行，我们就称其为并行。</em></strong></p>
<p><img src="/home/alex/图片/2018-75.png" alt="filename already existsmed"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/12/CSAPP-SHELL-LAB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/12/CSAPP-SHELL-LAB/" itemprop="url">CSAPP-SHELL LAB</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-12T13:45:47+08:00">
                2018-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>整个过程中要考虑显式阻塞</p>
<p>1.在访问全局变量（jobs）以及调用给定函数的时候，要阻塞所有的信号，务必保证这些使用for循环遍历的函数不被中断。</p>
<p>2.在一些函数或者指令有必须的先后顺序的时候，要阻塞，保证前一个函数调用完成，再调用后面一个函数。</p>
<p>其他事项：</p>
<p><img src="/home/alex/图片/2018-70.png" alt="filename already exists, renaed"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//判断是否是当前引起停止信号的是否是前台进程</span><br><span class="line">volatile sig_atomic_t fg_stop_or_exit;</span><br></pre></td></tr></table></figure></p>
<h3 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h3><p>功能是对用户输入的参数进行解析，命令有两种，一种是内置的命令，会立刻执行，否则就要ｆｏｒｋ一个新的子进程并且把该任务在子进程的上下文中运行。<strong><em>如果是前台任务则需要等到它运行结束才返回</em></strong></p>
<p>每个子进程必须有一个独一无二的进程组id，通过在fork（）之后子进程的Setpgid(0,0)实现，这样当我们向前台程序发送ctrl+c或者ctrl+z命令才不会影响到后台程序。否则所有的子进程会与当前的tsh shell进程为同一个进程组，发送信号的时候，前后台子进程都会收到。</p>
<p>同时fork新进程的前后要阻塞SIGCHLD信号，防止出现竞争的同步错误：fork之后会在job列表里添加job，信号处理函数sigchld_handler回收进程后会在job列表中删除，如果信号来得很早，那么就可能发生先删除后添加的情况，那么job就会永远在列表中（内存泄漏？），所以我们先block掉SIGCHLD，添加job后再还原。</p>
<p>说白了就是要避免僵尸进程，防止父进程没有给子进程收尸，屏蔽这个信号，那么父亲进程就会不关心这个子进程，子进程结束将由init进程去处理。</p>
<h6 id="setpgid-函数"><a href="#setpgid-函数" class="headerlink" title="setpgid 函数"></a>setpgid 函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setpgid (pid_t pid,pgid_t pgid);</span><br></pre></td></tr></table></figure>
<p>该函数的意义是找到进程ID为pid的进程，将其进程组ID修改为pgid，如果pid=0，说明要修改进程组ID。如果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setpgid(0,0)</span><br></pre></td></tr></table></figure>
<p>表示创立新的进程组，并且指定的进程会成为进程组的首进程。</p>
<p>如果执行成功就返回组识别码，如果有错误则返回-1，错误原因保存在errno中。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>eval函数实现如下：</p>
<p>if builtin_command return 0,then shell starts a new child process,and execute the requested programs in the child process,if the user asks for running the program in background, then shell return back to the top of the loop,waiting for next command. otherwise shell uses the waitpid function to wait for the jobs ‘ termination. when jobs terminates,shell begin a new loop.</p>
<p>参考：<br><a href="https://blog.csdn.net/zxygww/article/details/25976107" target="_blank" rel="noopener">https://blog.csdn.net/zxygww/article/details/25976107</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">void eval(char *cmdline)</span><br><span class="line">&#123;</span><br><span class="line">    char *argv[MAXARGS];  //argument list execve()</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    int argc;</span><br><span class="line">    int bg; //whether the job is in fg or bg</span><br><span class="line">    bg = parseline(cmdline,argv);</span><br><span class="line">    sigset_t mask_chld,mask_all,mask_prev;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;mask_chld);</span><br><span class="line">    #把SIGCHLD信号赋给mask_chld</span><br><span class="line">    sigaddset(&amp;mask_chld,SIGCHLD);</span><br><span class="line">    #fill所有SIG信号给mask_all</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    strcpy(buf,cmdline);</span><br><span class="line"></span><br><span class="line">    //empty command</span><br><span class="line">    if(argv[0]==NULL)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!builtin_cmd(argv))&#123;</span><br><span class="line">		//如果不是内部函数，首先要把SIGCHLD信号阻塞住，以防出现竞争条件。</span><br><span class="line">		//子进程要解决信号阻塞，并执行相关的函数</span><br><span class="line">        //if the below code are outside of the buildin_cmd function,</span><br><span class="line">        //then these locks won&apos;t be realeased when executing inner commands</span><br><span class="line">        //block the SIGCHLD in order to prevent child process ends between father process</span><br><span class="line">		//先要阻塞SIGCHLD信号</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_chld,&amp;mask_prev);</span><br><span class="line">        //codes below won&apos;t be interrupt by signal SIGCHLD</span><br><span class="line"></span><br><span class="line">        //running a child process</span><br><span class="line">        //</span><br><span class="line">        if((pid=fork())==0)&#123;</span><br><span class="line">         //由于子进程会继承block的特性，所以子进程要记得unblock。</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);//unblock the order</span><br><span class="line">            //change the process &apos;s group, not the same as tsh&apos;s group</span><br><span class="line">            setpgid(0,0);</span><br><span class="line">            if(execve(argv[0],argv,environ)&lt;0)&#123;</span><br><span class="line">                printf(&quot;%s: Command not found\n&quot;,argv[0]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //if execve cannot process then child process will execute main process</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //blcok all signal</span><br><span class="line">        //为我阻挡一切！！就算天塌下来也要先addjob不然顺序乱就gg</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,NULL);</span><br><span class="line">        //foreGround</span><br><span class="line">        if(!bg)&#123;</span><br><span class="line">            addjob(jobs,pid,FG,cmdline);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            addjob(jobs,pid,BG,cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">        //block sigchld again</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_chld,NULL);</span><br><span class="line"></span><br><span class="line">        //father process wait until front process stops</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //父进程要判断子进程是前台进程还是后台进程，如果是前台进程，则调用waitpid来等待前台进程，如果是后台，把新添加进程利用addjob添加到工作组中。</span><br><span class="line">        if(!bg)&#123;</span><br><span class="line">            //Block until process pid is no longer the foreground process</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sigprocmask(SIG_BLOCK,&amp;mask_all,NULL);</span><br><span class="line">            struct job_t * currbgmask = getjobpid(jobs,pid);</span><br><span class="line">            printf(&quot;[%d] (%d) %s&quot;,currbgmask-&gt;jid,currbgmask-&gt;pid,currbgmask-&gt;cmdline);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //unblock all signals</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="builtin-command"><a href="#builtin-command" class="headerlink" title="builtin_command"></a>builtin_command</h3><p>注意访问全局变量jobs的时候要阻塞全部信号就是了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int builtin_cmd(char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    sigset_t mask_all,mask_prev;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    if(!strcmp(argv[0],&quot;quit&quot;))&#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;&amp;&quot;))&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;jobs&quot;))&#123;</span><br><span class="line">        //when visit a global variance,you need to block all signals</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;bg&quot;)||!strcmp(argv[0],&quot;fg&quot;))&#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;     /* not a builtin command */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>只要进程号一直是前台程序，就一直sleep等待</p>
<p>但奇怪的是，这个版本的waitfg函数运行有错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">void waitfg(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //fgpid return the pid of the front process id</span><br><span class="line">    </span><br><span class="line">    while((pid==fgpid(jobs)))&#123;</span><br><span class="line">        sleep(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下版本：<br>是书中545中介绍的一种显式接收信号的方法</p>
<p>只要信号处理函数回收了前台进程，它就会将fg_stop_or_exit(注意用volatile关键字声明) 置1，这样我们的waitfg函数就会退出，接着读取用户的下一个输入.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="line"> */</span><br><span class="line">void waitfg(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    sigset_t mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    fg_stop_or_exit = 0;</span><br><span class="line">   </span><br><span class="line">    ////只有发出这个信号的子进程是前台进程才设置fg_stop_or_exit标志。</span><br><span class="line">    while(!fg_stop_or_exit)&#123;</span><br><span class="line">        sigsuspend(&amp;mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sigint-handler-amp-sigtstp-handler"><a href="#sigint-handler-amp-sigtstp-handler" class="headerlink" title="sigint_handler &amp; sigtstp_handler"></a>sigint_handler &amp; sigtstp_handler</h3><p>思路：</p>
<p>1.获取前台进程（fgpid），判断当前是否有前台进程，如果没有则直接返回，有则进行步骤2</p>
<p>2.使用kill函数，发送SIGINT/SIGTSTP信号给前台进程组</p>
<h6 id="kill函数使用"><a href="#kill函数使用" class="headerlink" title="kill函数使用"></a>kill函数使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid,int sig);</span><br><span class="line"></span><br><span class="line">//如果pid大于0，那么kill函数发送信号号码sig给进程pid，如果pid==0，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid&lt;0，则发送sig给进程组|pid|中的每个进程。</span><br></pre></td></tr></table></figure>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>1.访问jobs的时候要阻塞所有信号</p>
<p>2.kill的pid是负的，说明发送信号对象是进程组，是所有前台程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="line"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="line"> *    to the foreground job.</span><br><span class="line"> */</span><br><span class="line">void sigint_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int olderrno = errno;</span><br><span class="line">    sigset_t mask_all,prev_all;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    //execute global function, so block all signals</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    pid=fgpid(jobs);</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,NULL);</span><br><span class="line"></span><br><span class="line">    //only process the front process</span><br><span class="line">    //pid==0 means background process?</span><br><span class="line"></span><br><span class="line">    if(pid!=0)&#123;</span><br><span class="line">        kill(-pid,SIGINT);</span><br><span class="line">        //printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;,pid2jid(pid),pid,sig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><p>1.注意如果进程已经停止，就不要再把它设置为停止了否则会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="line"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="line"> *     foreground job by sending it a SIGTSTP.</span><br><span class="line"> */</span><br><span class="line">void sigtstp_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid=fgpid(jobs);</span><br><span class="line"></span><br><span class="line">    if(pid!=0)&#123;</span><br><span class="line">        struct job_t *job = getjobpid(jobs,pid);</span><br><span class="line">        if(job-&gt;state==ST)</span><br><span class="line">            return;</span><br><span class="line">        else</span><br><span class="line">            kill(-pid,SIGTSTP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h3><p>status表示中止进程或者停止进程的原因，WNOHANG|WUNTRACED作用是判断当前进程中是否存在已经停止或者终止的进程，如果存在则返回pid，不存在立即返回</p>
<p>WIFSTOPPED(status):表示如果进程是因为停止的信号而停止，那么返回true</p>
<p>WIFSIGNALED(status):表示进程是因为捕获的信号而中止，返回true</p>
<p>WIFEXITED(status): 表示进程通过调用exit()或者return正常结束，则返回true。</p>
<p>参考：<a href="https://www.cnblogs.com/sky-heaven/p/8074273.html" target="_blank" rel="noopener">https://www.cnblogs.com/sky-heaven/p/8074273.html</a></p>
<p><img src="/home/alex/图片/2018-69.png" alt="filename already exists, rnamed"></p>
<h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="line"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="line"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="line"> *     available zombie children, but doesn&apos;t wait for any other</span><br><span class="line"> *     currently running children to terminate.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void sigchld_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    int olderrno = errno;</span><br><span class="line">    sigset_t mask_all,prev_all;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    struct job_t *gc_job;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    //尽可能回收子进程，使用WNOHANG,使得如果当前进程都没有停止的时候直接返回，</span><br><span class="line">    //而不是挂起该回收进程，这样可能会阻碍无法两个短时间结束的后台进程</span><br><span class="line"></span><br><span class="line">    while((pid = waitpid(-1,&amp;status,WNOHANG|WUNTRACED))&gt;0)&#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">        gc_job = getjobpid(jobs,pid);</span><br><span class="line">        //说明当前引起停止的确实是前台进程</span><br><span class="line">        if(pid==fgpid(jobs))&#123;</span><br><span class="line">            fg_stop_or_exit=1;</span><br><span class="line">        &#125;</span><br><span class="line">        //子进程正常结束，返回一个非0值</span><br><span class="line">        if(WIFEXITED(status))&#123;</span><br><span class="line">            deletejob(jobs,pid);</span><br><span class="line">        &#125;</span><br><span class="line">        //子进程被暂停，只有暂停不用deletejobs</span><br><span class="line">        else if(WIFSTOPPED(status))&#123;</span><br><span class="line">            //子进程停止引起waitpid函数返回,再判断该进程是否是前台进程</span><br><span class="line">            gc_job-&gt;state = ST;</span><br><span class="line">            printf(&quot;Job [%d] (%d) stopped by signal %d\n&quot;, gc_job-&gt;jid, gc_job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        //因捕获信号而终止</span><br><span class="line">        else if (WIFSIGNALED(status))&#123;</span><br><span class="line">            //子进程终止引起的返回，判断是否是前台进程</span><br><span class="line">            //并且判断该信号是否是未捕获的的信号</span><br><span class="line">            printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;, gc_job-&gt;jid, gc_job-&gt;pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs,pid);</span><br><span class="line">        &#125;</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        //unblock all signals</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;prev_all,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-fgbg"><a href="#do-fgbg" class="headerlink" title="do_fgbg"></a>do_fgbg</h3><p>1.输入时%num 代表jobsid，num代表进程id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="line"> */</span><br><span class="line">void do_bgfg(char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //parameters</span><br><span class="line">    char *para = argv[1];</span><br><span class="line">    </span><br><span class="line">    //lack parameters</span><br><span class="line">    if(para==NULL)&#123;</span><br><span class="line">        printf(&quot;%s command requires PID or %%jobid argument\n&quot;,argv[0]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //full dirname</span><br><span class="line">    char *cmd = argv[0];</span><br><span class="line"></span><br><span class="line">    struct job_t*curr_job;</span><br><span class="line">    sigset_t mask_all,mask_prev;</span><br><span class="line">    int curr_jid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    //first character of the paramaters</span><br><span class="line">    //linux command: fg %n bring process n from background to frontground</span><br><span class="line">    if(para[0]==&apos;%&apos;)&#123;</span><br><span class="line">  </span><br><span class="line">        // the argument is a job id</span><br><span class="line">        curr_jid = atoi(&amp;(para[1]));</span><br><span class="line">        //mistake process2</span><br><span class="line">        curr_job = getjobjid(jobs,curr_jid);</span><br><span class="line">        if(curr_job==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%%%d: No such job\n&quot;,curr_jid);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line">    	// the argument is a process id</span><br><span class="line">        curr_jid = atoi(para);</span><br><span class="line">        if(curr_jid==0)&#123;</span><br><span class="line">            printf(&quot;%s: argument must be a PID or %%jobid\n&quot;,cmd);</span><br><span class="line">            fflush(stdout);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //block all signals when visit global vairance</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">        curr_jid = pid2jid(curr_jid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //block all signals when visit global vairance</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">    curr_job = getjobjid(jobs,curr_jid);</span><br><span class="line"></span><br><span class="line">    if(curr_job==NULL)&#123;</span><br><span class="line">        printf(&quot;(%s): No such process\n&quot;,para);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //bg</span><br><span class="line">    if(!strcmp(cmd,&quot;bg&quot;))&#123;</span><br><span class="line">        switch(curr_job-&gt;state)&#123;</span><br><span class="line">            case ST:</span><br><span class="line">                //change from stop to bg ST-&gt;BG</span><br><span class="line">                //meanwhile send signal to child process</span><br><span class="line">                curr_job-&gt;state =BG;</span><br><span class="line">                kill(-(curr_job-&gt;pid),SIGCONT);</span><br><span class="line">                printf(&quot;[%d] (%d) %s&quot;,curr_job-&gt;jid,curr_job-&gt;pid,curr_job-&gt;cmdline);</span><br><span class="line">                break;</span><br><span class="line">            case BG:</span><br><span class="line">                break;</span><br><span class="line">            case UNDEF:</span><br><span class="line">            case FG:</span><br><span class="line">                unix_error(&quot;bg or undef error&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//要用waitfg指令，等待前台作业结束后再退出    </span><br><span class="line">    else&#123;</span><br><span class="line">        switch(curr_job-&gt;state)&#123;</span><br><span class="line">            //如果作业本身是STOP的话，要记得发送信号（SIGCONT，让其继续运行）</span><br><span class="line">            case ST:</span><br><span class="line">                //change from stop to bg ST-&gt;BG</span><br><span class="line">                //meanwhile send signal to child process</span><br><span class="line">                curr_job-&gt;state =FG;</span><br><span class="line">                //发射信号给前台进程组，所有前台进程都会受到信号</span><br><span class="line">                kill(-(curr_job-&gt;pid),SIGCONT);</span><br><span class="line">                //if change to fg,then you need to wait until it dies</span><br><span class="line">                waitfg(curr_job-&gt;pid);</span><br><span class="line">                break;</span><br><span class="line">            case BG:</span><br><span class="line">                curr_job-&gt;state =FG;</span><br><span class="line">                waitfg(curr_job-&gt;pid);</span><br><span class="line">                break;</span><br><span class="line">            case UNDEF:</span><br><span class="line">            case FG:</span><br><span class="line">                unix_error(&quot;bg or undef error&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当我们在真正的shell（例如bash）中执行tsh时，tsh本身也是被放在前台进程组中的，它的子进程也会在前台进程组中，例如下图所示：</p>
<p><img src="/home/alex/图片/jinchengzu.png" alt="upload succsful"></p>
<h3 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h3><p>1.<a href="https://www.cnblogs.com/liqiuhao/p/8120617.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiuhao/p/8120617.html</a></p>
<p>2.<a href="https://blog.csdn.net/xiaolian_hust/article/details/80087376" target="_blank" rel="noopener">https://blog.csdn.net/xiaolian_hust/article/details/80087376</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/09/DS-动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/DS-动态规划/" itemprop="url">DS-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-09T14:11:52+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Leetcode-647"><a href="#Leetcode-647" class="headerlink" title="Leetcode 647"></a>Leetcode 647</h3><p> Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p>
<p>Example 1:</p>
<p>Input: [1,3,5,4,7]<br>Output: 3<br>Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       if(nums.empty())</span><br><span class="line">           return 0;</span><br><span class="line">       int n = nums.size();</span><br><span class="line">       int dp[n];</span><br><span class="line">       dp[0]=1;</span><br><span class="line">       int res = 1;</span><br><span class="line">       for(int i=1;i&lt;nums.size();i++)&#123;</span><br><span class="line">           if(nums[i-1]&lt;nums[i])&#123;</span><br><span class="line">               dp[i] = dp[i-1]+1;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               dp[i] = 1;</span><br><span class="line">           &#125;</span><br><span class="line">           res = max(dp[i],res);</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="printLIS-路径"><a href="#printLIS-路径" class="headerlink" title="printLIS 路径"></a>printLIS 路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//M saves the index</span><br><span class="line">int M[MAX+1];</span><br><span class="line">int pre[MAX+1];</span><br><span class="line">int pathIndex[MAX+1];</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;vec;</span><br><span class="line"></span><br><span class="line">void print(int pos)&#123;</span><br><span class="line">    if(pos==-1)return;</span><br><span class="line">    print(pre[pos]);</span><br><span class="line">    cout&lt;&lt;&quot; &quot;&lt;&lt;vec[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL); cout.tie(NULL);</span><br><span class="line"></span><br><span class="line">    int N;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        cin&gt;&gt;N;</span><br><span class="line">        if(N==0)</span><br><span class="line">            break;</span><br><span class="line">        vec.assign(N,0);</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            cin&gt;&gt;vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int L = 0;</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            int lo = 1;</span><br><span class="line">            int Hi = L;</span><br><span class="line">            //find the largest mid &lt;=L such that vec[M[mid]]&lt;vec[i]</span><br><span class="line">            while(lo&lt;=Hi)&#123;</span><br><span class="line">                int mid = ceil((lo+Hi)/2.0);</span><br><span class="line">                if(vec[M[mid]]&lt;vec[i])&#123;</span><br><span class="line">                    lo=mid+1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    Hi = mid-1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //newL is 1 greater than the longest prefix of vec[i]</span><br><span class="line">            int newL = lo;</span><br><span class="line">            //vec[i]的前驱节点是newL-1子串的最后一个索引</span><br><span class="line">            pre[i] = M[newL-1];</span><br><span class="line">			//NEWL新子串的最后一个索引就是i</span><br><span class="line">            M[newL] = i;</span><br><span class="line"></span><br><span class="line">            if(newL&gt;L)</span><br><span class="line">                L = newL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int k = M[L];</span><br><span class="line">        for(int i=L-1;i&gt;=0;i--)&#123;</span><br><span class="line">            pathIndex[i] = k;</span><br><span class="line">            k = pre[k];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;L&lt;&lt;&quot; &quot;;</span><br><span class="line">        for(int i=0;i&lt;=L-1;i++)&#123;</span><br><span class="line">            cout&lt;&lt;vec[pathIndex[i]]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-300"><a href="#Leetcode-300" class="headerlink" title="Leetcode 300"></a>Leetcode 300</h3><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:</p>
<p>Input: [10,9,2,5,3,7,101,18]<br>Output: 4<br>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">       if(nums.empty())</span><br><span class="line">           return 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int dp[n];</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            dp[i]=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                if(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    //仅当dp[j]+1&gt;dp[i]的时候才更新</span><br><span class="line">                    if(dp[j]+1&gt;dp[i])&#123;</span><br><span class="line">                        dp[i]=dp[j]+1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            res = max(res,dp[i]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O（n^2）</p>
<p>解析：</p>
<p><a href="https://www.youtube.com/watch?v=CE2b_-XfVDk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CE2b_-XfVDk</a></p>
<p>以下是O(nlogn)作法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">       if(nums.empty())</span><br><span class="line">           return 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int dp[n];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int len=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            int left=0;</span><br><span class="line">            int right = len-1;</span><br><span class="line">            int mid;</span><br><span class="line">            if(dp[len-1]&lt;nums[i])&#123;</span><br><span class="line">                dp[len++]=nums[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(left&lt;=right)&#123;</span><br><span class="line">                    mid = (left+right)/2;</span><br><span class="line">                    if(dp[mid]&lt;nums[i])&#123;</span><br><span class="line">                        left = mid+1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        right = mid-1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[left] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp[i]表示长度为i的LIS序列的最后一个数字最小末尾</p>
<p><a href="https://www.cnblogs.com/ziyi--caolu/p/3227121.html" target="_blank" rel="noopener">https://www.cnblogs.com/ziyi--caolu/p/3227121.html</a></p>
<h3 id="leetcode-53"><a href="#leetcode-53" class="headerlink" title="leetcode 53"></a>leetcode 53</h3><p>Longest maximum subarray</p>
<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:</p>
<p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int max_sum(vector&lt;int&gt;&amp;nums,int i)&#123;</span><br><span class="line">        if(i==0)</span><br><span class="line">            return nums[i];</span><br><span class="line">        int res = max(nums[i],nums[i]+max_sum(nums,i-1));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        if(nums.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            res = max(res,max_sum(nums,i));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<p>转移方程： dp[i] = nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">      if(nums.empty())</span><br><span class="line">          return 0;</span><br><span class="line">      int n = nums.size();</span><br><span class="line">      int dp[n];</span><br><span class="line">      dp[0] = nums[0];</span><br><span class="line">      int res = dp[0];</span><br><span class="line">      for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">          dp[i] = nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</span><br><span class="line">          res = max(res,dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>拓展</p>
<p>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …,<br>Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，<br>例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和<br>为20。<br>在今年的数据结构考卷中，要求编写程序得到最大和，现在增加一个要求，即还需要输出该<br>子序列的第一个和最后一个元素。</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1231" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1231</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">int A[30][30][30];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int k;</span><br><span class="line"></span><br><span class="line">    while(true)&#123;</span><br><span class="line">        long long int dp[10001];</span><br><span class="line">        int arr[10001];</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        if(k==0)</span><br><span class="line">            break;</span><br><span class="line">        int posFlag = 0;</span><br><span class="line">        for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">            if(arr[i]&gt;=0)</span><br><span class="line">                posFlag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(posFlag!=1)&#123;</span><br><span class="line">            cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;arr[1]&lt;&lt;&quot; &quot;&lt;&lt;arr[k]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            double max = -INF;</span><br><span class="line">            dp[1]=arr[1];</span><br><span class="line">            int resulti=1;</span><br><span class="line">            for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">                //or dp[i] = max(dp[i-1]+arr[i],arr[i])</span><br><span class="line">                dp[i] = arr[i]+(dp[i-1]&gt;0?dp[i-1]:0);</span><br><span class="line">                if(dp[i]&gt;max)&#123;</span><br><span class="line">                    max = dp[i];</span><br><span class="line">                    resulti = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            double max2=0;</span><br><span class="line">            int start=1;</span><br><span class="line">            for(int i=resulti;i&gt;=1;i--)&#123;</span><br><span class="line">                max2+=arr[i];</span><br><span class="line">                if(max2==max)&#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;max&lt;&lt;&quot; &quot;&lt;&lt;arr[start]&lt;&lt;&quot; &quot;&lt;&lt;arr[resulti]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键是要找到子序列的第一个元素。</p>
<p>当找到最后一个元素的索引时候，从索引处由后往前找，知道sum等于结果的max，记录下此时的索引i，于是便找到了第一个元素的索引i</p>
<h3 id="Longest-common-subsequence"><a href="#Longest-common-subsequence" class="headerlink" title="Longest common subsequence"></a>Longest common subsequence</h3><p><img src="/home/alex/图片/LCS.png" alt="upload successul"></p>
<p>转移方程 ： res = max(lcs(i-1,j),lcs(i,j-1),1+lcs(i-1,j-1))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string a=&quot;bananinn&quot;;</span><br><span class="line">string b = &quot;kaninan&quot;;</span><br><span class="line"></span><br><span class="line">int lcs(int i,int j)&#123;</span><br><span class="line">    if(i==-1||j==-1)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    res = max(res,lcs(i-1,j));</span><br><span class="line">    res = max(res,lcs(i,j-1));</span><br><span class="line"></span><br><span class="line">    if(a[i]==b[j])&#123;</span><br><span class="line">        res = max(res,1+lcs(i-1,j-1));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int mem[1000][1000];</span><br><span class="line">    memset(mem,-1,sizeof(mem));</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i=0;i&lt;8;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;7;j++)&#123;</span><br><span class="line">            ans = max(ans,lcs(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DP模板"><a href="#DP模板" class="headerlink" title="DP模板"></a>DP模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Dynamic programming formulation</span><br><span class="line">map&lt;problem, value&gt; memory;</span><br><span class="line">	value dp(problem P) &#123;</span><br><span class="line">		if (is_base_case(P)) &#123;</span><br><span class="line">			return base_case_value(P);</span><br><span class="line">	&#125;</span><br><span class="line">		if (memory.find(P) != memory.end()) &#123;</span><br><span class="line">			return memory[P];</span><br><span class="line">	&#125;</span><br><span class="line">		value result = some value;</span><br><span class="line">		for (problem Q in subproblems(P)) &#123;</span><br><span class="line">			result = combine(result, dp(Q));	</span><br><span class="line">		&#125;</span><br><span class="line">		memory[P] = result;</span><br><span class="line">		return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Traveling-Salesman-problem"><a href="#Traveling-Salesman-problem" class="headerlink" title="Traveling Salesman problem"></a>Traveling Salesman problem</h3><p><img src="/home/alex/图片/2018-51.png" alt="filename already existsamed"></p>
<p>TSP问题就是在一张有权图，从某个起点出发，然后go through each node exactly once and finally return to the beginning node,such that the weightSum is minimal</p>
<h4 id="NP-HARD"><a href="#NP-HARD" class="headerlink" title="NP-HARD"></a>NP-HARD</h4><p>no solution with dominomial time complexity </p>
<p><img src="/home/alex/图片/TSP.png" alt="upload succsful"></p>
<p>子问题一共有 2^n*n 个，每个子问题用O(n)复杂度来解决</p>
<p>T:(2^n*n^2)</p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>状态转移方程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//f[i][j]表示i个物品，容量j背包的物品最大价值</span><br><span class="line">//若f[i][j] == f[i-1][j],说明不装第i个</span><br><span class="line">//否则装入第i个，同时容量-w,价值+v,w,v分别为第i个物品的重量和价值</span><br><span class="line"></span><br><span class="line">f[i][j] = max(f[i-1][j],f[i-1][j-w]+v);</span><br></pre></td></tr></table></figure></p>
<h4 id="kattis-knapsack"><a href="#kattis-knapsack" class="headerlink" title="kattis - knapsack"></a>kattis - knapsack</h4><p>关键是如何打印出装入的物品的index</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    double capa;</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;capa&amp;&amp;cin&gt;&gt;n)&#123;</span><br><span class="line">        int capacity = floor(capa);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;f(n+1,vector&lt;int&gt;(capacity+1,0));</span><br><span class="line">        values.assign(n+1,0);</span><br><span class="line">        weights.assign(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int v,w;</span><br><span class="line">            cin&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            weights[i] = w;</span><br><span class="line">            values[i] = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int v = values[i];</span><br><span class="line">            int w = weights[i];</span><br><span class="line">            for(int j=1;j&lt;=capacity;j++)&#123;</span><br><span class="line">                if(j&lt;w)&#123;</span><br><span class="line">                    f[i][j] = f[i-1][j];</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                f[i][j] = max(f[i-1][j],f[i-1][j-w]+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //打印最终装入的物品的index！ 即寻找f[i][j]!=f[i-1][j]</span><br><span class="line">        vector&lt;int&gt;res;</span><br><span class="line">        int j = capacity;</span><br><span class="line">        for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">            if(f[i][j]!=f[i-1][j])&#123;</span><br><span class="line">                res.push_back(i-1);</span><br><span class="line">                j-=weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res.size()&lt;&lt;endl;</span><br><span class="line">        for(auto i:res)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=1579" target="_blank" rel="noopener">http://poj.org/problem?id=1579</a></p>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>把递归结果存在表里，减少不必要的递归次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int A[30][30][30];</span><br><span class="line"></span><br><span class="line">int w(int a,int b,int c)&#123;</span><br><span class="line">    if(a&lt;=0||b&lt;=0||c&lt;=0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a&gt;20||b&gt;20||c&gt;20)&#123;</span><br><span class="line">        return w(20,20,20);</span><br><span class="line">    &#125;</span><br><span class="line">    if(A[a][b][c])  //if already in A no need to do recursion</span><br><span class="line">        return A[a][b][c];</span><br><span class="line">    if(a&lt;b&amp;&amp;b&lt;c)&#123;</span><br><span class="line">        A[a][b][c] =w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c); //A[a][b][c-1]+A[a][b-1][c-1]-A[a][b-1][c];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        A[a][b][c] = w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1);//A[a-1][b][c]+A[a-1][b-1][c]+A[a-1][b][c-1]-A[a-1][b-1][c-1];</span><br><span class="line">    return A[a][b][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    memset(A,0,sizeof(A));</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        if(a==-1&amp;&amp;b==-1&amp;&amp;c==-1)</span><br><span class="line">            break;</span><br><span class="line">        cout&lt;&lt;w(a,b,c)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dfs-solve-TSP"><a href="#dfs-solve-TSP" class="headerlink" title="dfs solve TSP"></a>dfs solve TSP</h3><p><a href="https://open.kattis.com/problems/beepers" target="_blank" rel="noopener">https://open.kattis.com/problems/beepers</a></p>
<p>dfs解TSP问题</p>
<p>基本思路是从出发点开始，尝试从出发点到其他所有点的可能性，然后回溯。</p>
<p>dfs的大概思路就是当n&lt;num的时候，尝试到不同的点，回溯，当n==num的时候，比较现在的路径长度是否小于最短路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int shortest,num;</span><br><span class="line">int startx,starty;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;vec;</span><br><span class="line">int visited[MAX];</span><br><span class="line"></span><br><span class="line">int dis(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    return abs(x1-x2)+abs(y1-y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int cur,int len,int n)&#123;</span><br><span class="line"></span><br><span class="line">    if(n==num)&#123;</span><br><span class="line">        int t = dis(vec[cur].x,vec[cur].y,startx,starty);</span><br><span class="line">        if(len+t&lt;shortest)&#123;</span><br><span class="line">            shortest = len+t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(len&lt;shortest)&#123;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">            if(visited[i]==0)&#123;</span><br><span class="line">                visited[i] = 1;</span><br><span class="line">                DFS(i,len+dis(vec[cur].x,vec[cur].y,vec[i].x,vec[i].y),n+1);</span><br><span class="line">                visited[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL); cout.tie(NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int sc;</span><br><span class="line">    int row,col;</span><br><span class="line">    cin&gt;&gt;sc;</span><br><span class="line">    while(sc--)&#123;</span><br><span class="line">        cin&gt;&gt;row&gt;&gt;col;</span><br><span class="line">        cin&gt;&gt;startx&gt;&gt;starty;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        vec.clear();</span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            int xx,yy;</span><br><span class="line">            cin&gt;&gt;xx&gt;&gt;yy;</span><br><span class="line">            vec.push_back(&#123;xx,yy&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        shortest = INF;</span><br><span class="line">        memset(visited,0,sizeof(visited));</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            int tempL = dis(vec[i].x,vec[i].y,startx,starty);</span><br><span class="line">            visited[i] = 1;</span><br><span class="line">            DFS(i,tempL,1);</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;shortest&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-931"><a href="#leetcode-931" class="headerlink" title="leetcode 931"></a>leetcode 931</h3><p>minimum falling path sum</p>
<p><img src="/home/alex/图片/minimum.png" alt="upload scessful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">    int res = INT_MAX;</span><br><span class="line">    int row = A.size();</span><br><span class="line">    int col = A[0].size();</span><br><span class="line">    int dp[row][col+2];</span><br><span class="line">   </span><br><span class="line">    for(int i=1;i&lt;row;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;col;j++)&#123;</span><br><span class="line">            if(j==0)&#123;</span><br><span class="line">                A[i][j] = A[i][j]+min(A[i-1][j],A[i-1][j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(j==col-1)&#123;</span><br><span class="line">                A[i][j] = A[i][j]+min(A[i-1][j],A[i-1][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">               A[i][j] = A[i][j]+min(A[i-1][j],min(A[i-1][j-1],A[i-1][j+1]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;col;i++)&#123;</span><br><span class="line">        res = min(res,A[row-1][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度 n^2</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="Alex Chiu" />
            
              <p class="site-author-name" itemprop="name">Alex Chiu</p>
              <p class="site-description motion-element" itemprop="description">Alex's personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">50</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Chiu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
