<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Alex&apos;s personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex Chiu">
<meta property="og:url" content="http://AlexanderChiuluvB.github.io/page/3/index.html">
<meta property="og:site_name" content="Alex Chiu">
<meta property="og:description" content="Alex&apos;s personal blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex Chiu">
<meta name="twitter:description" content="Alex&apos;s personal blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://AlexanderChiuluvB.github.io/page/3/"/>





  <title>Alex Chiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex Chiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/13/并发与并行区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/并发与并行区别/" itemprop="url">并发与并行区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T17:15:32+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.cnblogs.com/liqiuhao/p/8082246.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiuhao/p/8082246.html</a></p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>程序加载到内存中执行，（这时变成进程），操作系统会通过虚拟内存机制，通过让它和其他进程分时段占用CPU，使其产生独占CPU的假象。在CPU执行一个进程的指令的时候，被执行的许多指令连接起来，就构成了逻辑控制流。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>就是两个逻辑控制流交替进行</p>
<p><img src="/home/alex/图片/bingfa.png" alt="upload succe"></p>
<p>A与B，A与C并发</p>
<p><strong><em>并发与CPU个数或者计算机个数无关</em></strong></p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p><strong><em>如果两个逻辑控制流同时（一个cpu时段内）在不同的cpu（多核）或者计算机上被执行，我们就称其为并行。</em></strong></p>
<p><img src="/home/alex/图片/2018-75.png" alt="filename already existsmed"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/12/CSAPP-SHELL-LAB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/12/CSAPP-SHELL-LAB/" itemprop="url">CSAPP-SHELL LAB</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-12T13:45:47+08:00">
                2018-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>整个过程中要考虑显式阻塞</p>
<p>1.在访问全局变量（jobs）以及调用给定函数的时候，要阻塞所有的信号，务必保证这些使用for循环遍历的函数不被中断。</p>
<p>2.在一些函数或者指令有必须的先后顺序的时候，要阻塞，保证前一个函数调用完成，再调用后面一个函数。</p>
<p>其他事项：</p>
<p><img src="/home/alex/图片/2018-70.png" alt="filename already exists, renaed"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//判断是否是当前引起停止信号的是否是前台进程</span><br><span class="line">volatile sig_atomic_t fg_stop_or_exit;</span><br></pre></td></tr></table></figure></p>
<h3 id="eval函数"><a href="#eval函数" class="headerlink" title="eval函数"></a>eval函数</h3><p>功能是对用户输入的参数进行解析，命令有两种，一种是内置的命令，会立刻执行，否则就要ｆｏｒｋ一个新的子进程并且把该任务在子进程的上下文中运行。<strong><em>如果是前台任务则需要等到它运行结束才返回</em></strong></p>
<p>每个子进程必须有一个独一无二的进程组id，通过在fork（）之后子进程的Setpgid(0,0)实现，这样当我们向前台程序发送ctrl+c或者ctrl+z命令才不会影响到后台程序。否则所有的子进程会与当前的tsh shell进程为同一个进程组，发送信号的时候，前后台子进程都会收到。</p>
<p>同时fork新进程的前后要阻塞SIGCHLD信号，防止出现竞争的同步错误：fork之后会在job列表里添加job，信号处理函数sigchld_handler回收进程后会在job列表中删除，如果信号来得很早，那么就可能发生先删除后添加的情况，那么job就会永远在列表中（内存泄漏？），所以我们先block掉SIGCHLD，添加job后再还原。</p>
<p>说白了就是要避免僵尸进程，防止父进程没有给子进程收尸，屏蔽这个信号，那么父亲进程就会不关心这个子进程，子进程结束将由init进程去处理。</p>
<h6 id="setpgid-函数"><a href="#setpgid-函数" class="headerlink" title="setpgid 函数"></a>setpgid 函数</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setpgid (pid_t pid,pgid_t pgid);</span><br></pre></td></tr></table></figure>
<p>该函数的意义是找到进程ID为pid的进程，将其进程组ID修改为pgid，如果pid=0，说明要修改进程组ID。如果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setpgid(0,0)</span><br></pre></td></tr></table></figure>
<p>表示创立新的进程组，并且指定的进程会成为进程组的首进程。</p>
<p>如果执行成功就返回组识别码，如果有错误则返回-1，错误原因保存在errno中。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>eval函数实现如下：</p>
<p>if builtin_command return 0,then shell starts a new child process,and execute the requested programs in the child process,if the user asks for running the program in background, then shell return back to the top of the loop,waiting for next command. otherwise shell uses the waitpid function to wait for the jobs ‘ termination. when jobs terminates,shell begin a new loop.</p>
<p>参考：<br><a href="https://blog.csdn.net/zxygww/article/details/25976107" target="_blank" rel="noopener">https://blog.csdn.net/zxygww/article/details/25976107</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">void eval(char *cmdline)</span><br><span class="line">&#123;</span><br><span class="line">    char *argv[MAXARGS];  //argument list execve()</span><br><span class="line">    char buf[MAXLINE];</span><br><span class="line">    int argc;</span><br><span class="line">    int bg; //whether the job is in fg or bg</span><br><span class="line">    bg = parseline(cmdline,argv);</span><br><span class="line">    sigset_t mask_chld,mask_all,mask_prev;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    </span><br><span class="line">    sigemptyset(&amp;mask_chld);</span><br><span class="line">    #把SIGCHLD信号赋给mask_chld</span><br><span class="line">    sigaddset(&amp;mask_chld,SIGCHLD);</span><br><span class="line">    #fill所有SIG信号给mask_all</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    strcpy(buf,cmdline);</span><br><span class="line"></span><br><span class="line">    //empty command</span><br><span class="line">    if(argv[0]==NULL)&#123;</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!builtin_cmd(argv))&#123;</span><br><span class="line">		//如果不是内部函数，首先要把SIGCHLD信号阻塞住，以防出现竞争条件。</span><br><span class="line">		//子进程要解决信号阻塞，并执行相关的函数</span><br><span class="line">        //if the below code are outside of the buildin_cmd function,</span><br><span class="line">        //then these locks won&apos;t be realeased when executing inner commands</span><br><span class="line">        //block the SIGCHLD in order to prevent child process ends between father process</span><br><span class="line">		//先要阻塞SIGCHLD信号</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_chld,&amp;mask_prev);</span><br><span class="line">        //codes below won&apos;t be interrupt by signal SIGCHLD</span><br><span class="line"></span><br><span class="line">        //running a child process</span><br><span class="line">        //</span><br><span class="line">        if((pid=fork())==0)&#123;</span><br><span class="line">         //由于子进程会继承block的特性，所以子进程要记得unblock。</span><br><span class="line">            sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);//unblock the order</span><br><span class="line">            //change the process &apos;s group, not the same as tsh&apos;s group</span><br><span class="line">            setpgid(0,0);</span><br><span class="line">            if(execve(argv[0],argv,environ)&lt;0)&#123;</span><br><span class="line">                printf(&quot;%s: Command not found\n&quot;,argv[0]);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            //if execve cannot process then child process will execute main process</span><br><span class="line">            exit(0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //blcok all signal</span><br><span class="line">        //为我阻挡一切！！就算天塌下来也要先addjob不然顺序乱就gg</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,NULL);</span><br><span class="line">        //foreGround</span><br><span class="line">        if(!bg)&#123;</span><br><span class="line">            addjob(jobs,pid,FG,cmdline);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            addjob(jobs,pid,BG,cmdline);</span><br><span class="line">        &#125;</span><br><span class="line">        //block sigchld again</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_chld,NULL);</span><br><span class="line"></span><br><span class="line">        //father process wait until front process stops</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        //父进程要判断子进程是前台进程还是后台进程，如果是前台进程，则调用waitpid来等待前台进程，如果是后台，把新添加进程利用addjob添加到工作组中。</span><br><span class="line">        if(!bg)&#123;</span><br><span class="line">            //Block until process pid is no longer the foreground process</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            sigprocmask(SIG_BLOCK,&amp;mask_all,NULL);</span><br><span class="line">            struct job_t * currbgmask = getjobpid(jobs,pid);</span><br><span class="line">            printf(&quot;[%d] (%d) %s&quot;,currbgmask-&gt;jid,currbgmask-&gt;pid,currbgmask-&gt;cmdline);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //unblock all signals</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="builtin-command"><a href="#builtin-command" class="headerlink" title="builtin_command"></a>builtin_command</h3><p>注意访问全局变量jobs的时候要阻塞全部信号就是了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int builtin_cmd(char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    sigset_t mask_all,mask_prev;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    if(!strcmp(argv[0],&quot;quit&quot;))&#123;</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;&amp;&quot;))&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;jobs&quot;))&#123;</span><br><span class="line">        //when visit a global variance,you need to block all signals</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(!strcmp(argv[0],&quot;bg&quot;)||!strcmp(argv[0],&quot;fg&quot;))&#123;</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;     /* not a builtin command */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="waitfg"><a href="#waitfg" class="headerlink" title="waitfg"></a>waitfg</h3><p>只要进程号一直是前台程序，就一直sleep等待</p>
<p>但奇怪的是，这个版本的waitfg函数运行有错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">void waitfg(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //fgpid return the pid of the front process id</span><br><span class="line">    </span><br><span class="line">    while((pid==fgpid(jobs)))&#123;</span><br><span class="line">        sleep(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以下版本：<br>是书中545中介绍的一种显式接收信号的方法</p>
<p>只要信号处理函数回收了前台进程，它就会将fg_stop_or_exit(注意用volatile关键字声明) 置1，这样我们的waitfg函数就会退出，接着读取用户的下一个输入.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * waitfg - Block until process pid is no longer the foreground process</span><br><span class="line"> */</span><br><span class="line">void waitfg(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    sigset_t mask;</span><br><span class="line">    sigemptyset(&amp;mask);</span><br><span class="line">    fg_stop_or_exit = 0;</span><br><span class="line">   </span><br><span class="line">    ////只有发出这个信号的子进程是前台进程才设置fg_stop_or_exit标志。</span><br><span class="line">    while(!fg_stop_or_exit)&#123;</span><br><span class="line">        sigsuspend(&amp;mask);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sigint-handler-amp-sigtstp-handler"><a href="#sigint-handler-amp-sigtstp-handler" class="headerlink" title="sigint_handler &amp; sigtstp_handler"></a>sigint_handler &amp; sigtstp_handler</h3><p>思路：</p>
<p>1.获取前台进程（fgpid），判断当前是否有前台进程，如果没有则直接返回，有则进行步骤2</p>
<p>2.使用kill函数，发送SIGINT/SIGTSTP信号给前台进程组</p>
<h6 id="kill函数使用"><a href="#kill函数使用" class="headerlink" title="kill函数使用"></a>kill函数使用</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int kill(pid_t pid,int sig);</span><br><span class="line"></span><br><span class="line">//如果pid大于0，那么kill函数发送信号号码sig给进程pid，如果pid==0，那么kill发送信号sig给调用进程所在进程组中的每个进程，包括调用进程自己。如果pid&lt;0，则发送sig给进程组|pid|中的每个进程。</span><br></pre></td></tr></table></figure>
<h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><p>1.访问jobs的时候要阻塞所有信号</p>
<p>2.kill的pid是负的，说明发送信号对象是进程组，是所有前台程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * sigint_handler - The kernel sends a SIGINT to the shell whenver the</span><br><span class="line"> *    user types ctrl-c at the keyboard.  Catch it and send it along</span><br><span class="line"> *    to the foreground job.</span><br><span class="line"> */</span><br><span class="line">void sigint_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int olderrno = errno;</span><br><span class="line">    sigset_t mask_all,prev_all;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line">    //execute global function, so block all signals</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">    pid=fgpid(jobs);</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;prev_all,NULL);</span><br><span class="line"></span><br><span class="line">    //only process the front process</span><br><span class="line">    //pid==0 means background process?</span><br><span class="line"></span><br><span class="line">    if(pid!=0)&#123;</span><br><span class="line">        kill(-pid,SIGINT);</span><br><span class="line">        //printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;,pid2jid(pid),pid,sig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    errno = olderrno;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码如下-1"><a href="#代码如下-1" class="headerlink" title="代码如下"></a>代码如下</h4><p>1.注意如果进程已经停止，就不要再把它设置为停止了否则会出错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * sigtstp_handler - The kernel sends a SIGTSTP to the shell whenever</span><br><span class="line"> *     the user types ctrl-z at the keyboard. Catch it and suspend the</span><br><span class="line"> *     foreground job by sending it a SIGTSTP.</span><br><span class="line"> */</span><br><span class="line">void sigtstp_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid=fgpid(jobs);</span><br><span class="line"></span><br><span class="line">    if(pid!=0)&#123;</span><br><span class="line">        struct job_t *job = getjobpid(jobs,pid);</span><br><span class="line">        if(job-&gt;state==ST)</span><br><span class="line">            return;</span><br><span class="line">        else</span><br><span class="line">            kill(-pid,SIGTSTP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sigchld-handler"><a href="#sigchld-handler" class="headerlink" title="sigchld_handler"></a>sigchld_handler</h3><p>status表示中止进程或者停止进程的原因，WNOHANG|WUNTRACED作用是判断当前进程中是否存在已经停止或者终止的进程，如果存在则返回pid，不存在立即返回</p>
<p>WIFSTOPPED(status):表示如果进程是因为停止的信号而停止，那么返回true</p>
<p>WIFSIGNALED(status):表示进程是因为捕获的信号而中止，返回true</p>
<p>WIFEXITED(status): 表示进程通过调用exit()或者return正常结束，则返回true。</p>
<p>参考：<a href="https://www.cnblogs.com/sky-heaven/p/8074273.html" target="_blank" rel="noopener">https://www.cnblogs.com/sky-heaven/p/8074273.html</a></p>
<p><img src="/home/alex/图片/2018-69.png" alt="filename already exists, rnamed"></p>
<h4 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * sigchld_handler - The kernel sends a SIGCHLD to the shell whenever</span><br><span class="line"> *     a child job terminates (becomes a zombie), or stops because it</span><br><span class="line"> *     received a SIGSTOP or SIGTSTP signal. The handler reaps all</span><br><span class="line"> *     available zombie children, but doesn&apos;t wait for any other</span><br><span class="line"> *     currently running children to terminate.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void sigchld_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    int olderrno = errno;</span><br><span class="line">    sigset_t mask_all,prev_all;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    struct job_t *gc_job;</span><br><span class="line">    int status;</span><br><span class="line"></span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    //尽可能回收子进程，使用WNOHANG,使得如果当前进程都没有停止的时候直接返回，</span><br><span class="line">    //而不是挂起该回收进程，这样可能会阻碍无法两个短时间结束的后台进程</span><br><span class="line"></span><br><span class="line">    while((pid = waitpid(-1,&amp;status,WNOHANG|WUNTRACED))&gt;0)&#123;</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;prev_all);</span><br><span class="line">        gc_job = getjobpid(jobs,pid);</span><br><span class="line">        //说明当前引起停止的确实是前台进程</span><br><span class="line">        if(pid==fgpid(jobs))&#123;</span><br><span class="line">            fg_stop_or_exit=1;</span><br><span class="line">        &#125;</span><br><span class="line">        //子进程正常结束，返回一个非0值</span><br><span class="line">        if(WIFEXITED(status))&#123;</span><br><span class="line">            deletejob(jobs,pid);</span><br><span class="line">        &#125;</span><br><span class="line">        //子进程被暂停，只有暂停不用deletejobs</span><br><span class="line">        else if(WIFSTOPPED(status))&#123;</span><br><span class="line">            //子进程停止引起waitpid函数返回,再判断该进程是否是前台进程</span><br><span class="line">            gc_job-&gt;state = ST;</span><br><span class="line">            printf(&quot;Job [%d] (%d) stopped by signal %d\n&quot;, gc_job-&gt;jid, gc_job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        //因捕获信号而终止</span><br><span class="line">        else if (WIFSIGNALED(status))&#123;</span><br><span class="line">            //子进程终止引起的返回，判断是否是前台进程</span><br><span class="line">            //并且判断该信号是否是未捕获的的信号</span><br><span class="line">            printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;, gc_job-&gt;jid, gc_job-&gt;pid, WTERMSIG(status));</span><br><span class="line">            deletejob(jobs,pid);</span><br><span class="line">        &#125;</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        //unblock all signals</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;prev_all,NULL);</span><br><span class="line">    &#125;</span><br><span class="line">    errno = olderrno;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="do-fgbg"><a href="#do-fgbg" class="headerlink" title="do_fgbg"></a>do_fgbg</h3><p>1.输入时%num 代表jobsid，num代表进程id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * do_bgfg - Execute the builtin bg and fg commands</span><br><span class="line"> */</span><br><span class="line">void do_bgfg(char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //parameters</span><br><span class="line">    char *para = argv[1];</span><br><span class="line">    </span><br><span class="line">    //lack parameters</span><br><span class="line">    if(para==NULL)&#123;</span><br><span class="line">        printf(&quot;%s command requires PID or %%jobid argument\n&quot;,argv[0]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //full dirname</span><br><span class="line">    char *cmd = argv[0];</span><br><span class="line"></span><br><span class="line">    struct job_t*curr_job;</span><br><span class="line">    sigset_t mask_all,mask_prev;</span><br><span class="line">    int curr_jid;</span><br><span class="line">    sigfillset(&amp;mask_all);</span><br><span class="line"></span><br><span class="line">    //first character of the paramaters</span><br><span class="line">    //linux command: fg %n bring process n from background to frontground</span><br><span class="line">    if(para[0]==&apos;%&apos;)&#123;</span><br><span class="line">  </span><br><span class="line">        // the argument is a job id</span><br><span class="line">        curr_jid = atoi(&amp;(para[1]));</span><br><span class="line">        //mistake process2</span><br><span class="line">        curr_job = getjobjid(jobs,curr_jid);</span><br><span class="line">        if(curr_job==NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%%%d: No such job\n&quot;,curr_jid);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    else&#123;</span><br><span class="line">    	// the argument is a process id</span><br><span class="line">        curr_jid = atoi(para);</span><br><span class="line">        if(curr_jid==0)&#123;</span><br><span class="line">            printf(&quot;%s: argument must be a PID or %%jobid\n&quot;,cmd);</span><br><span class="line">            fflush(stdout);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //block all signals when visit global vairance</span><br><span class="line">        sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">        curr_jid = pid2jid(curr_jid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //block all signals when visit global vairance</span><br><span class="line">    sigprocmask(SIG_BLOCK,&amp;mask_all,&amp;mask_prev);</span><br><span class="line">    curr_job = getjobjid(jobs,curr_jid);</span><br><span class="line"></span><br><span class="line">    if(curr_job==NULL)&#123;</span><br><span class="line">        printf(&quot;(%s): No such process\n&quot;,para);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //bg</span><br><span class="line">    if(!strcmp(cmd,&quot;bg&quot;))&#123;</span><br><span class="line">        switch(curr_job-&gt;state)&#123;</span><br><span class="line">            case ST:</span><br><span class="line">                //change from stop to bg ST-&gt;BG</span><br><span class="line">                //meanwhile send signal to child process</span><br><span class="line">                curr_job-&gt;state =BG;</span><br><span class="line">                kill(-(curr_job-&gt;pid),SIGCONT);</span><br><span class="line">                printf(&quot;[%d] (%d) %s&quot;,curr_job-&gt;jid,curr_job-&gt;pid,curr_job-&gt;cmdline);</span><br><span class="line">                break;</span><br><span class="line">            case BG:</span><br><span class="line">                break;</span><br><span class="line">            case UNDEF:</span><br><span class="line">            case FG:</span><br><span class="line">                unix_error(&quot;bg or undef error&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	//要用waitfg指令，等待前台作业结束后再退出    </span><br><span class="line">    else&#123;</span><br><span class="line">        switch(curr_job-&gt;state)&#123;</span><br><span class="line">            //如果作业本身是STOP的话，要记得发送信号（SIGCONT，让其继续运行）</span><br><span class="line">            case ST:</span><br><span class="line">                //change from stop to bg ST-&gt;BG</span><br><span class="line">                //meanwhile send signal to child process</span><br><span class="line">                curr_job-&gt;state =FG;</span><br><span class="line">                //发射信号给前台进程组，所有前台进程都会受到信号</span><br><span class="line">                kill(-(curr_job-&gt;pid),SIGCONT);</span><br><span class="line">                //if change to fg,then you need to wait until it dies</span><br><span class="line">                waitfg(curr_job-&gt;pid);</span><br><span class="line">                break;</span><br><span class="line">            case BG:</span><br><span class="line">                curr_job-&gt;state =FG;</span><br><span class="line">                waitfg(curr_job-&gt;pid);</span><br><span class="line">                break;</span><br><span class="line">            case UNDEF:</span><br><span class="line">            case FG:</span><br><span class="line">                unix_error(&quot;bg or undef error&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sigprocmask(SIG_SETMASK,&amp;mask_prev,NULL);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>当我们在真正的shell（例如bash）中执行tsh时，tsh本身也是被放在前台进程组中的，它的子进程也会在前台进程组中，例如下图所示：</p>
<p><img src="/home/alex/图片/jinchengzu.png" alt="upload succsful"></p>
<h3 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h3><p>1.<a href="https://www.cnblogs.com/liqiuhao/p/8120617.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiuhao/p/8120617.html</a></p>
<p>2.<a href="https://blog.csdn.net/xiaolian_hust/article/details/80087376" target="_blank" rel="noopener">https://blog.csdn.net/xiaolian_hust/article/details/80087376</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/09/DS-动态规划/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/DS-动态规划/" itemprop="url">DS-动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-09T14:11:52+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Leetcode-647"><a href="#Leetcode-647" class="headerlink" title="Leetcode 647"></a>Leetcode 647</h3><p> Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p>
<p>Example 1:</p>
<p>Input: [1,3,5,4,7]<br>Output: 3<br>Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">       if(nums.empty())</span><br><span class="line">           return 0;</span><br><span class="line">       int n = nums.size();</span><br><span class="line">       int dp[n];</span><br><span class="line">       dp[0]=1;</span><br><span class="line">       int res = 1;</span><br><span class="line">       for(int i=1;i&lt;nums.size();i++)&#123;</span><br><span class="line">           if(nums[i-1]&lt;nums[i])&#123;</span><br><span class="line">               dp[i] = dp[i-1]+1;</span><br><span class="line">           &#125;</span><br><span class="line">           else&#123;</span><br><span class="line">               dp[i] = 1;</span><br><span class="line">           &#125;</span><br><span class="line">           res = max(dp[i],res);</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="printLIS-路径"><a href="#printLIS-路径" class="headerlink" title="printLIS 路径"></a>printLIS 路径</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//M saves the index</span><br><span class="line">int M[MAX+1];</span><br><span class="line">int pre[MAX+1];</span><br><span class="line">int pathIndex[MAX+1];</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;vec;</span><br><span class="line"></span><br><span class="line">void print(int pos)&#123;</span><br><span class="line">    if(pos==-1)return;</span><br><span class="line">    print(pre[pos]);</span><br><span class="line">    cout&lt;&lt;&quot; &quot;&lt;&lt;vec[pos];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL); cout.tie(NULL);</span><br><span class="line"></span><br><span class="line">    int N;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        cin&gt;&gt;N;</span><br><span class="line">        if(N==0)</span><br><span class="line">            break;</span><br><span class="line">        vec.assign(N,0);</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            cin&gt;&gt;vec[i];</span><br><span class="line">        &#125;</span><br><span class="line">        int L = 0;</span><br><span class="line">        for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">            int lo = 1;</span><br><span class="line">            int Hi = L;</span><br><span class="line">            //find the largest mid &lt;=L such that vec[M[mid]]&lt;vec[i]</span><br><span class="line">            while(lo&lt;=Hi)&#123;</span><br><span class="line">                int mid = ceil((lo+Hi)/2.0);</span><br><span class="line">                if(vec[M[mid]]&lt;vec[i])&#123;</span><br><span class="line">                    lo=mid+1;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    Hi = mid-1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            //newL is 1 greater than the longest prefix of vec[i]</span><br><span class="line">            int newL = lo;</span><br><span class="line">            //vec[i]的前驱节点是newL-1子串的最后一个索引</span><br><span class="line">            pre[i] = M[newL-1];</span><br><span class="line">			//NEWL新子串的最后一个索引就是i</span><br><span class="line">            M[newL] = i;</span><br><span class="line"></span><br><span class="line">            if(newL&gt;L)</span><br><span class="line">                L = newL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int k = M[L];</span><br><span class="line">        for(int i=L-1;i&gt;=0;i--)&#123;</span><br><span class="line">            pathIndex[i] = k;</span><br><span class="line">            k = pre[k];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;L&lt;&lt;&quot; &quot;;</span><br><span class="line">        for(int i=0;i&lt;=L-1;i++)&#123;</span><br><span class="line">            cout&lt;&lt;vec[pathIndex[i]]&lt;&lt;&quot; &quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Leetcode-300"><a href="#Leetcode-300" class="headerlink" title="Leetcode 300"></a>Leetcode 300</h3><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:</p>
<p>Input: [10,9,2,5,3,7,101,18]<br>Output: 4<br>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">       if(nums.empty())</span><br><span class="line">           return 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int dp[n];</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            dp[i]=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">                if(nums[j]&lt;nums[i])&#123;</span><br><span class="line">                    //仅当dp[j]+1&gt;dp[i]的时候才更新</span><br><span class="line">                    if(dp[j]+1&gt;dp[i])&#123;</span><br><span class="line">                        dp[i]=dp[j]+1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for(int i=0;i&lt;n;i++)</span><br><span class="line">            res = max(res,dp[i]);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>复杂度：O（n^2）</p>
<p>解析：</p>
<p><a href="https://www.youtube.com/watch?v=CE2b_-XfVDk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=CE2b_-XfVDk</a></p>
<p>以下是O(nlogn)作法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">    </span><br><span class="line">       if(nums.empty())</span><br><span class="line">           return 0;</span><br><span class="line">        int n = nums.size();</span><br><span class="line">        int dp[n];</span><br><span class="line">        dp[0] = nums[0];</span><br><span class="line">        int len=1;</span><br><span class="line">        for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">            int left=0;</span><br><span class="line">            int right = len-1;</span><br><span class="line">            int mid;</span><br><span class="line">            if(dp[len-1]&lt;nums[i])&#123;</span><br><span class="line">                dp[len++]=nums[i];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                while(left&lt;=right)&#123;</span><br><span class="line">                    mid = (left+right)/2;</span><br><span class="line">                    if(dp[mid]&lt;nums[i])&#123;</span><br><span class="line">                        left = mid+1;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        right = mid-1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[left] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>dp[i]表示长度为i的LIS序列的最后一个数字最小末尾</p>
<p><a href="https://www.cnblogs.com/ziyi--caolu/p/3227121.html" target="_blank" rel="noopener">https://www.cnblogs.com/ziyi--caolu/p/3227121.html</a></p>
<h3 id="leetcode-53"><a href="#leetcode-53" class="headerlink" title="leetcode 53"></a>leetcode 53</h3><p>Longest maximum subarray</p>
<p>Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p>Example:</p>
<p>Input: [-2,1,-3,4,-1,2,1,-5,4],<br>Output: 6<br>Explanation: [4,-1,2,1] has the largest sum = 6.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int max_sum(vector&lt;int&gt;&amp;nums,int i)&#123;</span><br><span class="line">        if(i==0)</span><br><span class="line">            return nums[i];</span><br><span class="line">        int res = max(nums[i],nums[i]+max_sum(nums,i-1));</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        </span><br><span class="line">        if(nums.empty())</span><br><span class="line">            return 0;</span><br><span class="line">        int res = nums[0];</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            res = max(res,max_sum(nums,i));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法二：</p>
<p>转移方程： dp[i] = nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">      if(nums.empty())</span><br><span class="line">          return 0;</span><br><span class="line">      int n = nums.size();</span><br><span class="line">      int dp[n];</span><br><span class="line">      dp[0] = nums[0];</span><br><span class="line">      int res = dp[0];</span><br><span class="line">      for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">          dp[i] = nums[i]+(dp[i-1]&gt;0?dp[i-1]:0);</span><br><span class="line">          res = max(res,dp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>拓展</p>
<p>给定K个整数的序列{ N1, N2, …, NK }，其任意连续子序列可表示为{ Ni, Ni+1, …,<br>Nj }，其中 1 &lt;= i &lt;= j &lt;= K。最大连续子序列是所有连续子序列中元素和最大的一个，<br>例如给定序列{ -2, 11, -4, 13, -5, -2 }，其最大连续子序列为{ 11, -4, 13 }，最大和<br>为20。<br>在今年的数据结构考卷中，要求编写程序得到最大和，现在增加一个要求，即还需要输出该<br>子序列的第一个和最后一个元素。</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1231" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=1231</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">#define INF 0x3f3f3f3f</span><br><span class="line">int A[30][30][30];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int k;</span><br><span class="line"></span><br><span class="line">    while(true)&#123;</span><br><span class="line">        long long int dp[10001];</span><br><span class="line">        int arr[10001];</span><br><span class="line">        cin&gt;&gt;k;</span><br><span class="line">        if(k==0)</span><br><span class="line">            break;</span><br><span class="line">        int posFlag = 0;</span><br><span class="line">        for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">            if(arr[i]&gt;=0)</span><br><span class="line">                posFlag=1;</span><br><span class="line">        &#125;</span><br><span class="line">        if(posFlag!=1)&#123;</span><br><span class="line">            cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;arr[1]&lt;&lt;&quot; &quot;&lt;&lt;arr[k]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            double max = -INF;</span><br><span class="line">            dp[1]=arr[1];</span><br><span class="line">            int resulti=1;</span><br><span class="line">            for(int i=1;i&lt;=k;i++)&#123;</span><br><span class="line">                //or dp[i] = max(dp[i-1]+arr[i],arr[i])</span><br><span class="line">                dp[i] = arr[i]+(dp[i-1]&gt;0?dp[i-1]:0);</span><br><span class="line">                if(dp[i]&gt;max)&#123;</span><br><span class="line">                    max = dp[i];</span><br><span class="line">                    resulti = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            double max2=0;</span><br><span class="line">            int start=1;</span><br><span class="line">            for(int i=resulti;i&gt;=1;i--)&#123;</span><br><span class="line">                max2+=arr[i];</span><br><span class="line">                if(max2==max)&#123;</span><br><span class="line">                    start = i;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;max&lt;&lt;&quot; &quot;&lt;&lt;arr[start]&lt;&lt;&quot; &quot;&lt;&lt;arr[resulti]&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键是要找到子序列的第一个元素。</p>
<p>当找到最后一个元素的索引时候，从索引处由后往前找，知道sum等于结果的max，记录下此时的索引i，于是便找到了第一个元素的索引i</p>
<h3 id="Longest-common-subsequence"><a href="#Longest-common-subsequence" class="headerlink" title="Longest common subsequence"></a>Longest common subsequence</h3><p><img src="/home/alex/图片/LCS.png" alt="upload successul"></p>
<p>转移方程 ： res = max(lcs(i-1,j),lcs(i,j-1),1+lcs(i-1,j-1))</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">string a=&quot;bananinn&quot;;</span><br><span class="line">string b = &quot;kaninan&quot;;</span><br><span class="line"></span><br><span class="line">int lcs(int i,int j)&#123;</span><br><span class="line">    if(i==-1||j==-1)</span><br><span class="line">        return 0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int res=0;</span><br><span class="line">    res = max(res,lcs(i-1,j));</span><br><span class="line">    res = max(res,lcs(i,j-1));</span><br><span class="line"></span><br><span class="line">    if(a[i]==b[j])&#123;</span><br><span class="line">        res = max(res,1+lcs(i-1,j-1));</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int mem[1000][1000];</span><br><span class="line">    memset(mem,-1,sizeof(mem));</span><br><span class="line">    int ans = 0;</span><br><span class="line">    for(int i=0;i&lt;8;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;7;j++)&#123;</span><br><span class="line">            ans = max(ans,lcs(i,j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DP模板"><a href="#DP模板" class="headerlink" title="DP模板"></a>DP模板</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Dynamic programming formulation</span><br><span class="line">map&lt;problem, value&gt; memory;</span><br><span class="line">	value dp(problem P) &#123;</span><br><span class="line">		if (is_base_case(P)) &#123;</span><br><span class="line">			return base_case_value(P);</span><br><span class="line">	&#125;</span><br><span class="line">		if (memory.find(P) != memory.end()) &#123;</span><br><span class="line">			return memory[P];</span><br><span class="line">	&#125;</span><br><span class="line">		value result = some value;</span><br><span class="line">		for (problem Q in subproblems(P)) &#123;</span><br><span class="line">			result = combine(result, dp(Q));	</span><br><span class="line">		&#125;</span><br><span class="line">		memory[P] = result;</span><br><span class="line">		return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Traveling-Salesman-problem"><a href="#Traveling-Salesman-problem" class="headerlink" title="Traveling Salesman problem"></a>Traveling Salesman problem</h3><p><img src="/home/alex/图片/2018-51.png" alt="filename already existsamed"></p>
<p>TSP问题就是在一张有权图，从某个起点出发，然后go through each node exactly once and finally return to the beginning node,such that the weightSum is minimal</p>
<h4 id="NP-HARD"><a href="#NP-HARD" class="headerlink" title="NP-HARD"></a>NP-HARD</h4><p>no solution with dominomial time complexity </p>
<p><img src="/home/alex/图片/TSP.png" alt="upload succsful"></p>
<p>子问题一共有 2^n*n 个，每个子问题用O(n)复杂度来解决</p>
<p>T:(2^n*n^2)</p>
<h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><p>状态转移方程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//f[i][j]表示i个物品，容量j背包的物品最大价值</span><br><span class="line">//若f[i][j] == f[i-1][j],说明不装第i个</span><br><span class="line">//否则装入第i个，同时容量-w,价值+v,w,v分别为第i个物品的重量和价值</span><br><span class="line"></span><br><span class="line">f[i][j] = max(f[i-1][j],f[i-1][j-w]+v);</span><br></pre></td></tr></table></figure></p>
<h4 id="kattis-knapsack"><a href="#kattis-knapsack" class="headerlink" title="kattis - knapsack"></a>kattis - knapsack</h4><p>关键是如何打印出装入的物品的index</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    double capa;</span><br><span class="line">    int n;</span><br><span class="line">    while(cin&gt;&gt;capa&amp;&amp;cin&gt;&gt;n)&#123;</span><br><span class="line">        int capacity = floor(capa);</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;f(n+1,vector&lt;int&gt;(capacity+1,0));</span><br><span class="line">        values.assign(n+1,0);</span><br><span class="line">        weights.assign(n+1,0);</span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int v,w;</span><br><span class="line">            cin&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            weights[i] = w;</span><br><span class="line">            values[i] = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            int v = values[i];</span><br><span class="line">            int w = weights[i];</span><br><span class="line">            for(int j=1;j&lt;=capacity;j++)&#123;</span><br><span class="line">                if(j&lt;w)&#123;</span><br><span class="line">                    f[i][j] = f[i-1][j];</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                f[i][j] = max(f[i-1][j],f[i-1][j-w]+v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //打印最终装入的物品的index！ 即寻找f[i][j]!=f[i-1][j]</span><br><span class="line">        vector&lt;int&gt;res;</span><br><span class="line">        int j = capacity;</span><br><span class="line">        for(int i=n;i&gt;=1;i--)&#123;</span><br><span class="line">            if(f[i][j]!=f[i-1][j])&#123;</span><br><span class="line">                res.push_back(i-1);</span><br><span class="line">                j-=weights[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;res.size()&lt;&lt;endl;</span><br><span class="line">        for(auto i:res)</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=1579" target="_blank" rel="noopener">http://poj.org/problem?id=1579</a></p>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>把递归结果存在表里，减少不必要的递归次数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int A[30][30][30];</span><br><span class="line"></span><br><span class="line">int w(int a,int b,int c)&#123;</span><br><span class="line">    if(a&lt;=0||b&lt;=0||c&lt;=0)&#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a&gt;20||b&gt;20||c&gt;20)&#123;</span><br><span class="line">        return w(20,20,20);</span><br><span class="line">    &#125;</span><br><span class="line">    if(A[a][b][c])  //if already in A no need to do recursion</span><br><span class="line">        return A[a][b][c];</span><br><span class="line">    if(a&lt;b&amp;&amp;b&lt;c)&#123;</span><br><span class="line">        A[a][b][c] =w(a,b,c-1)+w(a,b-1,c-1)-w(a,b-1,c); //A[a][b][c-1]+A[a][b-1][c-1]-A[a][b-1][c];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">        A[a][b][c] = w(a-1,b,c)+w(a-1,b-1,c)+w(a-1,b,c-1)-w(a-1,b-1,c-1);//A[a-1][b][c]+A[a-1][b-1][c]+A[a-1][b][c-1]-A[a-1][b-1][c-1];</span><br><span class="line">    return A[a][b][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    memset(A,0,sizeof(A));</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        int a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        if(a==-1&amp;&amp;b==-1&amp;&amp;c==-1)</span><br><span class="line">            break;</span><br><span class="line">        cout&lt;&lt;w(a,b,c)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dfs-solve-TSP"><a href="#dfs-solve-TSP" class="headerlink" title="dfs solve TSP"></a>dfs solve TSP</h3><p><a href="https://open.kattis.com/problems/beepers" target="_blank" rel="noopener">https://open.kattis.com/problems/beepers</a></p>
<p>dfs解TSP问题</p>
<p>基本思路是从出发点开始，尝试从出发点到其他所有点的可能性，然后回溯。</p>
<p>dfs的大概思路就是当n&lt;num的时候，尝试到不同的点，回溯，当n==num的时候，比较现在的路径长度是否小于最短路径。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">int shortest,num;</span><br><span class="line">int startx,starty;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int x;</span><br><span class="line">    int y;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;vec;</span><br><span class="line">int visited[MAX];</span><br><span class="line"></span><br><span class="line">int dis(int x1,int y1,int x2,int y2)&#123;</span><br><span class="line">    return abs(x1-x2)+abs(y1-y2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int cur,int len,int n)&#123;</span><br><span class="line"></span><br><span class="line">    if(n==num)&#123;</span><br><span class="line">        int t = dis(vec[cur].x,vec[cur].y,startx,starty);</span><br><span class="line">        if(len+t&lt;shortest)&#123;</span><br><span class="line">            shortest = len+t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else if(len&lt;shortest)&#123;</span><br><span class="line">        int i;</span><br><span class="line">        for(i=0;i&lt;num;i++)&#123;</span><br><span class="line">            if(visited[i]==0)&#123;</span><br><span class="line">                visited[i] = 1;</span><br><span class="line">                DFS(i,len+dis(vec[cur].x,vec[cur].y,vec[i].x,vec[i].y),n+1);</span><br><span class="line">                visited[i] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    ios::sync_with_stdio(false);</span><br><span class="line">    cin.tie(NULL); cout.tie(NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int sc;</span><br><span class="line">    int row,col;</span><br><span class="line">    cin&gt;&gt;sc;</span><br><span class="line">    while(sc--)&#123;</span><br><span class="line">        cin&gt;&gt;row&gt;&gt;col;</span><br><span class="line">        cin&gt;&gt;startx&gt;&gt;starty;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        vec.clear();</span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            int xx,yy;</span><br><span class="line">            cin&gt;&gt;xx&gt;&gt;yy;</span><br><span class="line">            vec.push_back(&#123;xx,yy&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        shortest = INF;</span><br><span class="line">        memset(visited,0,sizeof(visited));</span><br><span class="line"></span><br><span class="line">        for(int i=0;i&lt;num;i++)&#123;</span><br><span class="line">            int tempL = dis(vec[i].x,vec[i].y,startx,starty);</span><br><span class="line">            visited[i] = 1;</span><br><span class="line">            DFS(i,tempL,1);</span><br><span class="line">            visited[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;shortest&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode-931"><a href="#leetcode-931" class="headerlink" title="leetcode 931"></a>leetcode 931</h3><p>minimum falling path sum</p>
<p><img src="/home/alex/图片/minimum.png" alt="upload scessful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int minFallingPathSum(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123;</span><br><span class="line">    int res = INT_MAX;</span><br><span class="line">    int row = A.size();</span><br><span class="line">    int col = A[0].size();</span><br><span class="line">    int dp[row][col+2];</span><br><span class="line">   </span><br><span class="line">    for(int i=1;i&lt;row;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;col;j++)&#123;</span><br><span class="line">            if(j==0)&#123;</span><br><span class="line">                A[i][j] = A[i][j]+min(A[i-1][j],A[i-1][j+1]);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(j==col-1)&#123;</span><br><span class="line">                A[i][j] = A[i][j]+min(A[i-1][j],A[i-1][j-1]);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">               A[i][j] = A[i][j]+min(A[i-1][j],min(A[i-1][j-1],A[i-1][j+1]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(int i=0;i&lt;col;i++)&#123;</span><br><span class="line">        res = min(res,A[row-1][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度 n^2</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/07/程序的机器级表示与执行/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/程序的机器级表示与执行/" itemprop="url">CSAPP-异常控制流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T19:30:00+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CPU所执行的指令的地址序列称为CPU的控制流，通过下述两种方式得到的控制流为正常控制流。</p>
<p>1.按顺序取下一条指令执行。</p>
<p>2.通过CALL/RET/Jcc/JMP等指令跳转到转移目标地址处执行</p>
<h3 id="异常控制流"><a href="#异常控制流" class="headerlink" title="异常控制流"></a>异常控制流</h3><p><img src="/home/alex/图片/ctrlc.png" alt="upload sucessful"></p>
<p>硬件层面有两种情况：</p>
<p>1.执行指令的硬件发现指令有异常。eg:除0</p>
<p>2.外部中断 ctrl+c</p>
<p>异常控制流形成原因（1.2硬件层面）</p>
<p>1.内部异常：缺页，越权，越级，整除0，溢出等，都是CPU可以发现的。</p>
<p>2.外部中断（Ctrl-C，打印缺纸，DMA结束等）由外界请求信号通知CPU</p>
<p>3.进程的上下文切换（发生在操作系统层）</p>
<p>4.一个进程直接发送信号给另外一个进程（发生在应用软件层）</p>
<h3 id="程序和进程"><a href="#程序和进程" class="headerlink" title="程序和进程"></a>程序和进程</h3><p><img src="/home/alex/图片/程序和进程.png" alt="uplod successful"></p>
<p><img src="/home/alex/图片/PROCESS.png" alt="upload sucessful"></p>
<p><img src="/home/alex/图片/XITONG.png" alt="pload successful"></p>
<p>vm_area_struct  是一个线性链表</p>
<h4 id="引入进程的好处"><a href="#引入进程的好处" class="headerlink" title="引入进程的好处"></a>引入进程的好处</h4><p><img src="/home/alex/图片/2018-42.png" alt="ilename already exists, renamed"></p>
<p>独立的逻辑控制流意味着进程不会感觉到其他进程的存在，使得其不容易受其他进程打乱</p>
<h4 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h4><p><img src="/home/alex/图片/2018-43.png" alt="filename eady exists, renamed"></p>
<p> 进程p1，A12，打断一次</p>
<p> 进程p2，A24，打断一次</p>
<h4 id="进程与上下文切换"><a href="#进程与上下文切换" class="headerlink" title="进程与上下文切换"></a>进程与上下文切换</h4><p>什么叫进程的上下文？<br><img src="/home/alex/图片/chuliqi.png" alt="upload sucessful"></p>
<p><img src="/home/alex/图片/js.png" alt="upload succeul"></p>
<p><strong><em>用户级上下文地址空间和系统级上下文地址空间一起构成了一个进程的整个存储器映像</em></strong></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>以下内容引用<br><a href="https://wdxtub.com/2016/04/16/thin-csapp-5/" target="_blank" rel="noopener">https://wdxtub.com/2016/04/16/thin-csapp-5/</a></p>
<p>进程才是程序（指令和数据）的真正运行实例。之所以重要，是因为进程给每个应用提供了两个非常关键的抽象：一是逻辑控制流，二是私有地址空间。逻辑控制流通过称为上下文切换(context switching)的内核机制让每个程序都感觉自己在独占处理器。私有地址空间则是通过称为虚拟内存(virtual memory)的机制让每个程序都感觉自己在独占内存。这样的抽象使得具体的进程不需要操心处理器和内存的相关适宜，也保证了在不同情况下运行同样的程序能得到相同的结果。</p>
<p><img src="/home/alex/图片/2018-68.png" alt="filename already exists, ramed"></p>
<p>左边是单进程的模型，内存中保存着进程所需的各种信息，因为该进程独占 CPU，所以并不需要保存寄存器值。而在右边的单核多进程模型中，虚线部分可以认为是当前正在执行的进程，因为我们可能会切换到其他进程，所以内存中需要另一块区域来保存当前的寄存器值，以便下次执行的时候进行恢复（也就是所谓的上下文切换）。整个过程中，CPU 交替执行不同的进程，虚拟内存系统会负责管理地址空间，而没有执行的进程的寄存器值会被保存在内存中。切换到另一个进程的时候，会载入已保存的对应于将要执行的进程的寄存器值。</p>
<p>我们所讲的“双核”</p>
<p><img src="/home/alex/图片/double.png" alt="upload success"></p>
<p><img src="/home/alex/图片/进程.png" alt="upload successfu"></p>
<p>上下文切换是指把运行内核代码的环境调出来，然后把用户代码的环境（PC，寄存器等）保存起来</p>
<h4 id="进程地址空间"><a href="#进程地址空间" class="headerlink" title="进程地址空间"></a>进程地址空间</h4><p>虚拟地址空间由内核空间和用户空间两部分组成。用户空间（32位）都从0x08048000组成。<br><img src="/home/alex/图片/、、.png" alt="upload successfl"></p>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p>在遇到错误的时候，Linux 系统级函数通常会返回 -1 并且设置 errno 这个全局变量来表示错误的原因。使用的时候记住两个规则：</p>
<p>1.对于每个系统调用都应该检查返回值<br>2.当然有一些系统调用的返回值为 void，在这里就不适用</p>
<p>fork函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void unix_error(char *msg) /* Unix-style error */</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pid_t Fork(void)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    if ((pid = fork()) &lt; 0)</span><br><span class="line">        unix_error(&quot;Fork error&quot;);</span><br><span class="line">    return pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取进程信息"><a href="#获取进程信息" class="headerlink" title="获取进程信息"></a>获取进程信息</h4><p>我们可以用下面两个函数获取进程的相关信息：</p>
<p>1.pid_t getpid(void) - 返回当前进程的 PID<br>2.pid_t getppid(void) - 返回当前进程的父进程的 PID</p>
<p>我们可以认为，进程有三个主要状态：</p>
<p>1.运行 Running<br>        正在被执行、正在等待执行或者最终将会被执行<br>2.停止 Stopped<br>        执行被挂起，在进一步通知前不会计划执行<br>3.终止 Terminated<br>        进程被永久停止</p>
<h3 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h3><p><img src="/home/alex/图片/2018-44.png" alt="filename alredy exists, renamed"></p>
<h3 id="程序的加载和运行"><a href="#程序的加载和运行" class="headerlink" title="程序的加载和运行"></a>程序的加载和运行</h3><p><img src="/home/alex/图片/taipei.png" alt="upload succesful"></p>
<p><img src="/home/alex/图片/jiazai.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/2018-45.png" alt="filename alrdy exists, renamed"></p>
<p><img src="/home/alex/图片/ke.png" alt="upload succesul"></p>
<p>entry point 是可执行目标文件ELF头 的entry point</p>
<p>所以程序的加载和运行就是一个进程切换到另外一个进程，中间要进行上下文切换。切换新进程的时候先要创建一个进程（fork），然后exec，然后运行main</p>
<p><img src="/home/alex/图片/fork.png" alt="upload successful"></p>
<p>第一个参数先压栈，最后一个参数最后压栈，注意上图，argv是一个指针，指向一个数组，即图中argv【0】处，每一个元素又本身是一个指针，指向一个字符串，envp也是一个指针数组，每一个元素指向一个环境变量。</p>
<p>然后如果main函数调用了其它函数，就会又长出一个栈帧，这就是程序加载与运行的过程。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>可以用kill函数发射信号</p>
<p>子进程陷入无限循环，则父进程发射KILL信号，终结子进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void forkandkill()</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid[N];</span><br><span class="line">    int i;</span><br><span class="line">    int child_status;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">        if ((pid[i] = fork()) == 0)</span><br><span class="line">            while(1) ;  // 死循环</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Killing process %d\n&quot;, pid[i]);</span><br><span class="line">        kill(pid[i], SIGINT);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; N; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pid_t wpid = wait(&amp;child_status);</span><br><span class="line">        if (WIFEXITED(child_status))</span><br><span class="line"> printf(&quot;Child %d terminated with exit status  %d\n&quot;,wpid,WEXITSTATUS(child_status));</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;Child %d terminated abnormally\n&quot;, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>所有上下文切换都是通过调用某个异常处理器（exception handler）完成的，内核会计算对易于某个进程p的pnb值：pnb=pending&amp;~blocked</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void unix_error(char *msg) /* Unix-style error */</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, &quot;%s: %s\n&quot;, msg, strerror(errno));</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void sigint_handler(int sig) // SIGINT 处理器</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;想通过 ctrl+c 来关闭我？\n&quot;);</span><br><span class="line">    sleep(2);</span><br><span class="line">    fflush(stdout);</span><br><span class="line">    sleep(1);</span><br><span class="line">    printf(&quot;OK. :-)\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    // 设定 SIGINT 处理器</span><br><span class="line">    if (signal(SIGINT, sigint_handler) == SIG_ERR)</span><br><span class="line">        unix_error(&quot;signal error&quot;);</span><br><span class="line">        </span><br><span class="line">    // 等待接收信号</span><br><span class="line">    pause();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/maye.png" alt="upload succeful"></p>
<p>信号处理器的工作流程可以认为是和当前用户进程“并发”的同一个伪进程。</p>
<h4 id="并行与并发的区别"><a href="#并行与并发的区别" class="headerlink" title="并行与并发的区别"></a>并行与并发的区别</h4><p>并行：多个CPU同时执行程序</p>
<p>并发(concurrent)：即使只有一个CPU，但操作系统能够把程序的执行单位细化，然后分开执行。是一种伪并行执行</p>
<h4 id="阻塞信号"><a href="#阻塞信号" class="headerlink" title="阻塞信号"></a>阻塞信号</h4><p>内核会阻塞与当前在处理的信号同类型的其他正在等待的信号，也就是说一个SIGINT信号处理是不能被另外一个SIGINT信号中断的。</p>
<p>如果要显示阻塞，需要用sigprocmask函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sigset_t mask, prev_mask;</span><br><span class="line">Sigemptyset(&amp;mask); // 创建空集</span><br><span class="line">Sigaddset(&amp;mask, SIGINT); // 把 SIGINT 信号加入屏蔽列表中</span><br><span class="line">// 阻塞对应信号，并保存之前的集合作为备份</span><br><span class="line">Sigprocmask(SIG_BLOCK, &amp;mask, &amp;prev_mask);</span><br><span class="line">...</span><br><span class="line">... // 这部分代码不会被 SIGINT 中断</span><br><span class="line">...</span><br><span class="line">// 取消阻塞信号，恢复原来的状态</span><br><span class="line">Sigprocmask(SIG_SETMASK, &amp;prev_mask, NULL);</span><br></pre></td></tr></table></figure>
<p>并行访问可能会导致数据毁坏问题，以下是一些编写程序的规则。</p>
<pre><code>规则 1：信号处理器越简单越好
    例如：设置一个全局的标记，并返回
规则 2：信号处理器中只调用异步且信号安全(async-signal-safe)的函数
    诸如 printf, sprintf, malloc 和 exit 都是不安全的！
规则 3：在进入和退出的时候保存和恢复 errno
    这样信号处理器就不会覆盖原有的 errno 值
规则 4：临时阻塞所有的信号以保证对于共享数据结构的访问
    防止可能出现的数据损坏
规则 5：用 volatile 关键字声明全局变量
    这样编译器就不会把它们保存在寄存器中，保证一致性
规则 6：用 volatile sig_atomic_t 来声明全局标识符(flag)
    这样可以防止出现访问异常
</code></pre><p>异步信号安全：指的是如下两类函数：</p>
<p>1.所有的变量都保存在栈帧当中<br>2.不会被信号中断的函数</p>
<h3 id="非本地跳转-Non-local-jump"><a href="#非本地跳转-Non-local-jump" class="headerlink" title="非本地跳转 Non local jump"></a>非本地跳转 Non local jump</h3><p>从一个函数跳转到另一个函数中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setjmp 保存当前程序的堆栈上下文环境(stack context)，注意，这个保存的堆栈上下文环境仅在调用 setjmp 的函数内有效，如果调用 setjmp 的函数返回了，这个保存的堆栈上下文环境就失效了。调用 setjmp 的直接返回值为 0。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">longjmp 将会恢复由 setjmp 保存的程序堆栈上下文，即程序从调用 setjmp 处重新开始执行，不过此时的 setjmp 的返回值将是由 longjmp 指定的值。注意longjmp 不能指定0为返回值，即使指定了 0，longjmp 也会使 setjmp 返回 1。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf env;</span><br><span class="line">P1()</span><br><span class="line">&#123;</span><br><span class="line">    if (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">        // 跳转到这里</span><br><span class="line">    &#125; else </span><br><span class="line">    &#123;</span><br><span class="line">        P2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">P2()</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    P2();</span><br><span class="line">    ...</span><br><span class="line">    P3();</span><br><span class="line">&#125;</span><br><span class="line">P3()</span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/kundao.png" alt="uploadccessful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">jmp_buf env;</span><br><span class="line">P1()</span><br><span class="line">&#123;</span><br><span class="line">    P2(); P3();</span><br><span class="line">&#125;</span><br><span class="line">P2()</span><br><span class="line">&#123;</span><br><span class="line">    if (setjmp(env))</span><br><span class="line">    &#123;</span><br><span class="line">        // 跳转到这里</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">P3()</span><br><span class="line">&#123;</span><br><span class="line">    longjmp(env, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为P2在跳转的时候，已经在P3前返回了，内存已经清理了其对应的栈帧，所以P3的longjmp不能实现期望的操作。</p>
<h4 id="CSAPP-家庭作业"><a href="#CSAPP-家庭作业" class="headerlink" title="CSAPP 家庭作业"></a>CSAPP 家庭作业</h4><p>waitpid函数的作用：</p>
<p>当指定等待的子进程以及停止运行或者结束了，waitpid函数会立即返回，如果子进程还没有停止运行或者结束，调用waitpid的父进程会被祖塞，暂停运行</p>
<p>8.18<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void end()&#123;</span><br><span class="line">  </span><br><span class="line">      printf(&quot;2&quot;);fflush(stdout);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  int main()</span><br><span class="line">  &#123;</span><br><span class="line">     if(fork()==0)</span><br><span class="line">        atexit(end);</span><br><span class="line">     if(fork()==0)&#123;</span><br><span class="line">        printf(&quot;0&quot;);fflush(stdout);</span><br><span class="line">      &#125;</span><br><span class="line">     else&#123;</span><br><span class="line">        printf(&quot;1&quot;);fflush(stdout);</span><br><span class="line">     &#125;</span><br><span class="line">      exit(0);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个子进程的atexit函数把end函数添加到函数列表中，那么这个子进程生成的两个子进程的堆栈中也会有end函数，但是另外父进程则独立，不受影响，即使wxit也不会有反应。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/07/IA-32-linux中的地址转换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/IA-32-linux中的地址转换/" itemprop="url">CSAPP-IA-32/linux中的地址转换</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-07T15:28:00+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/home/alex/图片/2018-32.png" alt="filename alrady exists, renamed"></p>
<p><img src="/home/alex/图片/IA32.png" alt="upload succeful"></p>
<p>1.逻辑地址-》线性地址是 分段<br>2.线性地址-》内存地址是 分页</p>
<p>这里的8是偏移量A<br>%ebp是基址寄存器B，%esp是变址寄存器I，4是比例因子S</p>
<h3 id="分段过程"><a href="#分段过程" class="headerlink" title="分段过程"></a>分段过程</h3><p>线性地址的计算</p>
<p><img src="/home/alex/图片/duanxuanze.png" alt="upload sucsful"></p>
<p>段选择符是在上图的段寄存器里面的</p>
<p><img src="/home/alex/图片/dizhizhuanhuan.png" alt="upload success"></p>
<p>段选择符就相当于index位，分段方式中有一个”段表“（在主存），段表记录了段的长度，段开始的地方，存取权限等。</p>
<p>线性地址 = 段基址+有效地址</p>
<p>有效地址 = 基址寄存器+变址寄存器×比例因子</p>
<p>有效地址实际上是一个段内的偏移量，首地址+段内偏移量 = 线性地址。</p>
<p><img src="/home/alex/图片/duan.png" alt="upload succesful"></p>
<p>得到的线性地址再通过分页，通过页表转换为主存地址</p>
<h3 id="段寄存器的含义"><a href="#段寄存器的含义" class="headerlink" title="段寄存器的含义"></a>段寄存器的含义</h3><p><img src="/home/alex/图片/2018-33.png" alt="filename already exists, rend"></p>
<p>RPL： 最后两位表示管理状态（request privilege level）</p>
<p><img src="/home/alex/图片/2018-35.png" alt="filename alreadmed"></p>
<h3 id="段描述符和段描述符表"><a href="#段描述符和段描述符表" class="headerlink" title="段描述符和段描述符表"></a>段描述符和段描述符表</h3><p><img src="/home/alex/图片/2018-36.png" alt="filename already exists, renamed"></p>
<p>什么叫任务状态段？</p>
<p>这里的任务指的是进程，就是进程执行到某个阶段的时候，CS.SS.EIP，ESP，GPR内容等信息（代码算段，堆栈段，指令指针，栈指针，通用寄存器内容等）</p>
<p>中断门描述符记录了处理中断等异常处理的程序的首地址</p>
<p><img src="/home/alex/图片/logical.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/2018-37.png" alt="filename already enamed"></p>
<p>为了减少从主存中找段描述符，使用cache</p>
<p><img src="/home/alex/图片/cc.png" alt="upload succsful"></p>
<p><img src="/home/alex/图片/2018-38.png" alt="upload suessful"></p>
<p>TSS描述符在进行进程切换的时候，TR里面的内容也要进行切换。</p>
<p>所有表的起始地址是放在GDR，而所有异常中断程序的首地址放在IDT，IDT的首地址也放在IDTR里面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GDT和IDT只有一个，GDTR 和 IDTR指向各自起始的地方，根据TR取GDT中的TSS描述符的时候，GDTR给出首地址</span><br></pre></td></tr></table></figure>
<h4 id="Linux的全局段描述符表"><a href="#Linux的全局段描述符表" class="headerlink" title="Linux的全局段描述符表"></a>Linux的全局段描述符表</h4><p><img src="/home/alex/图片/GDT.png" alt="upload sucssful"></p>
<p>最后两位是RPL,都为0表示其在第0环，位于内核</p>
<p>倒数第三位表示这个描述符在GDT中，剩下的位便是索引号，<br>TSS索引是0x0010,即全局描述符表的第16项，LDT索引是0x0011，是第17项</p>
<p>因此在上上图中，操作系统会分别把0x80与0x88放在TR与LDTR中</p>
<h4 id="逻辑地址向线性地址转换"><a href="#逻辑地址向线性地址转换" class="headerlink" title="逻辑地址向线性地址转换"></a>逻辑地址向线性地址转换</h4><p><img src="/home/alex/图片/GDTR.png" alt="upload succesful"></p>
<p>逻辑地址（48位）=》 线性地址（32位）</p>
<p>16位的段选择符，根据TI选择去GDT还是去LDT，其中GDT，LDT的首地址分别存储在GDTR和LDTR里面，（不可见寄存器）</p>
<p><strong><em>段描述符 = 首地址+8×段选择符的索引</em></strong></p>
<p>所以得到的段基地址加上段偏移量，就得到32位线性地址</p>
<p>段描述符只有在第一次进行访问，访问过后就放在了cache里面，所以之后求线性地址，只需要在cache里面取基地址然后相加就行</p>
<p><img src="/home/alex/图片/risc.png" alt="upoad successful"></p>
<p>1.就是初始化时候上述4个段描述符放在GDT中<br>2.每个段都被初始化在0-4GB的线性地址空间中</p>
<p><img src="/home/alex/图片/ldtgdt.png" alt="uploauccessful"></p>
<p><img src="/home/alex/图片/2018-39.png" alt="filename already exists, reamed"></p>
<p>有效地址（偏移量） = 基址寄存器+变址寄存器×比例因子</p>
<p><img src="/home/alex/图片/2018-40.png" alt="filename alreay exists, renamed"></p>
<p>所以<strong><em>线性地址就等于EA = 有效地址 </em></strong></p>
<p>线性地址 = 基地址+有效地址</p>
<p>所谓EA其实只是一个segment内的一个段内偏移量</p>
<p><img src="/home/alex/图片/logic.png" alt="upload succeul"></p>
<p>指令的线性地址 = 代码段基地址+有效地址，而linux编译器默认了代码段基地址位0，因此指令的线性地址就等于有效地址就等于段的偏移量。</p>
<p>而数据的线性地址 = 数据段基地址+EA =0+ R[ECX]+R[EDX]*4</p>
<p>0X8048A00+(400)的16进制，注意进制的转换</p>
<h3 id="分页过程（线性地址-》物理地址）"><a href="#分页过程（线性地址-》物理地址）" class="headerlink" title="分页过程（线性地址-》物理地址）"></a>分页过程（线性地址-》物理地址）</h3><p>如果页大小为4KB，每个页表项占4B则理论上一个页表大小：</p>
<p>项个数：2^32/2^12 = 2^20 ，因此每个页表大小位4MB</p>
<p>比页还要大，因此采用多级页表方式来存储</p>
<p>—————————————————————————————————————————</p>
<p><img src="/home/alex/图片/2018-41.png" alt="filename already exists, red"></p>
<p>IA-32采用二级页表方式来存储</p>
<p><img src="/home/alex/图片/yedizhi.png" alt="upload sucssful"></p>
<p>每个页表起始位置按4KB对齐意思就是每个页表起始的20位都是相同的，只有后面的12位（4KB）不同</p>
<p><img src="/home/alex/图片/mmu.png" alt="upload"></p>
<p><img src="/home/alex/图片/imge.png" alt="upload succeul"></p>
<p>MMU 完成从逻辑地址到线性地址的过程</p>
<h3 id="CPL-RPL-DPL区别与联系"><a href="#CPL-RPL-DPL区别与联系" class="headerlink" title="CPL,RPL,DPL区别与联系"></a>CPL,RPL,DPL区别与联系</h3><p>1.CPL是当前进程的权限级别(Current Privilege Level)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。
　　</p>
<p>2.RPL说明的是进程对段访问的请求权限(Request Privilege Level)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。
　　　　</p>
<p>3.DPL存储在段描述符中，规定访问该段的权限级别(Descriptor Privilege Level)，每个段的DPL固定。<br>当进程访问一个段时，需要进程特权级检查，一般要求DPL &gt;= max {CPL, RPL}</p>
<p>下面打一个比方，中国官员分为6级国家主席1、总理2、省长3、市长4、县长5、乡长6，假设我是当前进程，级别总理（CPL=2）,我去聊城市(DPL=4)考察(呵呵),我用省长的级别(RPL=3 这样也能吓死他们:-))去访问,可以吧，如果我用县长的级别，人家就不理咱了(你看看电视上的微服私访，呵呵)，明白了吧！为什么采用RPL，是考虑到安全的问题，就好像你明明对一个文件用有写权限，为什么用只读打开它呢，还不是为了安全！</p>
<p>ref：<a href="https://blog.csdn.net/better0332/article/details/3416749" target="_blank" rel="noopener">https://blog.csdn.net/better0332/article/details/3416749</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/06/CSAPP-Virtural-Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/CSAPP-Virtural-Memory/" itemprop="url">CSAPP-Virtural Memory</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T20:12:21+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>为每个进程提供了一个大的，一致的和私有的地址空间。</p>
<p>1.把主存看成是一个存储在磁盘上的地址空间的高速缓存</p>
<p>2.为每个进程提供了一致的地址空间，简化了内存管理</p>
<p>3.保护每个进程的地址空间不被其他进程破坏</p>
<h3 id="早期分页方式的概念"><a href="#早期分页方式的概念" class="headerlink" title="早期分页方式的概念"></a>早期分页方式的概念</h3><p>大白话：程序是在逻辑空间上写的，而是在物理空间上运行，所以要解决逻辑空间与物理空间之间的映射。</p>
<p><img src="/home/alex/图片/page.png" alt="upload successf"></p>
<p>就是程序可能会有2^16byte长，但是物理容量只有4K</p>
<p><img src="/home/alex/图片/2018-26.png" alt="filename alrady exists, renamed"></p>
<p>这个区号意思就是说，地址空间0-4095对应page 1，4096-8192对应page2</p>
<p><strong><em>区间就是页(page)，主存中存放页的区域成为页框</em></strong></p>
<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p><img src="/home/alex/图片/paging.png" alt="upload succesul"></p>
<p><img src="/home/alex/图片/dazi.png" alt="upad successful"></p>
<p>逻辑地址 1：30  1作为地址空间索引号（页号），30作为内容</p>
<p>14代表页框号 </p>
<p>所以页表就是用来映射页号和物理地址中的页框号</p>
<p><img src="/home/alex/图片/durian.png" alt="upload successl"></p>
<p>页框之间内容可以离散，页框内部内容连续</p>
<h3 id="虚拟存储系统"><a href="#虚拟存储系统" class="headerlink" title="虚拟存储系统"></a>虚拟存储系统</h3><p>大白话：程序可能很长，但是主存容量有限，于是把活跃的程序段放到主存中运行，然后自动进行切换</p>
<p>实质：</p>
<p>1.程序员在比实际主存空间大得多的逻辑地址空间中编写程序</p>
<p>2.程序执行的时候，要把当前需要的程序段以及相应的数据块调入主存当中，不用的部分放在磁盘上</p>
<h4 id="虚拟存储技术的实质"><a href="#虚拟存储技术的实质" class="headerlink" title="虚拟存储技术的实质"></a>虚拟存储技术的实质</h4><p>进程调入物理主存的空间（程序中活跃的片段占用了主存的物理空间）</p>
<p><img src="/home/alex/图片/xuange.png" alt="upload successl"></p>
<p>每个程序会有一个页表来说明它这一页的情况<br>（在磁盘上/内存上/空页）</p>
<p><img src="/home/alex/图片/vmm.png" alt="upload successl"></p>
<p>cpu拿到的是虚拟地址，要求转化为主存地址，而这个过程是在执行指令的时候完成的，只能通过硬件来完成</p>
<p><img src="/home/alex/图片/2018-27.png" alt="filename already exists, med"></p>
<p>加载一个可执行文件，执行的时候，不会实际上把数据都加载到内存当中，而是生成该程序对应的一个页表。然后按照按需调页原则，通过pageFault异常来实现，把数据装入到内存当中。</p>
<h4 id="主存–磁盘"><a href="#主存–磁盘" class="headerlink" title="主存–磁盘"></a>主存–磁盘</h4><p><img src="/home/alex/图片/images.png" alt="upload successl"></p>
<p>因为访问磁盘的时间会比较长，因此要尽可能减少磁盘的次数</p>
<p>write back 只写主存，不写磁盘</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>用结构数组来实现</p>
<p><img src="/home/alex/图片/vlid.png" alt="upload successfu"></p>
<p>装入位-&gt;valid bit</p>
<p>修改位-&gt;dirty bit</p>
<p>替换控制位-&gt;根据其使用情况，决定该page是淘汰掉还是保留<br>eg（LRU.LMU）</p>
<p>实页号-&gt;页框号</p>
<p><strong>每个进程有一个页表，其中有装入位，dirty位，替换控制位，访问权限位（确定是否可读/可写）还有禁止缓存位，实页号</strong></p>
<p>一个页数的项数有什么来决定？<strong>虚拟地址空间大小来决定</strong></p>
<p>项数 = 虚拟地址空间大小 / 页大小</p>
<p>4GB/4KB = 2^20 项</p>
<p>每个进程的页表大小一样吗？</p>
<p><strong><em>各个进程有相同虚拟空间，所以理论上一样。实际大小看具体实现方式，如“空洞：页面如何处理</em></strong></p>
<p><img src="/home/alex/图片/2018-28.png" alt="fil"></p>
<p>页表分三种</p>
<p><img src="/home/alex/图片/ju.png" alt="upload successl"></p>
<h4 id="逻辑地址转换为物理地址"><a href="#逻辑地址转换为物理地址" class="headerlink" title="逻辑地址转换为物理地址"></a>逻辑地址转换为物理地址</h4><p><img src="/home/alex/图片/VA.png" alt="upload success"></p>
<p>VA：VIRTUAL ADDRESS</p>
<p>类比于全相连cache，地址只有两部分，高位的tag，低位的偏移量。这里也是类似，page no,表示页表索引，页表基址存放在一个寄存器当中，<strong><em>页表的地址 = 基址+页表索引×页框大小</em></strong> </p>
<p>PF： frame no. ，即物理页号，其加上disp偏移量就等于PA，物理地址。</p>
<p>V = 0时，发生缺页。</p>
<h4 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h4><p>这个时候就需要操作系统来帮忙处理</p>
<p><img src="/home/alex/图片/vm2.png" alt="upload success"></p>
<h4 id="TLB（快表）"><a href="#TLB（快表）" class="headerlink" title="TLB（快表）"></a>TLB（快表）</h4><p><img src="/home/alex/图片/um.png" alt="upload sssful"></p>
<p>全相连中，tag = 标签号，没有组号</p>
<p>组相连当中，虚页号高位作为tag，低位作为组号（index）</p>
<p><img src="/home/alex/图片/TLB.png" alt="upload succe"></p>
<p>1.从virtual page中得到虚页号，把虚页号与TLB中的tag作比较，如果valid=0 or valid = 1 but tag!=VA,then 发生缺页。</p>
<p>2.于是从主存的页表(慢表)开始寻找，由于页表中的表项是按照索引号排列的，所以并不需要tag号。如果V=0，还找不到，则时候就要到外存当中的磁盘找对应的表项。</p>
<p>3.如果找到了，可以直接从page frame中生成物理地址号，这样就不需要访问向前面部分介绍的那样，访问主存。</p>
<p><strong><em>所以引入快表（在cache）目的就是减少主存的访问次数，提高逻辑地址与物理地址转换的速度。</em></strong></p>
<p><img src="/home/alex/图片/cmt.png" alt="upload successfl"></p>
<p>最理想路径： VA-&gt;HIT1-&gt;HIT3-&gt;CPU 不用访问主存</p>
<p>如果发生了TLB缺失（miss1），在主存中的的页表中寻找，如果找到了就是hit2，继续送到cache里面，否则就是miss 2 ，发生page fault</p>
<p>如果送到cache，cache miss了，就发生miss 3，从主存那里找。</p>
<h5 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h5><p><img src="/home/alex/图片/2018-30.png" alt="filename already exists, renaed"></p>
<p>最上面那一段属于页表，中间段属于TLB，下面那一段是cache</p>
<p>大概过程：虚拟地址从TLB表中寻找，如果找不到就去页表找，然后映射为物理地址后，物理地址在cache中找，找不到就访问主存，从主存中找。</p>
<p>虚拟地址分为20位的虚拟页号，12位的页内地址</p>
<p>上图中由于是组相连，因此虚拟页号分为tag标记以及组索引，当v=1而且TLB标记等于标记号的时候，就找到了物理页号，然后物理页号与虚拟地址的业内地址结合起来，就找到了物理地址。然后物理地址就又分为标记号，组索引以及块内地址，于cache中寻找所要寻找的字节。</p>
<p><img src="/home/alex/图片/ca.png" alt="upload successl"></p>
<p>缺页处理是由操作系统来作的</p>
<p><img src="/home/alex/图片/HMM.png" alt="upload ful"></p>
<p>如果不在页表当中，就绝对不可能再快表当中；如果页表缺失，说明信息不在主存，cache也一定不可能有！</p>
<p>三个都miss过程：</p>
<p>1.快表miss，去页表（在主存）中找，访存1次</p>
<p>2.页表miss，只能从磁盘中寻找，访问磁盘一次</p>
<p>3.cache miss，从主存当中寻找，访存第二次</p>
<h4 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h4><p><img src="/home/alex/图片/lee.png" alt="upload succesul"></p>
<p>页表项数： 虚拟地址大小 / 页大小</p>
<p><img src="/home/alex/图片/phy.png" alt="upload succesl"></p>
<p>虚拟地址中，高8位就是虚拟页号，低6位就是偏移量。</p>
<p>物理地址中，高6位是实页号，低6号是偏移量。</p>
<p>快表：</p>
<p><img src="/home/alex/图片/bufen.png" alt="upload successl"></p>
<p>16个TLB项，4路组相连，说明TLBI是2，剩下6位就是tag位</p>
<p>快表中0A34数据有误，因为其VPN就是tag+set号</p>
<p> tag是0A,set是03，所以VPN为 00101011 就是0x2B</p>
<p>但是在慢表中，0x2Bvalid位是0，所以说明数据有误</p>
<p>cache：</p>
<p><img src="/home/alex/图片/china.png" alt="upload succesful"></p>
<p>一共有16行，所以CI是4，偏移量是2（主存块4B）</p>
<p><img src="/home/alex/图片/jizz.png" alt="upload succesul"></p>
<p>VPN = 0xF TLBI = 0x3 TLBT = 0x3</p>
<p>即在快表的第三组中找tag==3的，找到了，说明其命中，没有page fault，PPN是0D</p>
<p>0D = 1101</p>
<p>所以物理地址为（PPN+VPO）<br>001101010100</p>
<p>C0 = 00<br>CI = 0101<br>CT = 001101</p>
<p>在cache中找第5行，tag为001101的16位数据</p>
<p>B0 = 36 B1 = 72</p>
<p>所以要找的数据是7236(小端，高位数据在高位)</p>
<h4 id="分段式虚拟存储器"><a href="#分段式虚拟存储器" class="headerlink" title="分段式虚拟存储器"></a>分段式虚拟存储器</h4><p>分段方式很好管理，但是占的空间多，储存空间管理不好管理。</p>
<p><img src="/home/alex/图片/fenduan.png" alt="oad successful"></p>
<p><img src="/home/alex/图片/2018-31.png" alt="file already exists, renamed"></p>
<h4 id="段页式存储器"><a href="#段页式存储器" class="headerlink" title="段页式存储器"></a>段页式存储器</h4><p><img src="/home/alex/图片/ta.png" alt="upload succful"></p>
<h5 id="练习题9-5"><a href="#练习题9-5" class="headerlink" title="练习题9.5"></a>练习题9.5</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">char *bufp</span><br><span class="line"></span><br><span class="line">//fd 为open函数返回的文件描述符</span><br><span class="line">void *mmap(void *start,size_t length,int prot,int flags,int fd,off_t offset)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//创建一个包含size字节的只读，私有，请求二进制0的虚拟内存区域，如果调用成功，bufp则为新区域的地址</span><br><span class="line">bufp = Mmap(NULL,size,PROT_READ,MAP_PRIVATE|MAP_ANON,0,0);</span><br></pre></td></tr></table></figure>
<p>用以上函数，讲一个任意大小的磁盘文件复制到stdout，文件名作为一个命令行参数传递。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;csapp.h&gt;</span><br><span class="line"></span><br><span class="line">void mmapcopy(int fd,int size)&#123;</span><br><span class="line">    char *bufp;</span><br><span class="line">    bufp = Mmap(NULL,size,PROT_READ,MAP_PRIVATE,fd,0);</span><br><span class="line">    Write(1,bufp,size);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line">    if(argc!=2)&#123;</span><br><span class="line">        printf(&quot;usage: %s &lt;filename&gt;\n&quot;,argv[0]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int fd;</span><br><span class="line">    struct stat stat;</span><br><span class="line">    fd = Open(argv[0],O_RDONLY,0);</span><br><span class="line">    fstat(fd,&amp;stat);</span><br><span class="line">    mmapcopy(fd,stat.st_size);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//文件描述符的用法<br>//<a href="https://blog.csdn.net/u012736748/article/details/74626145" target="_blank" rel="noopener">https://blog.csdn.net/u012736748/article/details/74626145</a></p>
<p>文件描述符是一个索引，指向内核为每一个进程所维护的该进程打开文件的记录表。</p>
<h4 id="删除虚拟地址"><a href="#删除虚拟地址" class="headerlink" title="删除虚拟地址"></a>删除虚拟地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int mummap（void *start,size_t length）;</span><br></pre></td></tr></table></figure>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><h4 id="usage-of-malloc-package"><a href="#usage-of-malloc-package" class="headerlink" title="usage of malloc package"></a>usage of malloc package</h4><p><img src="/home/alex/图片/mallocz.png" alt="upload scessful"></p>
<p><img src="/home/alex/图片/2018-71.png" alt="fildy existsenamed"></p>
<p>可以通过诸如malloc,new等方法让程序运行的时候得到虚拟内存。动态内存分配器会管理一个虚拟内存区域，叫做堆。</p>
<p>分配器以块为单位来维护堆，可以进行分配或者释放。有两种类型：</p>
<pre><code>1.显式分配器：应用分配并且回收空间（malloc &amp; free）
2.隐式分配器，只负责分配，但是不负责回收（JAVA中的垃圾收集）
</code></pre><p>过程如下：</p>
<p><img src="/home/alex/图片/malloc.png" alt="upload "></p>
<p><img src="/home/alex/图片/gg.png" alt="upload"></p>
<h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>假设给定一个malloc和free的请求的序列目标是尽可能提高吞吐量和内存利用率。</p>
<p>吞吐量： 单位时间内完成的请求数量。</p>
<p>内存利用率：主要影响因素是内存碎片。</p>
<h5 id="内部碎片"><a href="#内部碎片" class="headerlink" title="内部碎片"></a>内部碎片</h5><p><img src="/home/alex/图片/内存碎片.png" alt="upld successful"></p>
<h5 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h5><p><img src="/home/alex/图片/外部.png" alt="upload ssful"></p>
<h4 id="Peak-Memory-Utilization"><a href="#Peak-Memory-Utilization" class="headerlink" title="Peak Memory Utilization"></a>Peak Memory Utilization</h4><p><img src="/home/alex/图片/per.png" alt="upload susful"></p>
<h4 id="implementation"><a href="#implementation" class="headerlink" title="implementation"></a>implementation</h4><h5 id="how-to-free"><a href="#how-to-free" class="headerlink" title="how to free"></a>how to free</h5><p><img src="/home/alex/图片/implementation.png" alt="upload successf"></p>
<p>pointer 前面用一个word记录block size</p>
<p>free的时候，访问指针前一个word就可以知道blocksize了</p>
<h5 id="keeping-track-of-free-blocks"><a href="#keeping-track-of-free-blocks" class="headerlink" title="keeping track of free blocks"></a>keeping track of free blocks</h5><p><img src="/home/alex/图片/how.png" alt="uploadsuccessful"></p>
<h5 id="implicit-free-lists"><a href="#implicit-free-lists" class="headerlink" title="implicit free lists"></a>implicit free lists</h5><p><img src="/home/alex/图片/2018-72.png" alt="filename alredy exists, renamed"></p>
<p>因为每一个block是8-byte alignment的，因此最后3位必定都是0，所以可以利用最后一位来存储该块是否已经分配</p>
<h5 id="example"><a href="#example" class="headerlink" title="example"></a>example</h5><p><img src="/home/alex/图片/2018-73.png" alt="filenamey exists, renamed"></p>
<h5 id="Finding-a-free-block"><a href="#Finding-a-free-block" class="headerlink" title="Finding a free block"></a>Finding a free block</h5><p><img src="/home/alex/图片/2018-74.png" alt="filename already exists, renamd"></p>
<p>这里的 <em>p &amp; -2 -&gt;  </em>p &amp; 1111111…110 即得到block的size ，i.e mask out the last bit</p>
<h5 id="allocating-in-free-block"><a href="#allocating-in-free-block" class="headerlink" title="allocating in free block"></a>allocating in free block</h5><p><img src="/home/alex/图片/alloc.png" alt="upload succesul"></p>
<h5 id="freeing-a-block"><a href="#freeing-a-block" class="headerlink" title="freeing a block"></a>freeing a block</h5><p><img src="/home/alex/图片/freeing.png" alt="upload cessful"></p>
<h5 id="Coalescing"><a href="#Coalescing" class="headerlink" title="Coalescing"></a>Coalescing</h5><p><img src="/home/alex/图片/coalescing.png" alt="upload succsful"></p>
<p>next pointer points to where 2 stores</p>
<p>如果2开头的block是空的，那么 <em>p = </em>p +*next</p>
<p>意思就是说4 = 4+2 = 6</p>
<h5 id="Explicit-Free-Lists"><a href="#Explicit-Free-Lists" class="headerlink" title="Explicit Free Lists"></a>Explicit Free Lists</h5><p><img src="/home/alex/图片/VM.png" alt="upload succeful"></p>
<h3 id="一些区别"><a href="#一些区别" class="headerlink" title="一些区别"></a>一些区别</h3><p>explicit empty list &amp; implicit empty list</p>
<p>隐式的话，分配时间是块总数线性时间，而显式的话，是空闲块数量的线性时间，一般来说显式会比隐式更快。</p>
<p>first fit &amp;&amp; next fit &amp;&amp; best fit</p>
<p>首次适配：从头开始搜索空闲链表，选择第一个合适的空闲块。</p>
<p>下一次适配：从上一次搜索结束的位置开始搜索。</p>
<p>最佳适配：检索每一个空闲块，选择适合需求的最小空闲块。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/06/Stack-Pointer-Frame-Pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/06/Stack-Pointer-Frame-Pointer/" itemprop="url">Stack Pointer/Frame Pointer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-06T14:16:08+08:00">
                2018-12-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Stack-Frame"><a href="#Stack-Frame" class="headerlink" title="Stack Frame"></a>Stack Frame</h3><p><img src="/home/alex/图片/2018-18.png" alt="fil"></p>
<p>firstly, callee stack save the old caller ‘s stack ‘s ebp</p>
<p>lastly, the argument build means the arguments for calling any other function </p>
<p><img src="/home/alex/图片/2.png" alt="upload successfl"></p>
<p>pushl $zip2,$zip1 把参数压进栈顶，然后call swap，会把caller的return address压入栈</p>
<h3 id="whole-code"><a href="#whole-code" class="headerlink" title="whole code"></a>whole code</h3><p><img src="/home/alex/图片/whole.png" alt="upload succesful"></p>
<h4 id="set-up-code"><a href="#set-up-code" class="headerlink" title="set up code"></a>set up code</h4><p><img src="/home/alex/图片/2018-19.png" alt="filename already exists, amed"></p>
<p>一. push %ebp 把caller的 bast pointer 的数值压栈</p>
<p>二.movl %esp,%ebp （把esp 移动到ebp，即设置ebp = esp，这一步是设置callee的base pointer）</p>
<p>三.%ebx 是swap过程中可能会调用的参数</p>
<p><a href="https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq78292959/archive/2012/07/20/2600865.html</a></p>
<p>附上：EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。</p>
<p>EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。</p>
<p>ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</p>
<p>EDX 则总是被用来放整数除法产生的余数。</p>
<p>但是对于　%eax,%ecx,%edx　不能像ｅｂｘ一样，保存在callee中</p>
<h4 id="body-code"><a href="#body-code" class="headerlink" title="body code"></a>body code</h4><p><img src="/home/alex/图片/ebp.png" alt="upload successfl"></p>
<h4 id="finish-code"><a href="#finish-code" class="headerlink" title="finish code"></a>finish code</h4><p><img src="/home/alex/图片/sp.png" alt="upload sucu"></p>
<ol>
<li>%ebp-4 就是 old %ebx 的地址 ，把-4（%ebp）移到%ebx，相当于把原来的%ebx复原</li>
</ol>
<p>2.第二是 把 %ebp 移到 %esp，即现在%esp指向%ebp</p>
<p>(第一第二条指令相当于 pop %ebx)<br><img src="/home/alex/图片/d.png" alt="upload successf"></p>
<p>3.popl %ebp<br>本质上是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0(%esp),%ebp </span><br><span class="line">%esp +4</span><br></pre></td></tr></table></figure></p>
<p>这个时候base pointer复原，变回caller stack　的数值</p>
<p>４.ret 根据返回地址返回</p>
<p>其中leave instruction<br>等价于<br>mov ％ebp,%esp</p>
<p>popl %ebp</p>
<h3 id="register-saving-convention"><a href="#register-saving-convention" class="headerlink" title="register saving convention"></a>register saving convention</h3><p><img src="/home/alex/图片/tong.png" alt="upload succesul"></p>
<p>yoo当中，我们希望%edx不会因为调用了who函数之后发生改变，问题是，who调用过程中，%edx是可能发生改变的。</p>
<p>因此我们要制定convention，在使用这些寄存器之前先保存他们！</p>
<p><img src="/home/alex/图片/2018-20.png" alt="filename already exists, rnamed"></p>
<p>分类如下<br><img src="/home/alex/图片/2018-21.png" alt="fileame already exists, renamed"></p>
<p>%eax save the return address so it is caller saved register</p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p><img src="/home/alex/图片/2018-22.png" alt="filename already exis, renamed"></p>
<p><img src="/home/alex/图片/you.png" alt="upload successf"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.pushl %ebp #save the caller&apos;s ebp</span><br><span class="line"></span><br><span class="line">2.movl %esp,%ebp  #set callee&apos;s ebp</span><br><span class="line"></span><br><span class="line">3.subl $16,%esp   # add 16 bytes, add temporary space</span><br><span class="line"></span><br><span class="line">4.movl 8(%ebp),%edx  # set edx = x</span><br><span class="line"></span><br><span class="line">5.movl $1,-4(%ebp)</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/2018-23.png" alt="filename already eists, renamed"></p>
<p>两个pushl 相当于把 s_helper函数的两个参数传了进去</p>
<p>&amp;val始终指向val，当函数结束的时候，返回的值就保存在了-4(%ebp)当中</p>
<p><img src="/home/alex/图片/st.png" alt="upload sucessful"></p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>1.若调用函数有多个参数，stack从下到上，依次为第一个，第二个函数。</p>
<p>2.函数调用的参数在stack的上方，就是在caller准备好参数后再调用callee,就是说argument 是caller saved 的</p>
<p>3.函数结果返回在%eax</p>
<p>4.local variable 是存放在 callee-saved registers那里</p>
<h3 id="x86-64-conventions"><a href="#x86-64-conventions" class="headerlink" title="x86-64 conventions"></a>x86-64 conventions</h3><p>在x86 中，由于registers 的数目变多，因此可以把local variable 和argument存储在register当中，那样就可以减少对stack 的使用了</p>
<p>下图是16个 8-byte gpr<br><img src="/home/alex/图片/2018-24.png" alt="filename exists, rena"></p>
<p>黄色的是caller saved</p>
<p>绿色的是 callee saved</p>
<h4 id="specifications"><a href="#specifications" class="headerlink" title="specifications"></a>specifications</h4><p><img src="/home/alex/图片/dij.png" alt="up"></p>
<p>1.用callq 而不用call，因为要返回一个64-bit address,also decrement 8而不是4（8 bytes）</p>
<p>2.因为gpr实现了ebp / rbp 功能，因此不需要使用stack来更新 ，而且rsp能代替实现frame pointer 的功能</p>
<p>3.由于gpr只有6个argument register，所以当函数参数少于六个的时候，不需要用到栈结构</p>
<h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><p><img src="/home/alex/图片/y.png" alt="upload successfu"></p>
<p>q - 8byte - 64bits</p>
<p>l - 4byte - 32bits</p>
<p>w - 2byte - 16bits</p>
<p>b - 1byte - 8bits</p>
<p><img src="/home/alex/图片/2018-25.png" alt="filename already exists, rena"></p>
<h4 id="prepare-for-the-arguments"><a href="#prepare-for-the-arguments" class="headerlink" title="prepare for the arguments"></a>prepare for the arguments</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">movq $1,%rdi</span><br><span class="line">leaq 16(%rsp),%rsi</span><br><span class="line">movl $2,%rdx</span><br><span class="line">leaq 24(%rsp),%rcx</span><br><span class="line">movl $3,%r8</span><br><span class="line">leaq 28(%rsp),%r9</span><br><span class="line">movl $4,(%rsp)     #Arg 7</span><br><span class="line">leaq 31(%rsp),%rax</span><br><span class="line">movq %rax,8(%rsp)  #Arg 8</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/cltq.png" alt="upload succesul"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movswl 28(%rsp),%eax # %eax = x3</span><br><span class="line"></span><br><span class="line">movsbl 31(%rsp),%edx # %edx = x4</span><br><span class="line"></span><br><span class="line">s 表示 signextend</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/11/14/CSAPP-MIPS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/CSAPP-MIPS/" itemprop="url">CSAPP-MIPS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-14T21:00:00+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="Registers-寄存器"><a href="#Registers-寄存器" class="headerlink" title="Registers 寄存器"></a>Registers 寄存器</h5><hr>
<p>1.一共有32个general register</p>
<p>2.有两种使用方法: 直接使用对应的编号或者是对应的寄存器名称</p>
<table>
<thead>
<tr>
<th>寄存器编号</th>
<th>寄存器名称</th>
<th>寄存器用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>zero</td>
<td>return 0</td>
</tr>
<tr>
<td>1</td>
<td>$at</td>
<td>汇编保留寄存器</td>
</tr>
<tr>
<td>2-3</td>
<td>$v0-$v1</td>
<td>（value）存储表达式或者是函数的返回值</td>
</tr>
<tr>
<td>4-7</td>
<td>$a0-$a3</td>
<td>(Argument) 存储子程序前四个参数，调用时不保存</td>
</tr>
<tr>
<td>8-15</td>
<td>$t0-$t7</td>
<td>临时变量，调用时不保存，调用完成后要恢复</td>
</tr>
<tr>
<td>16-23</td>
<td>$s0-$s7</td>
<td>函数调用的时候必须保存，调用完成后需要恢复</td>
</tr>
<tr>
<td>24-25</td>
<td>$t8-$t9</td>
<td>属性和$t0-$t7一致</td>
</tr>
<tr>
<td>26-27</td>
<td>$k0-$k1</td>
<td>（kernel）中断函数返回值</td>
</tr>
<tr>
<td>28</td>
<td>$gp</td>
<td>global pointer 指向64K大小的静态数据块的中间地址</td>
</tr>
<tr>
<td>29</td>
<td>$sp</td>
<td>stack pointer</td>
</tr>
<tr>
<td>30</td>
<td>$fp/$s8</td>
<td>frame pointer</td>
</tr>
<tr>
<td>31</td>
<td>$ra</td>
<td>return address</td>
</tr>
</tbody>
</table>
<hr>
<h5 id="Program-Structure-程序结构"><a href="#Program-Structure-程序结构" class="headerlink" title="Program Structure 程序结构"></a>Program Structure 程序结构</h5><hr>
<p>本质其实就只是数据声明+普通文本+程序编码（文件后缀为.s，或者.asm也行） 数据声明在代码段之后（其实在其之前也没啥问题，也更符合高级程序设计的习惯）<br>Data Declarations 数据声明</p>
<pre><code>数据段以 .data为开始标志
声明变量后，即在主存中分配空间。
</code></pre><p>Code 代码</p>
<pre><code>代码段以 .text为开始标志
其实就是各项指令操作
程序入口为main：标志
程序结束标志（详见下文）
</code></pre><h6 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">		.data  # 数据变量声明</span><br><span class="line">		</span><br><span class="line">        .text  #代码段</span><br><span class="line">        </span><br><span class="line">main:   主函数入口</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="数据声明"><a href="#数据声明" class="headerlink" title="数据声明"></a>数据声明</h5><p>example</p>
<p>var1:   &emsp;  .word 3     </p>
<p>array:  &emsp;  .byte ‘a’,’b’  # 声明一个存储两个字符的数组array1，并赋值’a’,’b’</p>
<p>array1:  &emsp;  .space 40    #为变量array2 分配40个未使用的连续空间</p>
<hr>
<h6 id="其他指令汇总"><a href="#其他指令汇总" class="headerlink" title="其他指令汇总"></a>其他指令汇总</h6><hr>
<p><a href="https://blog.csdn.net/king523103/article/details/45967991" target="_blank" rel="noopener">MIPS入门</a></p>
<h5 id="实战-冒泡排序"><a href="#实战-冒泡排序" class="headerlink" title="实战-冒泡排序"></a>实战-冒泡排序</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">array: .space 1024</span><br><span class="line">input_msg: .asciiz &quot;Enter the number of integers:\n&quot;</span><br><span class="line">input_int_msg: .asciiz &quot;Enter integers to be sorted\n&quot;</span><br><span class="line">output_msg: .asciiz &quot;the sorted numbers are\n&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.globl main</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">	la $a0,input_msg</span><br><span class="line">	li $v0,4</span><br><span class="line">	syscall</span><br><span class="line">	 </span><br><span class="line">	li $v0,5  #接受用户输入的数组长度</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	la $t6,array #数组首地址</span><br><span class="line">	move $t7,$zero #循环变量i</span><br><span class="line">	move $t8,$zero #循环变量j</span><br><span class="line">	move $t9,$v0  #数组长度</span><br><span class="line"></span><br><span class="line">	addi $t3,$zero,1</span><br><span class="line">	beq $v0,$t3,special</span><br><span class="line">			</span><br><span class="line">input:</span><br><span class="line"></span><br><span class="line">	la $a0,input_int_msg</span><br><span class="line">	li $v0,4</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	li $v0,5  </span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	#for(int i=0;i&lt;num;i++)</span><br><span class="line">        #cin&gt;&gt;arr[i];</span><br><span class="line">        </span><br><span class="line">        move $t0,$t7 #$t0 is i</span><br><span class="line">        sll $t0,$t0,2 #i become byte offset</span><br><span class="line">        move $t1,$t6 #$t1 is &amp;array[0]</span><br><span class="line">        add $t1,$t1,$t0 #$t1 is &amp;array[i]</span><br><span class="line">        sw $v0,0($t1) #cin&gt;&gt;array[i]</span><br><span class="line">	</span><br><span class="line">	addi $t7,$t7,1</span><br><span class="line">	blt $t7,$t9,input #if ++i&lt;length</span><br><span class="line"> </span><br><span class="line">	move $t7,$zero</span><br><span class="line">	</span><br><span class="line">loop1:	# 每次外层循环比内层循环的循环变量设为0</span><br><span class="line">	move $t8,$zero</span><br><span class="line">loop2:</span><br><span class="line">	#read arr[j+1] and arr[j]</span><br><span class="line">	</span><br><span class="line">	move $t2,$t8 #t2 is j</span><br><span class="line">	sll $t2,$t2,2 #j=*4;</span><br><span class="line">	addu $t1,$t2,$t6 #&amp;arr[j]</span><br><span class="line">	lw $t4,0($t1)  #arr[j]</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	addi $t2,$t8,1 #j+1</span><br><span class="line">	sll $t2,$t2,2 #(j+1)*4</span><br><span class="line">	addu $t0,$t2,$t6 #&amp;arr[j+1]</span><br><span class="line">	lw   $t5,0($t0) #$t5 = arr[j+1]</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	bge $t5,$t4,skip #if arr[j+1]&gt;arr[j] skip</span><br><span class="line"></span><br><span class="line">	sw  $t5,0($t1)</span><br><span class="line">	sw  $t4,0($t0)</span><br><span class="line">	</span><br><span class="line">skip:</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	addi $t8,$t8,1 #j++</span><br><span class="line">	subi $t1,$t9,1 #t1 = num-1</span><br><span class="line">	sub  $t1,$t1,$t7 #t1 = num-1-i</span><br><span class="line">	blt  $t8,$t1,loop2 # if j&lt;num-i-1 t2=1</span><br><span class="line">	addi $t7,$t7,1 #i++</span><br><span class="line">	sub  $t3,$t9,1</span><br><span class="line">	blt  $t7,$t3,loop1  #if i&lt;num-1 then continue loop1</span><br><span class="line">	j output</span><br><span class="line">	</span><br><span class="line">special:</span><br><span class="line">	la $a0,input_int_msg</span><br><span class="line">	li $v0,4</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	li $v0,5  </span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	#for(int i=0;i&lt;num;i++)</span><br><span class="line">        #cin&gt;&gt;arr[i];</span><br><span class="line">        </span><br><span class="line">        move $t0,$t7 #$t0 is i</span><br><span class="line">        sll $t0,$t0,2 #i become byte offset</span><br><span class="line">        move $t1,$t6 #$t1 is &amp;array[0]</span><br><span class="line">        add $t1,$t1,$t0 #$t1 is &amp;array[i]</span><br><span class="line">        sw $v0,0($t1) #cin&gt;&gt;array[i]</span><br><span class="line">	</span><br><span class="line">output:</span><br><span class="line">	</span><br><span class="line">	la $a0,output_msg</span><br><span class="line">	li $v0,4</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	move $t7,$zero</span><br><span class="line">print:</span><br><span class="line">	</span><br><span class="line">	move $t0,$t7</span><br><span class="line">	</span><br><span class="line">	sll $t0,$t0,2</span><br><span class="line">	</span><br><span class="line">	add $t1,$t6,$t0</span><br><span class="line">	</span><br><span class="line">	lw $a0,0($t1) #argument a0</span><br><span class="line">	</span><br><span class="line">	li $v0,1</span><br><span class="line">	syscall</span><br><span class="line">	</span><br><span class="line">	addi $t7,$t7,1</span><br><span class="line">	blt $t7,$t9,print</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/11/14/算法-Sliding-Window/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/14/算法-Sliding-Window/" itemprop="url">算法-(2018-11-14) Sliding Window&Dijkstra枚举</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-14T15:58:00+08:00">
                2018-11-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="sliding-window-leetcode-239"><a href="#sliding-window-leetcode-239" class="headerlink" title="sliding window leetcode 239"></a>sliding window leetcode 239</h5><p><a href="https://leetcode.com/problems/sliding-window-maximum/description/" target="_blank" rel="noopener">https://leetcode.com/problems/sliding-window-maximum/description/</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">method 1: time complexity O(Nlog(k))</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        </span><br><span class="line">        multiset&lt;int&gt;st;</span><br><span class="line">        vector&lt;int&gt;vec;</span><br><span class="line">        list&lt;int&gt; lst;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            if(i-k&gt;=0)&#123;</span><br><span class="line">                int top = lst.front();</span><br><span class="line">                lst.pop_front();</span><br><span class="line">                st.erase(st.find(top));</span><br><span class="line">            &#125;</span><br><span class="line">         </span><br><span class="line">            lst.push_back(nums[i]);</span><br><span class="line">            st.insert(nums[i]);</span><br><span class="line">              if(i-k&gt;=-1)&#123;</span><br><span class="line">                vec.push_back(*st.rbegin());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return vec;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">method 2</span><br><span class="line"></span><br><span class="line">1. use a deque to store the index in the window , each window must fall in the range(i-k+1,i). so whenever an index smaller than i-k+1,pop_front() to discard the element; </span><br><span class="line"></span><br><span class="line">2. when insert a new element nums[i], compare it with the top of the queue , until q[front]&gt;nums[i] ,that is to say, q[front] is always the max element in the window</span><br><span class="line"></span><br><span class="line">  vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">       </span><br><span class="line">         deque&lt;int&gt;dq;</span><br><span class="line">         vector&lt;int&gt;res;</span><br><span class="line">         if(nums.empty())</span><br><span class="line">             return res;</span><br><span class="line">         for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            while(!dq.empty()&amp;&amp;dq.front()&lt;i-k+1)&#123;</span><br><span class="line">                dq.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            //remove smaller elements in window</span><br><span class="line">            while(!dq.empty()&amp;&amp;nums[dq.back()]&lt;=nums[i])&#123;</span><br><span class="line">                dq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">             dq.push_back(i);</span><br><span class="line">             if(i-k+1&gt;=0)&#123;</span><br><span class="line">                 res.push_back(nums[dq.front()]);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里sliding window就是移动窗口的时候，每次把最左边的值pop掉，然后不断比较最右边的值与新插入的值，保证新插入的值是最好的candidate，那么窗口最左边的值就会是最大值。</p>
<p>Kattis</p>
<p>#include <algorithm></algorithm></p>
<p>#include <set></set></p>
<p>#include <iostream></iostream></p>
<p>#include <queue></queue></p>
<p>#include <vector></vector></p>
<p>#include <string></string></p>
<p>#include <map></map></p>
<p>using namespace std;</p>
<p>struct edge{<br>    int from;<br>    int to;<br>    int weight;<br>};</p>
<p>typedef pair&lt;int,int&gt; ip;</p>
<p>#define INF 0x3f3f3f3f</p>
<p>void dijkstra(vector&lt;vector<ip>&gt;&amp;adj,vector<int>&amp;dist,int source){</int></ip></p>
<pre><code>priority_queue&lt;ip,vector&lt;ip&gt;,greater&lt;ip&gt;&gt; q;
q.push({0,source});
dist[source] = 0;
while(!q.empty()){
    auto top = q.top();
    q.pop();
    int u = top.second;
    for(auto p:adj[u]){
        int v = p.first;
        int weight = p.second;
        if(dist[v]==INF||dist[v]&gt;dist[u]+weight){
            dist[v] = dist[u]+weight;
            q.push(make_pair(dist[v],v));
        }
    }
}
</code></pre><p>}</p>
<p><a href="https://open.kattis.com/problems/flowerytrails" target="_blank" rel="noopener">https://open.kattis.com/problems/flowerytrails</a></p>
<p><strong><em>对于有多条最短路，并且求所有最短路的路径之和</em></strong></p>
<p>1.分别对起始点和终点跑DIjkstra</p>
<p>2.枚举每一条初始点与终点分别到这条边距离，分别为d1,d2，如果d1+d2+w==shortestPath,则ans+=w;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int P,T;</span><br><span class="line">    cin&gt;&gt;P&gt;&gt;T;</span><br><span class="line">    vector&lt;vector&lt;ip&gt;&gt; adj(P);</span><br><span class="line">    vector&lt;vector&lt;ip&gt;&gt; parent(P);</span><br><span class="line">    vector&lt;int&gt;distStart(P,INF);</span><br><span class="line">    vector&lt;int&gt;distEnd(P,INF);</span><br><span class="line">    vector&lt;tuple&lt;int,int,int&gt;&gt;edgeVec;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;T;i++)&#123;</span><br><span class="line">        int from,to,w;</span><br><span class="line">        cin&gt;&gt;from&gt;&gt;to&gt;&gt;w;</span><br><span class="line">        edgeVec.push_back(make_tuple(from,to,w));</span><br><span class="line">        adj[from].push_back(make_pair(to,w));</span><br><span class="line">        adj[to].push_back(make_pair(from,w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dijkstra(adj,distStart,0);</span><br><span class="line">    dijkstra(adj,distEnd,P-1);</span><br><span class="line"></span><br><span class="line">    int shortestPath = distStart[P-1];</span><br><span class="line">    int ans=0;</span><br><span class="line">    for(int i=0;i&lt;T;i++)&#123;</span><br><span class="line">        int from = get&lt;0&gt;(edgeVec[i]);</span><br><span class="line">        int to = get&lt;1&gt;(edgeVec[i]);</span><br><span class="line">        int weight = get&lt;2&gt;(edgeVec[i]);</span><br><span class="line"></span><br><span class="line">        if(distStart[to]+distEnd[from]+weight==shortestPath||</span><br><span class="line">        distStart[from]+distEnd[to]+weight==shortestPath)&#123;</span><br><span class="line">            ans+=weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;ans*2;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/29/DS-Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/DS-Graph/" itemprop="url">DS-Topo,Bipartite,max flow&min cut</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-29T10:38:37+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h3><h4 id="ver1-DFS"><a href="#ver1-DFS" class="headerlink" title="ver1 DFS"></a>ver1 DFS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">for each unvisited node u in V:</span><br><span class="line">	DFS(u)</span><br><span class="line">    for each neighbour h of u:</span><br><span class="line">    	if(!visited)</span><br><span class="line">        	DFS(h)</span><br><span class="line">    finish DFS(u) // push_back u to the list</span><br><span class="line">reverse the list!</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/topo.png" alt="upload successl"></p>
<h4 id="ver2-BFS-Khan"><a href="#ver2-BFS-Khan" class="headerlink" title="ver2 BFS (Khan)"></a>ver2 BFS (Khan)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">push vertices with no incoming edges to the queue</span><br><span class="line">while(!q.empty):</span><br><span class="line">	u = q.top </span><br><span class="line">    q.pop</span><br><span class="line">    for each neighbor x of u</span><br><span class="line">    	delete u-&gt;x</span><br><span class="line">        if x has no incoming edges,then push x to the queu</span><br><span class="line">//done</span><br></pre></td></tr></table></figure>
<h3 id="Bipartite"><a href="#Bipartite" class="headerlink" title="Bipartite"></a>Bipartite</h3><h4 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h4><p><img src="/home/alex/图片/def.png" alt="upload successfl"></p>
<p>1.说白了就是图的所有点可以分为两个set，每个set之间互相没有边，只有set与set之间的点有边。</p>
<p>2.应用于无向图。</p>
<h4 id="Bipartite-checker"><a href="#Bipartite-checker" class="headerlink" title="Bipartite checker"></a>Bipartite checker</h4><h4 id="ver1-DFS-1"><a href="#ver1-DFS-1" class="headerlink" title="ver1 DFS"></a>ver1 DFS</h4><p>每个点的邻居与它不同色（就是不同一个set）</p>
<p>每个点与它的邻居的邻居同色，它邻居的邻居与它在同一个set</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for each unvisited vertex in u:</span><br><span class="line">	dfs(u)</span><br><span class="line">    for each neighbor v in u:</span><br><span class="line">    	if(v is unvisited)</span><br><span class="line">        	assign u as different color</span><br><span class="line">        else if u and v has same color</span><br><span class="line">        	break!</span><br><span class="line">            it is not a bipartite</span><br></pre></td></tr></table></figure>
<h4 id="ver2-BFS"><a href="#ver2-BFS" class="headerlink" title="ver2 BFS"></a>ver2 BFS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push vertexs with no incoming edged to queue</span><br><span class="line">while(!queue.empty())</span><br><span class="line">	u = queue.top</span><br><span class="line">    q.pop</span><br><span class="line">    for v in neighbor in u</span><br><span class="line">    	if(v.color==u.color)</span><br><span class="line">        	exit;//no bipartite</span><br><span class="line">        else if unvisited </span><br><span class="line">        	assign different color to v</span><br></pre></td></tr></table></figure>
<h3 id="max-flow"><a href="#max-flow" class="headerlink" title="max flow"></a>max flow</h3><h4 id="intro-to-mincut-problem"><a href="#intro-to-mincut-problem" class="headerlink" title="intro to mincut problem"></a>intro to mincut problem</h4><p><img src="/home/alex/图片/2018-46.png" alt="filename already exists, renmed"></p>
<h4 id="intro-to-maxflow-problem"><a href="#intro-to-maxflow-problem" class="headerlink" title="intro to maxflow problem"></a>intro to maxflow problem</h4><p><img src="/home/alex/图片/2018-47.png" alt="filename already exists, rename"></p>
<h3 id="Ford-Fulkerson-Algorithm"><a href="#Ford-Fulkerson-Algorithm" class="headerlink" title="Ford-Fulkerson Algorithm"></a>Ford-Fulkerson Algorithm</h3><p>mincut 和 maxflow problem 实际上是等价的，解决了其中一个，另外一个就自然解决了。</p>
<p><img src="/home/alex/图片/2018-49.png" alt="filename already exists, reamed"></p>
<p>如上图，a为开始点。各边左数字为capacity，右边数字为flow</p>
<p>a-&gt;b满了，a-&gt;b有一个cut</p>
<p>a-&gt;c不满，即（flow&lt;capacity）</p>
<p>c-&gt;e满了（flow==capacity）</p>
<p>c-&gt;d满了（flow==capacity）</p>
<p>设点a,c为集合P，其余所有点为集合P‘</p>
<p>则capacity of P-&gt;P’ 就等于maximum flow </p>
<p><img src="/home/alex/图片/2018-50.png" alt="filename already exists, renaed"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start with 0 flow</span><br><span class="line">while there exists an augmenting path:</span><br><span class="line">	find an augmenting path</span><br><span class="line">    compute bottleneck capacity</span><br><span class="line">    increase flow on that path by bottleneck 	 capacity</span><br></pre></td></tr></table></figure>
<h5 id="Augmenting-Path"><a href="#Augmenting-Path" class="headerlink" title="Augmenting Path:"></a>Augmenting Path:</h5><p>find an <strong><em>undirected</em></strong> path from s to t such that:</p>
<pre><code>can increase flow on forward edges(not full.)
can decrease flow on backward edge(not empty.)
</code></pre><h5 id="termination"><a href="#termination" class="headerlink" title="termination"></a>termination</h5><p>all paths from s to t are blocked by either a:</p>
<p>full forward edge</p>
<p>empty backward edge</p>
<h5 id="relationship-between-flow-and-cuts"><a href="#relationship-between-flow-and-cuts" class="headerlink" title="relationship between flow and cuts"></a>relationship between flow and cuts</h5><p><img src="/home/alex/图片/flow.png" alt="upload succesful"></p>
<p><img src="/home/alex/图片/lizi.png" alt="upload succsful"></p>
<h5 id="network-of-flow"><a href="#network-of-flow" class="headerlink" title="network of flow"></a>network of flow</h5><p><img src="/home/alex/图片/shenzong.png" alt="upload succeful"></p>
<p><img src="/home/alex/图片/ziyou.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/path.png" alt="upload successf"></p>
<p><img src="/home/alex/图片/pm.png" alt="upload succsful"></p>
<p><img src="/home/alex/图片/max.png" alt="upload succeful"></p>
<p>so how to find mincut from maxflow f?</p>
<p>start from s,find the forward edge that is not full or backward edge that is not empty</p>
<p><img src="/home/alex/图片/bengk.png" alt="upload succesl"></p>
<h3 id="Ford-fulkerson算法"><a href="#Ford-fulkerson算法" class="headerlink" title="Ford-fulkerson算法"></a>Ford-fulkerson算法</h3><p>Ford-fulkerson算法就是： 不断在残留网络中找增广路，直到没有为止。</p>
<p> Time complexity : O(C*E) ,C 是容量和</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time complexity of the above algorithm is O(max_flow * E). We run a loop while there is an augmenting path. In worst case, we may add 1 unit flow in every iteration. Therefore the time complexity becomes O(max_flow * E).</span><br></pre></td></tr></table></figure>
<h4 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h4><p>Dinic: 每次寻找最短的增广路until找不到，可证明最多能找V次。</p>
<p>Time complexity : O（V^2E）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) Initialize residual graph G as given graph.</span><br><span class="line">1) Do BFS of G to construct a level graph (or</span><br><span class="line">   assign levels to vertices) and also check if </span><br><span class="line">   more flow is possible.</span><br><span class="line">    a) If more flow is not possible, then return.</span><br><span class="line">    b) Send multiple flows in G using level graph </span><br><span class="line">       until blocking flow is reached. Here using </span><br><span class="line">       level graph means, in every flow,</span><br><span class="line">       levels of path nodes should be 0, 1, 2...</span><br><span class="line">       (in order) from s to t.</span><br></pre></td></tr></table></figure>
<p>A flow is <strong><em>Blocking Flow</em></strong> if no more flow can be sent using level graph, i.e., no more s-t path exists such that path vertices have current levels 0, 1, 2… in order. </p>
<h3 id="Dinic-code-Kattis-maximum-flow"><a href="#Dinic-code-Kattis-maximum-flow" class="headerlink" title="Dinic code-Kattis maximum flow"></a>Dinic code-Kattis maximum flow</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define M 50</span><br><span class="line">#define N 50</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//https://www.geeksforgeeks.org/dinics-algorithm-maximum-flow/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Edge &#123;</span><br><span class="line"></span><br><span class="line">    int to;</span><br><span class="line">    unsigned long rev;//store index of reverse edge in adjacency</span><br><span class="line">    int flow, cap;//cap is capacity</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dinic &#123;</span><br><span class="line">    using AdjacencyList=vector&lt; vector&lt;Edge&gt; &gt;;</span><br><span class="line"></span><br><span class="line">    bool bfs() &#123;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        q.push(source);</span><br><span class="line">        fill(begin(levels), end(levels), -1);</span><br><span class="line">        levels[source] = 0;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            const auto now = q.front(); q.pop();</span><br><span class="line">            for (const auto&amp; e : adjList[now]) &#123;</span><br><span class="line">                if (levels[e.to] == -1 &amp;&amp; e.flow &lt; e.cap) &#123;</span><br><span class="line">                    q.push(e.to);</span><br><span class="line">                    levels[e.to] = levels[now] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return levels[sink] != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //a dfs based function to send flow after BFS</span><br><span class="line">//has figured out that there is a possible flow</span><br><span class="line">//and constructed levels.This function called multiple times for a</span><br><span class="line">//a single call of BFS</span><br><span class="line">//flow: current flow sent by parent function call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int dfs(int v, int flow) &#123;</span><br><span class="line">        if (flow == 0) return 0;</span><br><span class="line">        if (v == sink) return flow;</span><br><span class="line">        for (int &amp; i = currentEdge[v]; i &lt; (int) adjList[v].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; edge = adjList[v][i];</span><br><span class="line">            if (levels[v] + 1 == levels[edge.to]) &#123;</span><br><span class="line">                const auto minimalFlow = dfs(edge.to, min(flow, edge.cap - edge.flow));</span><br><span class="line">                if (minimalFlow &gt; 0) &#123;</span><br><span class="line">                    //add flow to current edge</span><br><span class="line">                    edge.flow += minimalFlow;</span><br><span class="line">                    //subtract flow from reverse edge</span><br><span class="line">                    adjList[edge.to][edge.rev].flow -= minimalFlow;</span><br><span class="line">                    return minimalFlow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; levels, currentEdge;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int source, sink;</span><br><span class="line">    AdjacencyList adjList;</span><br><span class="line"></span><br><span class="line">    void AddEdge(int a, int b, int cap) &#123;</span><br><span class="line">        //ADJList动态变化，节省空间</span><br><span class="line">        if (max(a, b) &gt;= (int) adjList.size()) &#123;</span><br><span class="line">            adjList.resize(max(a, b) + 1);</span><br><span class="line">            levels.resize(max(a, b) + 1);</span><br><span class="line">            currentEdge.resize(max(a, b) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        const auto rev_a = adjList[b].size();</span><br><span class="line">        const auto rev_b = adjList[a].size();</span><br><span class="line">        adjList[a].push_back(&#123;b, rev_a, 0, cap&#125;);</span><br><span class="line">        adjList[b].push_back(&#123;a, rev_b, 0, 0&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int MaxFlow(int s, int t) &#123;</span><br><span class="line">        source = s;</span><br><span class="line">        sink = t;</span><br><span class="line">        int flow = 0;</span><br><span class="line">        //augment the flow while there is path</span><br><span class="line">        //from source to sink</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int m = bfs();</span><br><span class="line">            if (!m) break;</span><br><span class="line">            fill(begin(currentEdge), end(currentEdge), 0);</span><br><span class="line">            while (int pushed = dfs(source, INT_MAX)) &#123;</span><br><span class="line">                flow += pushed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int n,m,s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    Dinic d;</span><br><span class="line">    d.sink =s;</span><br><span class="line">    d.source = t;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;flow(n,vector&lt;int&gt;(n,0));</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        int u,v,c;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;</span><br><span class="line">        //flow[u][v] = c;</span><br><span class="line">        d.AddEdge(u,v,c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;d.MaxFlow(s,t)&lt;&lt;&quot; &quot;;</span><br><span class="line">    //SIZE is the number of edges used in the solution</span><br><span class="line">    //</span><br><span class="line">    int size = 0;</span><br><span class="line">    vector&lt;tuple&lt;int,int,int&gt;&gt;ans;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(auto &amp;e:d.adjList[i])&#123;</span><br><span class="line">            if(e.flow&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                size++;</span><br><span class="line">                ans.push_back(&#123;i,e.to,e.flow&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    for(auto &amp;t:ans)&#123;</span><br><span class="line">        int from = get&lt;0&gt;(t);</span><br><span class="line">        int to = get&lt;1&gt;(t);</span><br><span class="line">        int f = get&lt;2&gt;(t);</span><br><span class="line">        cout&lt;&lt;from&lt;&lt;&quot; &quot;&lt;&lt;to&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="Alex Chiu" />
            
              <p class="site-author-name" itemprop="name">Alex Chiu</p>
              <p class="site-description motion-element" itemprop="description">Alex's personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">43</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Chiu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
