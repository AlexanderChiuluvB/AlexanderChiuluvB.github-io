<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Alex&apos;s personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex Chiu">
<meta property="og:url" content="http://AlexanderChiuluvB.github.io/page/3/index.html">
<meta property="og:site_name" content="Alex Chiu">
<meta property="og:description" content="Alex&apos;s personal blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex Chiu">
<meta name="twitter:description" content="Alex&apos;s personal blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://AlexanderChiuluvB.github.io/page/3/"/>





  <title>Alex Chiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex Chiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/29/DS-Graph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/29/DS-Graph/" itemprop="url">DS-Topo,Bipartite,max flow&min cut</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-29T10:38:37+08:00">
                2018-10-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Topological-Sort"><a href="#Topological-Sort" class="headerlink" title="Topological Sort"></a>Topological Sort</h3><h4 id="ver1-DFS"><a href="#ver1-DFS" class="headerlink" title="ver1 DFS"></a>ver1 DFS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">for each unvisited node u in V:</span><br><span class="line">	DFS(u)</span><br><span class="line">    for each neighbour h of u:</span><br><span class="line">    	if(!visited)</span><br><span class="line">        	DFS(h)</span><br><span class="line">    finish DFS(u) // push_back u to the list</span><br><span class="line">reverse the list!</span><br></pre></td></tr></table></figure>
<p><img src="/home/alex/图片/topo.png" alt="upload successl"></p>
<h4 id="ver2-BFS-Khan"><a href="#ver2-BFS-Khan" class="headerlink" title="ver2 BFS (Khan)"></a>ver2 BFS (Khan)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">code:</span><br><span class="line">push vertices with no incoming edges to the queue</span><br><span class="line">while(!q.empty):</span><br><span class="line">	u = q.top </span><br><span class="line">    q.pop</span><br><span class="line">    for each neighbor x of u</span><br><span class="line">    	delete u-&gt;x</span><br><span class="line">        if x has no incoming edges,then push x to the queu</span><br><span class="line">//done</span><br></pre></td></tr></table></figure>
<h3 id="Bipartite"><a href="#Bipartite" class="headerlink" title="Bipartite"></a>Bipartite</h3><h4 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h4><p><img src="/home/alex/图片/def.png" alt="upload successfl"></p>
<p>1.说白了就是图的所有点可以分为两个set，每个set之间互相没有边，只有set与set之间的点有边。</p>
<p>2.应用于无向图。</p>
<h4 id="Bipartite-checker"><a href="#Bipartite-checker" class="headerlink" title="Bipartite checker"></a>Bipartite checker</h4><h4 id="ver1-DFS-1"><a href="#ver1-DFS-1" class="headerlink" title="ver1 DFS"></a>ver1 DFS</h4><p>每个点的邻居与它不同色（就是不同一个set）</p>
<p>每个点与它的邻居的邻居同色，它邻居的邻居与它在同一个set</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for each unvisited vertex in u:</span><br><span class="line">	dfs(u)</span><br><span class="line">    for each neighbor v in u:</span><br><span class="line">    	if(v is unvisited)</span><br><span class="line">        	assign u as different color</span><br><span class="line">        else if u and v has same color</span><br><span class="line">        	break!</span><br><span class="line">            it is not a bipartite</span><br></pre></td></tr></table></figure>
<h4 id="ver2-BFS"><a href="#ver2-BFS" class="headerlink" title="ver2 BFS"></a>ver2 BFS</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push vertexs with no incoming edged to queue</span><br><span class="line">while(!queue.empty())</span><br><span class="line">	u = queue.top</span><br><span class="line">    q.pop</span><br><span class="line">    for v in neighbor in u</span><br><span class="line">    	if(v.color==u.color)</span><br><span class="line">        	exit;//no bipartite</span><br><span class="line">        else if unvisited </span><br><span class="line">        	assign different color to v</span><br></pre></td></tr></table></figure>
<h3 id="max-flow"><a href="#max-flow" class="headerlink" title="max flow"></a>max flow</h3><h4 id="intro-to-mincut-problem"><a href="#intro-to-mincut-problem" class="headerlink" title="intro to mincut problem"></a>intro to mincut problem</h4><p><img src="/home/alex/图片/2018-46.png" alt="filename already exists, renmed"></p>
<h4 id="intro-to-maxflow-problem"><a href="#intro-to-maxflow-problem" class="headerlink" title="intro to maxflow problem"></a>intro to maxflow problem</h4><p><img src="/home/alex/图片/2018-47.png" alt="filename already exists, rename"></p>
<h3 id="Ford-Fulkerson-Algorithm"><a href="#Ford-Fulkerson-Algorithm" class="headerlink" title="Ford-Fulkerson Algorithm"></a>Ford-Fulkerson Algorithm</h3><p>mincut 和 maxflow problem 实际上是等价的，解决了其中一个，另外一个就自然解决了。</p>
<p><img src="/home/alex/图片/2018-49.png" alt="filename already exists, reamed"></p>
<p>如上图，a为开始点。各边左数字为capacity，右边数字为flow</p>
<p>a-&gt;b满了，a-&gt;b有一个cut</p>
<p>a-&gt;c不满，即（flow&lt;capacity）</p>
<p>c-&gt;e满了（flow==capacity）</p>
<p>c-&gt;d满了（flow==capacity）</p>
<p>设点a,c为集合P，其余所有点为集合P‘</p>
<p>则capacity of P-&gt;P’ 就等于maximum flow </p>
<p><img src="/home/alex/图片/2018-50.png" alt="filename already exists, renaed"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Start with 0 flow</span><br><span class="line">while there exists an augmenting path:</span><br><span class="line">	find an augmenting path</span><br><span class="line">    compute bottleneck capacity</span><br><span class="line">    increase flow on that path by bottleneck 	 capacity</span><br></pre></td></tr></table></figure>
<h5 id="Augmenting-Path"><a href="#Augmenting-Path" class="headerlink" title="Augmenting Path:"></a>Augmenting Path:</h5><p>find an <strong><em>undirected</em></strong> path from s to t such that:</p>
<pre><code>can increase flow on forward edges(not full.)
can decrease flow on backward edge(not empty.)
</code></pre><h5 id="termination"><a href="#termination" class="headerlink" title="termination"></a>termination</h5><p>all paths from s to t are blocked by either a:</p>
<p>full forward edge</p>
<p>empty backward edge</p>
<h5 id="relationship-between-flow-and-cuts"><a href="#relationship-between-flow-and-cuts" class="headerlink" title="relationship between flow and cuts"></a>relationship between flow and cuts</h5><p><img src="/home/alex/图片/flow.png" alt="upload succesful"></p>
<p><img src="/home/alex/图片/lizi.png" alt="upload succsful"></p>
<h5 id="network-of-flow"><a href="#network-of-flow" class="headerlink" title="network of flow"></a>network of flow</h5><p><img src="/home/alex/图片/shenzong.png" alt="upload succeful"></p>
<p><img src="/home/alex/图片/ziyou.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/path.png" alt="upload successf"></p>
<p><img src="/home/alex/图片/pm.png" alt="upload succsful"></p>
<p><img src="/home/alex/图片/max.png" alt="upload succeful"></p>
<p>so how to find mincut from maxflow f?</p>
<p>start from s,find the forward edge that is not full or backward edge that is not empty</p>
<p><img src="/home/alex/图片/bengk.png" alt="upload succesl"></p>
<h3 id="Ford-fulkerson算法"><a href="#Ford-fulkerson算法" class="headerlink" title="Ford-fulkerson算法"></a>Ford-fulkerson算法</h3><p>Ford-fulkerson算法就是： 不断在残留网络中找增广路，直到没有为止。</p>
<p> Time complexity : O(C*E) ,C 是容量和</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time complexity of the above algorithm is O(max_flow * E). We run a loop while there is an augmenting path. In worst case, we may add 1 unit flow in every iteration. Therefore the time complexity becomes O(max_flow * E).</span><br></pre></td></tr></table></figure>
<h4 id="Dinic-算法"><a href="#Dinic-算法" class="headerlink" title="Dinic 算法"></a>Dinic 算法</h4><p>Dinic: 每次寻找最短的增广路until找不到，可证明最多能找V次。</p>
<p>Time complexity : O（V^2E）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1) Initialize residual graph G as given graph.</span><br><span class="line">1) Do BFS of G to construct a level graph (or</span><br><span class="line">   assign levels to vertices) and also check if </span><br><span class="line">   more flow is possible.</span><br><span class="line">    a) If more flow is not possible, then return.</span><br><span class="line">    b) Send multiple flows in G using level graph </span><br><span class="line">       until blocking flow is reached. Here using </span><br><span class="line">       level graph means, in every flow,</span><br><span class="line">       levels of path nodes should be 0, 1, 2...</span><br><span class="line">       (in order) from s to t.</span><br></pre></td></tr></table></figure>
<p>A flow is <strong><em>Blocking Flow</em></strong> if no more flow can be sent using level graph, i.e., no more s-t path exists such that path vertices have current levels 0, 1, 2… in order. </p>
<h3 id="Dinic-code-Kattis-maximum-flow"><a href="#Dinic-code-Kattis-maximum-flow" class="headerlink" title="Dinic code-Kattis maximum flow"></a>Dinic code-Kattis maximum flow</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"> #include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">#define M 50</span><br><span class="line">#define N 50</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//https://www.geeksforgeeks.org/dinics-algorithm-maximum-flow/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct Edge &#123;</span><br><span class="line"></span><br><span class="line">    int to;</span><br><span class="line">    unsigned long rev;//store index of reverse edge in adjacency</span><br><span class="line">    int flow, cap;//cap is capacity</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Dinic &#123;</span><br><span class="line">    using AdjacencyList=vector&lt; vector&lt;Edge&gt; &gt;;</span><br><span class="line"></span><br><span class="line">    bool bfs() &#123;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        q.push(source);</span><br><span class="line">        fill(begin(levels), end(levels), -1);</span><br><span class="line">        levels[source] = 0;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            const auto now = q.front(); q.pop();</span><br><span class="line">            for (const auto&amp; e : adjList[now]) &#123;</span><br><span class="line">                if (levels[e.to] == -1 &amp;&amp; e.flow &lt; e.cap) &#123;</span><br><span class="line">                    q.push(e.to);</span><br><span class="line">                    levels[e.to] = levels[now] + 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return levels[sink] != -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //a dfs based function to send flow after BFS</span><br><span class="line">//has figured out that there is a possible flow</span><br><span class="line">//and constructed levels.This function called multiple times for a</span><br><span class="line">//a single call of BFS</span><br><span class="line">//flow: current flow sent by parent function call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int dfs(int v, int flow) &#123;</span><br><span class="line">        if (flow == 0) return 0;</span><br><span class="line">        if (v == sink) return flow;</span><br><span class="line">        for (int &amp; i = currentEdge[v]; i &lt; (int) adjList[v].size(); ++i) &#123;</span><br><span class="line">            Edge&amp; edge = adjList[v][i];</span><br><span class="line">            if (levels[v] + 1 == levels[edge.to]) &#123;</span><br><span class="line">                const auto minimalFlow = dfs(edge.to, min(flow, edge.cap - edge.flow));</span><br><span class="line">                if (minimalFlow &gt; 0) &#123;</span><br><span class="line">                    //add flow to current edge</span><br><span class="line">                    edge.flow += minimalFlow;</span><br><span class="line">                    //subtract flow from reverse edge</span><br><span class="line">                    adjList[edge.to][edge.rev].flow -= minimalFlow;</span><br><span class="line">                    return minimalFlow;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; levels, currentEdge;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int source, sink;</span><br><span class="line">    AdjacencyList adjList;</span><br><span class="line"></span><br><span class="line">    void AddEdge(int a, int b, int cap) &#123;</span><br><span class="line">        //ADJList动态变化，节省空间</span><br><span class="line">        if (max(a, b) &gt;= (int) adjList.size()) &#123;</span><br><span class="line">            adjList.resize(max(a, b) + 1);</span><br><span class="line">            levels.resize(max(a, b) + 1);</span><br><span class="line">            currentEdge.resize(max(a, b) + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        const auto rev_a = adjList[b].size();</span><br><span class="line">        const auto rev_b = adjList[a].size();</span><br><span class="line">        adjList[a].push_back(&#123;b, rev_a, 0, cap&#125;);</span><br><span class="line">        adjList[b].push_back(&#123;a, rev_b, 0, 0&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int MaxFlow(int s, int t) &#123;</span><br><span class="line">        source = s;</span><br><span class="line">        sink = t;</span><br><span class="line">        int flow = 0;</span><br><span class="line">        //augment the flow while there is path</span><br><span class="line">        //from source to sink</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int m = bfs();</span><br><span class="line">            if (!m) break;</span><br><span class="line">            fill(begin(currentEdge), end(currentEdge), 0);</span><br><span class="line">            while (int pushed = dfs(source, INT_MAX)) &#123;</span><br><span class="line">                flow += pushed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return flow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    int n,m,s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    Dinic d;</span><br><span class="line">    d.sink =s;</span><br><span class="line">    d.source = t;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;flow(n,vector&lt;int&gt;(n,0));</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        int u,v,c;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;c;</span><br><span class="line">        //flow[u][v] = c;</span><br><span class="line">        d.AddEdge(u,v,c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;&quot; &quot;&lt;&lt;d.MaxFlow(s,t)&lt;&lt;&quot; &quot;;</span><br><span class="line">    //SIZE is the number of edges used in the solution</span><br><span class="line">    //</span><br><span class="line">    int size = 0;</span><br><span class="line">    vector&lt;tuple&lt;int,int,int&gt;&gt;ans;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(auto &amp;e:d.adjList[i])&#123;</span><br><span class="line">            if(e.flow&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                size++;</span><br><span class="line">                ans.push_back(&#123;i,e.to,e.flow&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;size&lt;&lt;endl;</span><br><span class="line">    for(auto &amp;t:ans)&#123;</span><br><span class="line">        int from = get&lt;0&gt;(t);</span><br><span class="line">        int to = get&lt;1&gt;(t);</span><br><span class="line">        int f = get&lt;2&gt;(t);</span><br><span class="line">        cout&lt;&lt;from&lt;&lt;&quot; &quot;&lt;&lt;to&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/27/stack-and-heap-and-memory-leak/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/stack-and-heap-and-memory-leak/" itemprop="url">CSAPP-进程控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-27T23:40:00+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="获取进程ID"><a href="#获取进程ID" class="headerlink" title="获取进程ID"></a>获取进程ID</h3><p>每个进程都有一个唯一的正数进程ID，getpid函数返回调用进程的PID，getppid函数返回它的父进程的PID（创建调用进程的进程）</p>
<h3 id="创建和终止进程"><a href="#创建和终止进程" class="headerlink" title="创建和终止进程"></a>创建和终止进程</h3><p>1.运行 </p>
<p>2.停止</p>
<p>3.终止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	pid_t pid;</span><br><span class="line">    int x= 1;</span><br><span class="line">    </span><br><span class="line">    pid = Fork();</span><br><span class="line">    if(pid==0)&#123;</span><br><span class="line">		printf(&quot;child : x=%d\n&quot;,++x);    </span><br><span class="line">    	exit(0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;parent: x=%d\n&quot;,--x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<p>1.fork函数只调用一次，但是会返回两次，一次是在父进程中，另外一次是在子进程中。</p>
<p>2.父进程总会返回子进程的PID，在子进程当中，fork总会返回0</p>
<p>3.并发执行，内核能够一任意方式交替执行它们逻辑控制流中的指令<br>在x86上，先完成父进程，再完成子进程,这个顺序不同的系统会不同，画出进程图，所有拓扑排序序列都可以。</p>
<p>4.相同但是独立的地址空间，每个进程都有相同的用户栈，相同的本地变量值，堆等“环境”，但却是独立的，就是说一个进程改变内部的环境不会影响另外一个进程</p>
<p>5.共享文件共享文件</p>
<p>结果如下<br><img src="/home/alex/图片/2018-65.png" alt="filename  exists, renamed"></p>
<p>所以上面程序的分析：</p>
<p>pid==0，即子进程</p>
<p>那如果是以下程序呢？</p>
<p><img src="/home/alex/图片/pro.png" alt="upload succful"></p>
<p><img src="/home/alex/图片/2018-66.png" alt="filename ready exists, renamed"></p>
<p>解析：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">先调用父进程，x=1，所以输出--x=0;</span><br><span class="line">然后调用子进程，子进程除了会执行if内的printf语句，同时还会执行if外的printf语句。</span><br></pre></td></tr></table></figure>
<h3 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h3><p>当一个进程由于某种原因中止的时候，内核不会立刻把它从系统中清除，而是保存在一个已经终止的状态中，等待被父进程回收。</p>
<p>所以一个终止了的但是还没有被回收的进程，成为僵死进程</p>
<p>如果父进程终止了，内核会安排init进程成为它孤儿进程的养父，init进程的PID位1，是系统启动的时候由内核创建的，不会终止，是所有进程的祖先。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pid_t waitpid(pid_t pid,int *statsup,int options)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>pid参数用来判断等待集合的成员。</p>
<p>如果pid&gt;0，那么等待集合就是一个单独的子进程，它的进程ID等于pid</p>
<p>如果pid=-1，那么等待集合是由父进程的所有子进程组成的</p>
<h4 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h4><p>wait函数是waitpid函数的简单版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t wait(int *statusp); // = waitpid(-1,&amp;status,0);</span><br></pre></td></tr></table></figure>
<h3 id="让进程休眠"><a href="#让进程休眠" class="headerlink" title="让进程休眠"></a>让进程休眠</h3><p>//返回要休眠的秒数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unsigned int sleep(unsigned int secs);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pause (void)</span><br><span class="line"></span><br><span class="line">让函数休眠，知道进程收到一个信号</span><br><span class="line">//always return -1</span><br></pre></td></tr></table></figure>
<h3 id="加载并运行程序"><a href="#加载并运行程序" class="headerlink" title="加载并运行程序"></a>加载并运行程序</h3><p>execve函数在当前进程上下文当中加载并且运行一个新程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int execve(const char *filename,const char *argv[],const char *envp[])</span><br></pre></td></tr></table></figure></p>
<p>execve函数加载并且运行可执行目标文件，且带参数列表argv和环境变量envp，只有当出现错误例如找不到filename的时候，execve才会返回到调用程序。</p>
<p>execve函数调用一次，而且从不返回</p>
<p>当execve加载了filename后，启动代码设置栈，并将控制传递给新程序的主函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char *argv,char **envp)</span><br></pre></td></tr></table></figure>
<p>1.argc argv[]数组中非空指针的数量</p>
<p>2.argv argb[]数组中的第一个条目</p>
<p>3.envp 指向argv[]数组的第一个条目</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *getenv(const char *name) 函数</span><br><span class="line"></span><br><span class="line">搜索字符串 name==value,找到就返回一个指向其的指针，否则返回NULL；</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int setenv(const char *name,const char *newvalue,int overwrite)//当overwrite非0的时候，如果name不存在，那么setenv把“name=newvalue&quot;添加到数组当中</span><br><span class="line"></span><br><span class="line">unsetenv就是会删除它</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//查看函数的命令行参数和环境变量</span><br><span class="line"></span><br><span class="line">int main(int argc,char *argv[],char *envp[])</span><br><span class="line">  &#123;</span><br><span class="line">      int i;</span><br><span class="line">      printf(&quot;command-line arguments:\n&quot;);</span><br><span class="line">      for(i=0;argv[i]!=NULL;i++)&#123;</span><br><span class="line">  </span><br><span class="line">          printf(&quot;    argv[%2d]: %s\n&quot;,i,argv[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      printf(&quot;\n&quot;);</span><br><span class="line">      printf(&quot;environmental variables:\n&quot;);</span><br><span class="line">      for(i=0;envp[i]!=NULL;i++)&#123;</span><br><span class="line">  </span><br><span class="line">          printf(&quot;    envp[%2d]: %s\n&quot;,i,envp[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      exit(0);</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="用户栈的组织结构"><a href="#用户栈的组织结构" class="headerlink" title="用户栈的组织结构"></a>用户栈的组织结构</h3><p>动态链接器变量下的envp,argv,与argc是libc_start_main的栈帧</p>
<p><img src="/home/alex/图片/yonghu.png" alt="upload succful"></p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>def：一条通知进程系统发生了一个某种类型事件的小信息</p>
<p>传送一个信号到目的进程由两个不同步骤组成：</p>
<h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><h5 id="进程组："><a href="#进程组：" class="headerlink" title="进程组："></a>进程组：</h5><p>每个进程属于一个进程组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpgrp(void); return id of id group</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setpgid(pid_t pid,pit_t pgid);</span><br></pre></td></tr></table></figure>
<h5 id="用-bin-kill发送信号"><a href="#用-bin-kill发送信号" class="headerlink" title="用/bin/kill发送信号"></a>用/bin/kill发送信号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/kill -9 15213</span><br><span class="line"></span><br><span class="line">/bin/kill -9 -15213 负的PID会导致信号被发送到进程组PID中的每个进程</span><br></pre></td></tr></table></figure>
<h5 id="从键盘发射信号"><a href="#从键盘发射信号" class="headerlink" title="从键盘发射信号"></a>从键盘发射信号</h5><p>作业（job）用来表示为一条命令行求值而创建的进程，在任何时候，至多只有一个前台作业和0个或多个后台作业。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | sort //会创建一个由两个进程组成的前台作业</span><br></pre></td></tr></table></figure>
<h5 id="用kill发射信号"><a href="#用kill发射信号" class="headerlink" title="用kill发射信号"></a>用kill发射信号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int kill (pid_t pid,int sig);</span><br><span class="line">成功则返回0，错误则返回-1</span><br><span class="line"></span><br><span class="line">如果pid大于0，则kill函数发送信号号码sig给进程pid，如果pid为0，则kill发送信号sig给调用进程所在进程组的每个进程，如果pid小于0，kill发送信号sig给进程组pig绝对值中的每个进程</span><br></pre></td></tr></table></figure>
<h4 id="接收信号"><a href="#接收信号" class="headerlink" title="接收信号"></a>接收信号</h4><p>1.内核位每个进程在pending位向量维护着待处理信号的集合，而在blocked位向量维护着被阻塞的信号集合。所以任何时刻一种类型的信号只会被接收一次，在处理它的时候，会先把该类型的信号block，进程可以忽略信号，也可以捕捉这个信号，执行信号处理程序。</p>
<p>2.当内核从一个异常处理程序返回的时候，准备吧控制传递给某个进程p的时候，会检查进程p违背阻塞的待处理信号集合。如果这个集合不为空，那么内核选择集合中的某个信号k（越小越好，因为linux里面编号越小，优先级越高），并且进入k的处理程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* 改变blocked向量的值，若oldset!=null，会用来保存以前blocked向量的值 */ </span><br><span class="line"></span><br><span class="line">int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);</span><br><span class="line"></span><br><span class="line">/* 初始化set为空集 */ int sigemptyset(sigset_t *set); /* 初始化set全为1，每个信号都填入blocked向量 */ </span><br><span class="line"></span><br><span class="line">int sigfillset(sigset *set); </span><br><span class="line"></span><br><span class="line">/* 添加、删除signum到set */ </span><br><span class="line">int sigaddset(sigset_t *set, int signum); int sigdelset(sigset_t *set, int signum);</span><br><span class="line"></span><br><span class="line">/* set中对应signum是否置1 */ </span><br><span class="line"></span><br><span class="line">int sigismember(const sigset_t *set, int signum);</span><br><span class="line">--------------------- </span><br><span class="line"></span><br><span class="line">原文：https://blog.csdn.net/WMLWONDER/article/details/53728630</span><br></pre></td></tr></table></figure>
<p>singal函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sighandler_t signal(int signum,sighandler_t handler)</span><br></pre></td></tr></table></figure>
<p>如果handler不是SIG_IGN或者SIG_DFL，handler 就是用户定义的函数的地址，这个函数叫做信号处理程序。这个过程叫<strong><em>设置信号处理程序</em></strong>，调用过程叫做捕获信号，执行信号处理过程叫做处理信号</p>
<h5 id="阻塞和解除阻塞信号"><a href="#阻塞和解除阻塞信号" class="headerlink" title="阻塞和解除阻塞信号"></a>阻塞和解除阻塞信号</h5><p>隐式阻塞：例如信号s对应程序S，当在处理程序S的时候，如果发送进程一个信号s，那么直到S返回，s会一直是待处理而不被接收。</p>
<p>显式阻塞：使用sigprocmask函数和其辅助函数，明确阻塞和解除阻塞选定的信号。</p>
<h5 id="临时阻塞一个信号"><a href="#临时阻塞一个信号" class="headerlink" title="临时阻塞一个信号"></a>临时阻塞一个信号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sigset_t mask,prev_mask;</span><br><span class="line">Sigemptyset(&amp;mask);</span><br><span class="line">Sigaddset(&amp;mask,SIGINT);</span><br><span class="line"></span><br><span class="line">//block sigint and save previous blocked set</span><br><span class="line"></span><br><span class="line">Sigprocmask(SIG_BLOCK，&amp;mask，&amp;prev_mask);</span><br><span class="line"></span><br><span class="line">	//Code region that will not be interrupt by SIGINT</span><br><span class="line">    </span><br><span class="line">Sigprocmask(SIG_SETMASK,&amp;prev_mask,NULL);</span><br></pre></td></tr></table></figure>
<h5 id="非本地跳转"><a href="#非本地跳转" class="headerlink" title="非本地跳转"></a>非本地跳转</h5><p><img src="/home/alex/图片/2018-67.png" alt="filename aready exists, renamed"></p>
<p>一些原则：</p>
<p>1.注意保存与恢复errno</p>
<p>2.当访问一个全局数据结构的时候，阻塞所有的信号</p>
<p>3.用volatile声明全局变量，告诉编译器不要缓存这个变量，那么每次引用g的时候，都要从内存中读取g的数值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/27/中断与异常的来源/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/27/中断与异常的来源/" itemprop="url">CSAPP中断与异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-27T22:48:00+08:00">
                2018-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="adjustment-to-the-CPU"><a href="#adjustment-to-the-CPU" class="headerlink" title="adjustment to the CPU"></a>adjustment to the CPU</h5><p><img src="/home/alex/图片/cpu.png" alt="upload success"></p>
<p><em>when the results computed by ALU shows that there is an error,<br>then add a signal path from ALU to PC UPDATE</em></p>
<p><em>now PC update have 3 choice to update its value:</em></p>
<p>1.PC+4</p>
<p>2.JUMP instruction PC+offset*4</p>
<p>3.when the error signal is valid PC -&gt; 0  ,which means it turns to address 0 ,execute few instructions from address 0 to rectify the mistakes or show there is an error.</p>
<p>you can also record the PC value then error occurs, so next time you can jump back to the PC value and then continue the execution.</p>
<h5 id="what-is-interruption-and-exception"><a href="#what-is-interruption-and-exception" class="headerlink" title="what is interruption and exception"></a>what is interruption and exception</h5><p><img src="/home/alex/图片/excep.png" alt="upload successl"></p>
<h5 id="the-original-way-to-handle-exception-and-interruptoin"><a href="#the-original-way-to-handle-exception-and-interruptoin" class="headerlink" title="the original way to handle exception and interruptoin"></a>the original way to handle exception and interruptoin</h5><p><img src="/home/alex/图片/modify.png" alt="upload succel"></p>
<h4 id="interrupt-vector"><a href="#interrupt-vector" class="headerlink" title="interrupt vector"></a>interrupt vector</h4><p>how intel 8086 divide its address space?</p>
<p><img src="/home/alex/图片/mm.png" alt="upload success"></p>
<p>中断向量用来存储address which process the interruption</p>
<p><img src="/home/alex/图片/vector.png" alt="upload successf"></p>
<p>IP 存放在指令指针寄存器<br>CS 存放在代码段寄存器</p>
<p>IP，CS寄存器参见<a href="https://blog.csdn.net/qq_35212671/article/details/52752808" target="_blank" rel="noopener">https://blog.csdn.net/qq_35212671/article/details/52752808</a></p>
<p>总的来说，CS:IP 两个寄存器指示了 CPU 当前将要读取的指令的地址。</p>
<p>当要执行一个可执行文件的时候，shell程序会把CS：IP寄存器设置这个程序的初始地址,然后CPU从这个地址开始读取指令</p>
<h5 id="逻辑地址生成物理地址"><a href="#逻辑地址生成物理地址" class="headerlink" title="逻辑地址生成物理地址"></a>逻辑地址生成物理地址</h5><p><img src="/home/alex/图片/img.png" alt="upload su"></p>
<p><img src="/home/alex/图片/xuanzang.png" alt="upload success"></p>
<p>中断向量表要在系统启动的时候进行初始化</p>
<p>一个中断向量占4个字节，1共有1KB空间用来存放中断向量，因此一共有256个中断向量。</p>
<p>CPU发现中断的时候，如果是1号，转向1号中断向量。由于中断向量的位置是固定的，CPU只需要通过硬件电路来访问中断向量，不需要通过软件。而且CS是段基值，IP是偏移量，根据段偏移计算方法：</p>
<p>对应地址为43006H<br>因此转到存储器里面的40996H，执行处理1号中断的服务程序。</p>
<p><em>注意终端服务程序存放顺序不固定</em></p>
<h5 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h5><p><img src="/home/alex/图片/2018-12.png" alt="flename already exists, renamed"></p>
<p>中断类型码就是中断向量序号，由于第0个中断向量是存放在地址0的，因此中断向量码与其存放地址的关系就是 地址 = 向量码×4</p>
<p>10H 20H 对应IP寄存器  30H 40H 对应CS寄存器</p>
<p>因此地址为 4030:2010H</p>
<p><img src="/home/alex/图片/biaoxi.png" alt="upload succes"></p>
<p>23 40 对应CS寄存器<br>78 90 对应IP寄存器</p>
<p>因此字节单元对应的内容分别为</p>
<p>23</p>
<p>40</p>
<p>78</p>
<p>90</p>
<p>(从上往下地址减少)</p>
<h4 id="中断向量表的发展"><a href="#中断向量表的发展" class="headerlink" title="中断向量表的发展"></a>中断向量表的发展</h4><p><img src="/home/alex/图片/huigu.png" alt="upload su"></p>
<p>1.回顾一下，实模式下，地址是有CS寄存器×4 + IP寄存器 来产生一个20位的地址来实现的</p>
<p>2.但是现在EIP的寻址能力和32位地址线寻址范围是对应的，因此保护模式下寻址方式和实模式有所不同。</p>
<h5 id="IA-32的存储器寻址"><a href="#IA-32的存储器寻址" class="headerlink" title="IA-32的存储器寻址"></a>IA-32的存储器寻址</h5><p>1.保护模式下，段基址不在CS中，而在内存中</p>
<p><img src="/home/alex/图片/2018-13.png" alt="upload successful"></p>
<p>为什么会有8192个描述符？</p>
<p>因为CS寄存器寻址能力是16位，可以寻找2^16也就是64K个地址，也就是8192个描述符</p>
<p>而这时候由于不知道起始地址，因此需要一个GDTR寄存器，来存储描述符0所在的地址。这是一个系统寄存器，在系统启动的时候就写好。</p>
<p>#####总结流程：</p>
<p>1.GDTR 结合 CS 寄存器，用来访问存储器中的描述符</p>
<p>2.然后从描述符当中提取出4个保存着基地址的字节，把得到的基地址与EIP指针寄存器结合，得到所要访问的寄存器的地址</p>
<h4 id="保护模式的中断操作"><a href="#保护模式的中断操作" class="headerlink" title="保护模式的中断操作"></a>保护模式的中断操作</h4><p>中断向量表</p>
<p><img src="/home/alex/图片/zhongduan.png" alt="upload succe"></p>
<p>这时候由于地址不是从0开始的，因此与上图类似，CPU需要一个IDTR来记录描述符0所在的地址。</p>
<p>这时候CPU把 <strong>(中断类型号 * 8 + IDTR)</strong>，得到描述符的地址，然后从描述符中选取2个段选择符字节放到CS寄存器，字节0,1,6,7放到EIP寄存器，（理解为偏移量）。记住实模式下，段基址并不是在CS中，而是需要用CS到内存中寻找。</p>
<p>所以当从中断向量取回CS与EIP后，要利用CS和GDTR结合，来寻找段基址，再把段基址与EIP结合，这样最后才能得到<strong>中断服务程序</strong>的入口地址</p>
<p>与实模式下的不同:</p>
<p><em>实模式下中断向量4个字节，其中低位的两个放到IP寄存器，高位的两个放到CS寄存器</em></p>
<h4 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h4><p><img src="/home/alex/图片/zhongd.png" alt="upload successf"></p>
<p><img src="/home/alex/图片/chenju.png" alt="upload succeful"></p>
<p><img src="/home/alex/图片/googl.png" alt="upload"></p>
<p><img src="/home/alex/图片/accu.png" alt="uploada"></p>
<p><img src="/home/alex/图片/man.png" alt="upload"></p>
<p><img src="/home/alex/图片/m.png" alt="upload succ"></p>
<p><img src="/home/alex/图片/2018-14.png" alt="filename already exists, remed"></p>
<p>根据上图： 发生中断的时候先压栈，保存好处理完中断后应该返回的地址的信息。</p>
<p>Flags保存好标志，以免处理的时候会改变某些标志位。</p>
<p>清楚IF-TF 起到关中断的作用？？？</p>
<p>然后再从存储器找到中断向量，取到CS、IP之后就找到了终端服务程序的入口地址。</p>
<p><img src="/home/alex/图片/shixi.png" alt="upload succul"></p>
<p>总结：</p>
<p><img src="/home/alex/图片/ZONGJIE.png" alt="upload succes"></p>
<p>集中内部中断的类型：</p>
<p><img src="/home/alex/图片/s.png" alt="upload succesl"></p>
<p><img src="/home/alex/图片/juanzi.png" alt="upload succ"></p>
<p>注意上述两种中断类型的时机是不同的哦。</p>
<p>中断类型0 是在检测出异常的时候立即发生，而内部中断需要自己主动执行INTO指令才可以检测出来</p>
<p><img src="/home/alex/图片/danbu.png" alt="upload successfl"></p>
<p><img src="/home/alex/图片/shangji.png" alt="upload success"></p>
<p>为什么INT n是两字节指令？ 因为 INT 指令操作码 首先占一个字节 ，然后n范围是0-255 需要8位来表示，所以用2个字节。</p>
<p>那为啥INT 3用1个字节呢？</p>
<p>因为x86地址最短的就是一个字节。如果INT 3 是两个字节或以上，可能会覆盖掉下面的指令的一些字节。</p>
<p>例如：</p>
<p>OFFSET      instruction 1, one byte</p>
<p>OFFSET+1    instruction 2, one byte</p>
<p>如果在inst1设置断点，则而且inst1内容是跳到inst2，则替换的时候INT 3会把inst2某些字节覆盖掉。那么就不能实现跳到inst2的指令了。</p>
<p>OFFSET     INT3……………….</p>
<p>OFFSET+1    ………………….</p>
<p>详情参考 <a href="http://www.cs.columbia.edu/~junfeng/09sp-w4118/lectures/int3/int3.txt" target="_blank" rel="noopener">http://www.cs.columbia.edu/~junfeng/09sp-w4118/lectures/int3/int3.txt</a></p>
<p><img src="/home/alex/图片/2018-15.png" alt="upload successful"></p>
<p><img src="/home/alex/图片/duandian.png" alt="upload success"></p>
<p><img src="/home/alex/图片/duandian2.png" alt="upload succe"></p>
<p>INT 3对应的中断服务程序可以查看 AL寄存器的值 </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/20/CSAPP-Cache-Lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/20/CSAPP-Cache-Lab/" itemprop="url">CSAPP -Cache Lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-20T23:11:27+08:00">
                2018-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Part-B"><a href="#Part-B" class="headerlink" title="Part B"></a>Part B</h3><p>引用<br><a href="https://blog.csdn.net/xbb224007/article/details/81103995?utm_source=blogxgwz0" target="_blank" rel="noopener">https://blog.csdn.net/xbb224007/article/details/81103995?utm_source=blogxgwz0</a></p>
<p><img src="/home/alex/图片/原函数misses过多原因分析.png" alt="upload successl"></p>
<h5 id="2-6就是常说的“抖动”"><a href="#2-6就是常说的“抖动”" class="headerlink" title="2-6就是常说的“抖动”"></a>2-6就是常说的“抖动”</h5><p>就是A，B数组下标相同的元素会映射到同一个cache块当中。</p>
<p>这里不命中本质上是因为访问同一个block的两个元素的时候，由于中间访问了其他块，导致已经加载的块被驱逐，进而导致第二次访问时候不命中。</p>
<p>解决办法： 同时把一个block若干个元素取出来，即省去了中间访问其他块导致驱逐的过程。利用blocking思想</p>
<p>CMU 文章<br><a href="http://csapp.cs.cmu.edu/2e/waside/waside-blocking.pdf" target="_blank" rel="noopener">http://csapp.cs.cmu.edu/2e/waside/waside-blocking.pdf</a></p>
<pre><code>1、A数组访问A[0][0]，冷不命中，将块11装入cache。

 2、B数组访问B[0][0]，虽然B[0][0]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。

 3、A数组访问A[0][1]，虽然A[0][1] 所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。

 4、B数组访问B[1][0]，虽然B[1][0]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。

 5、A数组访问A[0][2]，虽然A[0][2]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。

 6、B数组访问B[2][0]，B[2][0] 所映射的块12不在cache中，冷不命中，将数组B对应的块12装入cache。

 7、A数组访问A[0][3]，A[0][3]所映射的块11在cache中，且标记位相同，故命中。

 8、B数组访问B[3][0]，B[3][0]所映射的块12在cache中，且标记位相同，故命中。

 9、A数组访问A[1][0]，A[1][0]所映射的块11在cache中，且标记位相同，故命中。

 10、B数组访问B[0][1]，虽然B[0][1] 所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。

 11、A数组访问A[1][1]，虽然A[1][1]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。

 12、B数组访问B[1][1]，虽然B[1][1]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组B对应的块11装入cache。

 13、A数组访问A[1][2]，虽然A[1][2]所映射的块11在cache中，但是标记位不同，造成冲突不命中，重新将数组A对应的块11装入cache。

 14、B数组访问B[2][1]，B[2][1] 所映射的块12在cache中，且标记位相同，故命中。

 15、A数组访问A[1][3]，A[1][3]所映射的块11在cache中，且标记位相同，故命中。
</code></pre><h4 id="本实验的Cache"><a href="#本实验的Cache" class="headerlink" title="本实验的Cache"></a>本实验的Cache</h4><p>b = 5,s = 5，E=1</p>
<p>B  =2^b = 2^5 = 32</p>
<p>S  =2^s  =2^5  =32</p>
<p>所以就是有32个块，每个块能存 32 bytes，就是8个int</p>
<h4 id="先分析-32X32"><a href="#先分析-32X32" class="headerlink" title="先分析 32X32"></a>先分析 32X32</h4><p>一行32个元素，所以一行4个block，一共32个block，所以cache能应付8行。</p>
<p>所以每8行就会遇到冲突。<strong>就是两个int之间相差8行的整数倍，那么读取这两个元素所在的block就会发生替换</strong></p>
<p>所以使用 8 * 8 blocking ，这样可以避免冲突</p>
<h5 id="注意处理对角线的情况"><a href="#注意处理对角线的情况" class="headerlink" title="注意处理对角线的情况"></a>注意处理对角线的情况</h5><p>因为矩阵转置之后，A【i,j】 = B【j,i】是相等的。</p>
<p>所以会发生冲突，可以采取的方法是，遇到对角线上的元素先不放到B，等block的其他七个元素写完之后，再把这个元素写到目的地。避免了由于中间加载B块，导致A块被驱逐所引起的命中冲突。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if(M==32)</span><br><span class="line">&#123;   //separate the the 32X32 block into 8X8 , decrease the number of misses</span><br><span class="line">    for(row_Block = 0;row_Block &lt; N ;row_Block+=8)&#123;</span><br><span class="line">        for(col_Block =0 ;col_Block &lt; M; col_Block+=8)&#123;</span><br><span class="line">            for(i=row_Block ; i&lt;row_Block+8;i++)&#123;</span><br><span class="line">                for(j=col_Block;j&lt;col_Block+8;j++)&#123;</span><br><span class="line">                    if(i!=j)&#123;</span><br><span class="line">                        B[j][i] = A[i][j];</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        tmp = A[i][j];                  //i==j means is the diagonal. if we set B right now ,the  misses and evictions will increase . because the cache set of B is same to A.</span><br><span class="line">                        index = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if(col_Block == row_Block)&#123;             //just set B on the diagonal. other than shouldn&apos;t set the B</span><br><span class="line">                    B[index][index] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分析-61-x-67-情况"><a href="#分析-61-x-67-情况" class="headerlink" title="分析 61 x 67 情况"></a>分析 61 x 67 情况</h4><p>尝试 8<em>8,16</em>16,17*17等各种情况即可。</p>
<p>最难的就是</p>
<h4 id="64-X-64-情况"><a href="#64-X-64-情况" class="headerlink" title="64 X 64 情况"></a>64 X 64 情况</h4><p>一行用掉8个block，所以每4行就会发生冲突。</p>
<p>1.先要想清楚，转置的时候，对A数组是按行访问的，而对与B数组是按列访问的。</p>
<p>我们先来分析一下，如果在64 x 64情况下 ，采用8分块，那列访问B的时候，前四行和后四行映射的块是相同的。</p>
<p>所以会发生这种情况：</p>
<p>1.访问前4行第一列之后，再访问后4行的第一列，会发生冲突，使得原来的块被驱逐。</p>
<p>2.再回去访问前四行的第二列，由于原来的块被驱逐，又会导致冲突不命中，</p>
<p>3.访问后4行第二列又产生冲突不命中。</p>
<p>如果采用 4 X 4 分块</p>
<p>对于B 数组而言，访问顺序为<br>前四行前四列-》后四行前四列-》前四行后四列-》后四行后四列</p>
<p><strong><em>这里有点不懂</em></strong></p>
<p>参考文章提到，后四行前四列所在的块会覆盖前四行前四列的块，后面两次访问又会有一次不命中。为什么是2次？不是3次？</p>
<p>因此采取的策略：</p>
<p><img src="/home/alex/图片/qing.png" alt="upload success"></p>
<p><img src="/home/alex/图片/up.png" alt="upload successf"></p>
<p><img src="/home/alex/图片/2018-11.png" alt="filename alread"></p>
<p>按照这个顺序，对于B数组每一个块的元素，只会有一次不命中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">else if(M==64)&#123;</span><br><span class="line">     for (i = 0; i &lt; N; i+=8) &#123;</span><br><span class="line">         for (j = 0; j &lt; M; j+=8) &#123;</span><br><span class="line">             for(x=i;x&lt;i+4;x++)&#123;</span><br><span class="line"></span><br><span class="line">                 x1 = A[x][j];</span><br><span class="line">                 x2 = A[x][j+1];</span><br><span class="line">                 x3 = A[x][j+2];</span><br><span class="line">                 x4 = A[x][j+3];</span><br><span class="line">                 x5 = A[x][j+4];</span><br><span class="line">                 x6 = A[x][j+5];</span><br><span class="line">                 x7 = A[x][j+6];</span><br><span class="line">                 x8 = A[x][j+7];</span><br><span class="line">                 //leftup as usual</span><br><span class="line">                 B[j][x] = x1;</span><br><span class="line">                 B[j+1][x] = x2;</span><br><span class="line">                 B[j+2][x] = x3;</span><br><span class="line">                 B[j+3][x] = x4;</span><br><span class="line">                 B[j][x+4] = x5;</span><br><span class="line">                 B[j+1][x+4] = x6;</span><br><span class="line">                 B[j+2][x+4] = x7;</span><br><span class="line">                 B[j+3][x+4] = x8;</span><br><span class="line">             &#125;</span><br><span class="line">             for(y=j;y&lt;j+4;y++)&#123;</span><br><span class="line">                 </span><br><span class="line">                 x1 = A[i+4][y];</span><br><span class="line">                 x2 = A[i+5][y];</span><br><span class="line">                 x3 = A[i+6][y];</span><br><span class="line">                 x4 = A[i+7][y];</span><br><span class="line">                 x5 = B[y][i+4];</span><br><span class="line">                 x6 = B[y][i+5];</span><br><span class="line">                 x7 = B[y][i+6];</span><br><span class="line">                 x8 = B[y][i+7];</span><br><span class="line"></span><br><span class="line">                 B[y][i+4] = x1;</span><br><span class="line">                 B[y][i+5] = x2;</span><br><span class="line">                 B[y][i+6] = x3;</span><br><span class="line">                 B[y][i+7] = x4;</span><br><span class="line">                 B[y+4][i] = x5; </span><br><span class="line">                 B[y+4][i+1] = x6;</span><br><span class="line">                 B[y+4][i+2] = x7;</span><br><span class="line">                 B[y+4][i+3] = x8;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             for(x = i+4;x&lt;i+8;x++)&#123;</span><br><span class="line">                 x1 = A[x][j+4];</span><br><span class="line">                 x2 = A[x][j+5];</span><br><span class="line">                 x3 = A[x][j+6];</span><br><span class="line">                 x4 = A[x][j+7];</span><br><span class="line"></span><br><span class="line">                 B[j+4][x] = x1;</span><br><span class="line">                 B[j+5][x] = x2;</span><br><span class="line">                 B[j+6][x] = x3;</span><br><span class="line">                 B[j+7][x] = x4;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就是：</p>
<ol>
<li><p>B数组访问前4行</p>
</li>
<li><p>B数组访问前四行后四列，和后四行前四列</p>
</li>
<li><p>B数组最后把后四行后四列转置</p>
</li>
</ol>
<p>我感觉就是先把一行的数据处理完再去处理下一行，尽量不要交替着4行访问数据，这样会导致块被驱逐，加载，增加了总的冲突次数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/15/CSAPP-存储层次结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/15/CSAPP-存储层次结构/" itemprop="url">CSAPP 存储层次结构/Cahce</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-15T06:01:00+08:00">
                2018-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="存储层次结构概况"><a href="#存储层次结构概况" class="headerlink" title="存储层次结构概况"></a>存储层次结构概况</h3><p><img src="/home/alex/图片/ccc.png" alt="image"></p>
<h4 id="存储器的特性"><a href="#存储器的特性" class="headerlink" title="存储器的特性"></a>存储器的特性</h4><h5 id="1-非易失性，即断电后不会丢失数据"><a href="#1-非易失性，即断电后不会丢失数据" class="headerlink" title="1.非易失性，即断电后不会丢失数据"></a>1.非易失性，即断电后不会丢失数据</h5><p><img src="/home/alex/图片/bios.png" alt="bios"></p>
<p>CPU和主存都是易失性，而BIOS和硬盘是非易失的</p>
<p>通电之后CPU通过BIOS芯片开始执行程序，把硬盘配置好后，再从硬盘读取数据搬运到主存，然后CPU才能够执行程序。</p>
<h5 id="2-可读可写"><a href="#2-可读可写" class="headerlink" title="2.可读可写"></a>2.可读可写</h5><h5 id="3-随机访问"><a href="#3-随机访问" class="headerlink" title="3.随机访问"></a>3.随机访问</h5><p>访问数据与其位置无关</p>
<p>主存与BIOS(basic input output system)能够实现随即访问数据。</p>
<p>但是硬盘则不是。</p>
<h5 id="4-访问时间"><a href="#4-访问时间" class="headerlink" title="4.访问时间"></a>4.访问时间</h5><p>主存速度高于硬盘访问时间</p>
<p><img src="/home/alex/图片/DRAM.png" alt="dram"></p>
<p>DRAM读取数据时间是CPU读取时间的一百倍，因此执行一条指令的时候非常的慢！</p>
<p>因此考虑在CPU 和DRAM之间添加一个SRAM，使得CPU所需要的程序和数据大部分时间存放在Cache中，大大缩短执行指令时候所需要的时间周期。</p>
<p><img src="/home/alex/图片/MH.png" alt="MH"></p>
<h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>右下角就是内存条，通常也叫内存模组，是由若干个DRAM芯片组成的，核心就是左图的内存阵列，从外界输入行列信号，就可以读取一个基本存储单元，如红圈每个存储单元有若干个bit，通常是4个或者8个，每一个放大来看如右上角电路图所示。</p>
<p><img src="/home/alex/图片/2018-9.png" alt="a"></p>
<p>基本存储单元</p>
<p><img src="/home/alex/图片/refresh.png" alt="upload successfu"></p>
<p>通过存储的电容来表示存储的bit信息，对SDRAM的读写，主要体现在电容的冲放电，而这个是很难再做提高的。</p>
<p><img src="/home/alex/图片/SRAM.png" alt="upl"></p>
<p>SRAM采取的是晶体管开关存储，远比电容充电放电要快，所以SRAM比DRAM要快，现代CPU的高速缓存通常用SRAM实现</p>
<p><img src="/home/alex/图片/upl2.png" alt="upl2"></p>
<h4 id="内存工作原理"><a href="#内存工作原理" class="headerlink" title="内存工作原理"></a>内存工作原理</h4><p>第一步，申请系统总线，获得总线控制权后，会把地址送到内存控制器中。</p>
<p>然后内存控制器会把地址分解为行地址和列地址</p>
<p><img src="/home/alex/图片/SDRAM.png" alt="SDRAM"></p>
<p>第二步 行访问</p>
<p>内存控制器向SDRAM发起访存操作</p>
<p><img src="/home/alex/图片/hangfangwen.png" alt="SDRAM2"></p>
<p>这一行当中所有存储单元的信号通过放大器之后会放在一个缓冲区当中。这就是激活/行访问</p>
<p>第三步 列访问<br><img src="/home/alex/图片/column.png" alt="COLUMN"></p>
<p>第四步 送回CPU</p>
<p><img src="/home/alex/图片/CAIYANG.png" alt="CAIYANG"></p>
<p>内存控制器把采样到的数据送回给CPU</p>
<p>CPU之后又发送地址信号，如果不是同一行，则就要把激活的行关闭。</p>
<p>这个过程叫做预充电</p>
<h5 id="SDRAM的关键性能参数："><a href="#SDRAM的关键性能参数：" class="headerlink" title="SDRAM的关键性能参数："></a>SDRAM的关键性能参数：</h5><p>1.tRCD row to column delay  从行选到列选的延迟时间</p>
<p>2.CL CAS Latency  从列选到数据输出的延迟周期数</p>
<p>3.tRP 行预充电时间</p>
<p>数据个数就等同于内存条上DRAM芯片个数<br><img src="/home/alex/图片/gap.png" alt="upload successfu"></p>
<p>所以整个过程的周期并不等于7.5ns！</p>
<p>DDR SDRAM 比 SDR SDRAM 要快，原因是前者一次能比后者取多两倍的数据</p>
<p>DDR是数据传输的方式，不等同于内存</p>
<p><img src="/home/alex/图片/data.png" alt="upload successf"></p>
<h5 id="DDR-与-SDR-对比"><a href="#DDR-与-SDR-对比" class="headerlink" title="DDR 与 SDR 对比"></a>DDR 与 SDR 对比</h5><p><img src="/home/alex/图片/DDR.png" alt="ddr"></p>
<p>DDR由于一次读取两个数据，所以tRCD和CL变慢了，但是每个周期能同时取两个数据。<br>这里的带宽就是由每个周期取得的数据计算出来的。</p>
<p>衡量CPU有两个指标</p>
<h6 id="访存带宽"><a href="#访存带宽" class="headerlink" title="访存带宽"></a>访存带宽</h6><p>单位时间内存储器所存取的信息量。</p>
<h6 id="访存延迟"><a href="#访存延迟" class="headerlink" title="访存延迟"></a>访存延迟</h6><p>读出第一个数据所需要的时间。</p>
<h4 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h4><h5 id="空间局部性："><a href="#空间局部性：" class="headerlink" title="空间局部性："></a>空间局部性：</h5><p>空间局部性是一旦一个指令一个存储单元被访问，那么它附近的单元也将很快被访问</p>
<h5 id="时间局部性："><a href="#时间局部性：" class="headerlink" title="时间局部性："></a>时间局部性：</h5><p>时间局部性是一旦一个指令被执行了，则在不久的将来，它可能再被执行。</p>
<p><img src="/home/alex/图片/a.png" alt="uploa"></p>
<p><img src="/home/alex/图片/cache.png" alt="upload succ"></p>
<h5 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h5><p><img src="/home/alex/图片/cao.png" alt="uploa"></p>
<p>怎么把虚拟地址转化为实际地址是个问题</p>
<h5 id="Cache读操作"><a href="#Cache读操作" class="headerlink" title="Cache读操作"></a>Cache读操作</h5><p>1.第一条指令，由于一开始Cache是空的，所以没有命中。因此Cache访问主存。</p>
<p>之所以分配给表项1，是由地址倒数第二个数字决定的。（不看H）</p>
<p>然后前面的所有项(20)放到标签处。</p>
<p><img src="/home/alex/图片/2018-10.png" alt="filename already exists, ren"></p>
<p>2.第二种情况，没有命中，因为表被占用了。</p>
<p>4011H，先检查有效位1，发现原来标签是20H，因此把地址替换掉。</p>
<p><img src="/home/alex/图片/oc.png" alt="upload success"></p>
<h5 id="Cache写操作"><a href="#Cache写操作" class="headerlink" title="Cache写操作"></a>Cache写操作</h5><p><img src="/home/alex/图片/write.png" alt="write"></p>
<h4 id="平均访存时间"><a href="#平均访存时间" class="headerlink" title="平均访存时间"></a>平均访存时间</h4><p><img src="/home/alex/图片/memory.png" alt="visit"></p>
<p><img src="/home/alex/图片/策略.png" alt="upload successfu"></p>
<p>Cache映射策略，直接映射会遇到这么一个问题：</p>
<p>就是存储器会每隔八个地址把数据映射到Cache中，如果程序交替访问这两个数据，那么每次访问都会访问主存，把地址写入到Cache中，这样性能比没有Cache的时候还要差。</p>
<p>也可以通过二路组，四路组相联策略，但是代价是每次取数据的时候，要取多个标签比较，如直接映射只需要取一个标签出来，如图中的0，而二路组则要2个。而且这样会使得硬件电路变得复杂化，增加了命中时间，得不偿失。</p>
<p><img src="/home/alex/图片/visi.png" alt="upload succe"></p>
<h4 id="常见Cache替换算法"><a href="#常见Cache替换算法" class="headerlink" title="常见Cache替换算法"></a>常见Cache替换算法</h4><p><img src="/home/alex/图片/x86.png" alt="upload succ"></p>
<p>LRU的实现：</p>
<p>1.队列</p>
<p>2.用LRUnumber，例如初始化每块的LRUnumber为0，当要访问这块Cache的时候重新设置为0，然后其他块++1，然后LRUnumber最大的那个block就是最近最少使用的块。</p>
<p>计算机领域单位使用情况</p>
<p><img src="/home/alex/图片/dan.png" alt="upload succesful"></p>
<h3 id="Cache-映射"><a href="#Cache-映射" class="headerlink" title="Cache 映射"></a>Cache 映射</h3><h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="/home/alex/图片/mapping.png" alt="map"></p>
<p>Cache 大小：</p>
<p>假设每个槽，就是cache的每个block能装512个(2^9)byte，说明b = 9</p>
<p>然后一共有16个sets，说明 s = 4，</p>
<p>因此cache地址一共是（s+b = 13位）</p>
<p>主存的第0块，第16块，第32块。。都能放在cache的0槽当中，但是怎么知道<br>是哪个块群的呢?因此用标记号来说明，那么标记号该有几位？就是块群的个数2^7=128</p>
<p>所以标记号就是7位，标记号用来指出对应行来自于哪个块群。</p>
<p>主存大小：<br>2048 块 <em> 512B/块 = 2^11 </em> 2^ 9 = 2^20</p>
<p>所以主存地址一共20位，包含了9位的块内地址，4位cache索引，剩下7位主存标记。<br>主存一共2048（2^11）块，所以主存标记和cache索引用来标记主存的具体块号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例如：给定地址 0220CH</span><br><span class="line"></span><br><span class="line">转化为二进制 0000 0010 0001 0000 1100</span><br><span class="line"></span><br><span class="line">前7位 0000 001  决定来自于块群 1</span><br><span class="line"></span><br><span class="line">中间4位 0001 决定来自块群的具体哪个块  第一块</span><br><span class="line"></span><br><span class="line">后面9位，块内地址 决定了块内的哪个单元 第12个单元</span><br></pre></td></tr></table></figure>
<p><strong>所以大概过程</strong></p>
<p>拿来一个主存地址，然后划分为三段，根据中间索引号来寻找cache对应槽，然后看<br>valid位和标记位，如果valid=0，说明里面是空的，冷不命中，要从主存把地址送过来。如果valid=1，而且主存标记刚好是标记位，就根据块内地址在槽内寻找对应单元。</p>
<p><img src="/home/alex/图片/youxiao.png" alt="upload succeul"></p>
<p>给定32位主存地址，划分为三部分。</p>
<p>首先由于块大小为16（2^4）B，因此b = 4,偏移位 4位</p>
<p>索引位呢？  中间的索引位决定于cache有多少行</p>
<p>因此行数=64KB/16B = 4K = 2^12 行</p>
<p>因此中间索引位一共有12位</p>
<p>剩下16位就是tag位，标记位</p>
<p>给定内存地址，先由中间12行找到cache对应的行，看tag位与valid位是否满足条件，（valid=1说明这一行有数据）满足条件就hit，hit了就根据偏移位寻找对应的数据。</p>
<p>块大小位16B，即128bit，使用多路选择器MUX来选择取哪个32位的data。</p>
<p>11 最左边 10 中左 01 中右 00最右边</p>
<p>如果取的是int型（word），由于word alignment，即内存地址最后的两位其实是不需要理会的。那么只看第三第四位，就是所谓的block offset。决定所取int放在哪个block.</p>
<p>而如果要取的是char型，要在取了word之后再通过一个MUX，根据主存地址最后两位（Byte Offset）来得到要取哪个byte。</p>
<p><img src="/home/alex/图片/ex.png" alt="upload successl"></p>
<h3 id="cache-容量"><a href="#cache-容量" class="headerlink" title="cache 容量"></a>cache 容量</h3><p>上图中容量为  行数 X（每一行的bit数）</p>
<p>（16+1）<em>4K + 64K </em> 8 = 72.5KB</p>
<p>数据 64KB/72.5KB   =88.3%</p>
<p>有一个64行，块容量为16bytes的cache</p>
<p>十进制地址 1200应该映射到哪一行？</p>
<p>方法一： 【1200/16】mod 64  = 11</p>
<p>方法二： 1200转换为二进制 0100 1011 0000</p>
<p>索引号 = 6 ，即看中间存的是哪一行，001011 就是 11</p>
<p>实现一个直接映射，16K行数据，块大小为1个字（4B），32位主存地址的cache需要多少容量？</p>
<p>16K = 2^14 行数据，即中间索引有14位</p>
<p>byte =4B ，b = 2</p>
<p>所以tag = 32-2-14  =16</p>
<p>因此16K<em>（1+16）+16K</em>4B  =16K*(1+16+32)  =784Kbits<br>(1+16)中，1是valid位</p>
<p>特点</p>
<p><img src="/home/alex/图片/quan.png" alt="upload succesl"></p>
<h4 id="全相联映射方式"><a href="#全相联映射方式" class="headerlink" title="全相联映射方式"></a>全相联映射方式</h4><p><img src="/home/alex/图片/this.png" alt="upload successf"></p>
<p>给定地址，根据标记主存块号找到数据所在主存的哪一块，00000001111就是第15块，但是不知道在Cache的哪个槽中，所以只能一个一个槽比较。所以叫按内容访问。</p>
<p>为什么没有cache索引字段？</p>
<p>因为其可以任意映射到某一个行当中.</p>
<p><img src="/home/alex/图片/2018-16.png" alt="filename already exists, remed"></p>
<p>优点就是没有冲突，时间相对加快，但是tag长了，而且每一行都有一个比较器，比较时间长了，相当于命中时间会加长，而且比较成本也增加了，cache容量也变大了！</p>
<p><img src="/home/alex/图片/ans.png" alt="upload successf"></p>
<p>前8位标记表示cache属于哪个组群</p>
<p>中间3位表示属于哪个组</p>
<p>后面9位表示偏移量，表示要找到那个数据</p>
<p>Eg: 地址 0000 0001 001 00000 1100</p>
<p>前8位表示在第一组群 中间三位（cache索引）表示cache的第一个set  ，就是第一个族群的第001块，就是第九块，把这一块映射到cache的第一组当中。</p>
<p><img src="/home/alex/图片/2018-17.png" alt="filename already exists, renam"></p>
<p>两个比较器并向同时比较，最多有一个cache的tag与主存地址的tag相同，OR选择器的结果就是hit的结果。</p>
<p>通过多路选择器把所要找的cache data的block找出来！</p>
<p><img src="/home/alex/图片/bome.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/zombi.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/over.png" alt="upload succes"></p>
<p><img src="/home/alex/图片/inyourhead.png" alt="upload succe"></p>
<p>顺便讲一下什么叫按字节编址，按字编址。</p>
<p>字 word = 4byte</p>
<p>字节 byte = 8bit</p>
<p>位 bit</p>
<p><img src="/home/alex/图片/ra.png" alt="upload success"></p>
<p><img src="/home/alex/图片/shell.png" alt="upload succe"></p>
<p><img src="/home/alex/图片/sudden.png" alt="upload succes"></p>
<p><img src="/home/alex/图片/animal.png" alt="upload succesl"></p>
<p><img src="/home/alex/图片/am.png" alt="upload success"></p>
<p><img src="/home/alex/图片/dlearning.png" alt="upload succe"></p>
<p><img src="/home/alex/图片/today.png" alt="upload successf"></p>
<p>上面的图怎么看？</p>
<pre><code>1. 每一block64个字。访问第0block，冷不命中，放到第0组。那哪一行呢？都可以，一般按照顺序来，因此放在第0组第0行。然后第0组所有元素就都在第0组第0行中取。
2. 然后访问第1组，冷不命中，放在第1组第0行。第0，16，32，48block都放在第0组，分别放在第0，1，2，3行。
3. 当取到第64block的时候，miss，根据LRU把第0组行第0行替换掉。一直到第67block结束第一次循环。
4. 然后来到第二次循环，想要找第0组，但是已经被刚才第64组替换掉了，而且第0block只能放在第0组，因此根据LRU，替换掉第0组第一行，一直到第四个block的时候，这时候第4block放在第4组的的第0行，没有miss。
5. 由于第16，17，18，19个block已经被替换，当访问第16,17,18,19个block的时候，根据LRU，分别吧0，1，2，3组的第二行的32，33，34，35block替换。同理，当访问32，33，34，35block的时候，又把第三行的48495051替换。同理，访问48，49，50，51的时候，又miss，又把第一行的对应64，65，66，67替换掉。
6. 所以第二次-第九次循环，每次都有5*4=20次miss
</code></pre><p>命中率： (43520-68-9*20)/43520 = 99.43%</p>
<h4 id="Cache读和写的一致性问题"><a href="#Cache读和写的一致性问题" class="headerlink" title="Cache读和写的一致性问题"></a>Cache读和写的一致性问题</h4><p><img src="/home/alex/图片/we.png" alt="upload successl"></p>
<p><img src="/home/alex/图片/way.png" alt="upload succeful"></p>
<p>同时写cache和主存，但是主存要慢得多，这样写完了cache之后要等待主存。<br>所以可以增加一个buffer 写缓冲。<br>就是CPU可以把数据写到cache中。写完了之后不等写道主存，继续写cache，写到主存的工作就交给write buffer，由memory controller传回到DRAM</p>
<p><img src="/home/alex/图片/para.png" alt="upload successf"></p>
<p><img src="/home/alex/图片/haleluya.png" alt="upload successful"></p>
<p><img src="/home/alex/图片/hale.png" alt="upload successful"></p>
<p>写穿透就是同时写cache和主存，写分配就是同时更新主存和cache<br>Write Trough 算法<br>如果能够找到i，使得TAG（i） == X,<br>如果是读操作，就直接返回块内地址DATA[i]；<br>写操作就除了要写块内地址，还要写主存</p>
<p>如果miss掉<br>读操作就是读主存的数据，然后打标签，送到cache<br>写操作就是先写主存，然后打标签，最后在块内new一个新的数据</p>
<p>Cache越大越好，命中率越高，但是越大的话成本越高<br>Block 不能太大，也不能太小</p>
<h4 id="Cache-数目"><a href="#Cache-数目" class="headerlink" title="Cache 数目"></a>Cache 数目</h4><p><img src="/home/alex/图片/shumu.png" alt="upload successl"></p>
<p>L1，分立cache，为了实现流水线，同时取数据和指令，提高并行性。</p>
<p>第二个问题：<br>因为他有L1，L2两个cache，即使不命中也没有关系</p>
<p>第三个问题：最后Level的cache与指令流无关，不需要考虑并行。因此优先考虑空间的利用率，同时命中率比命中时间更重要。</p>
<p>L1比L2容量小，（越大命中率越高）比L2快，命中时间短，如果L1不命中，只好寄托在L2身上，因此L2的命中率就显得特别重要。</p>
<h4 id="Cache-实现举例"><a href="#Cache-实现举例" class="headerlink" title="Cache 实现举例"></a>Cache 实现举例</h4><p>用2个状态位：</p>
<pre><code>S: SHARE
E：EXCLUSIVE
M: MODIFIED （是否dirty bit）
VALID 是否有效
</code></pre><p>LRU用1位： </p>
<p><img src="/home/alex/图片/silence.png" alt="upload succel"></p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="/home/alex/图片/eg.png" alt="upload successful"></p>
<h5 id="1-不考虑一致性：dirty-bit-；替换控制即LRU位"><a href="#1-不考虑一致性：dirty-bit-；替换控制即LRU位" class="headerlink" title="1. 不考虑一致性：dirty bit ；替换控制即LRU位"></a>1. 不考虑一致性：dirty bit ；替换控制即LRU位</h5><p>256MB 表示主存地址 28位</p>
<p>64B – b = 6</p>
<p>Cache 8行 -中间索引位 3</p>
<p>Tag位 19位 别忘了要考虑valid位</p>
<p>（1+19）<em>8 + 64</em>8*8 （每行一个block）(64B是64byte，1byte 8 bits)</p>
<h5 id="2-64B-16个元素-一行16个元素"><a href="#2-64B-16个元素-一行16个元素" class="headerlink" title="2. 64B-16个元素 一行16个元素"></a>2. 64B-16个元素 一行16个元素</h5><p>A[0][31] 地址 320+4*31 = 444 [444/64] = 6</p>
<p>因此主存块号为6，6mod8 = 6因此在第六行。</p>
<p>或者444 为0000110111100B 中间三位是索引位，就是第六行</p>
<p>而A[1][1] = (320+256*4+8 )/64 mod 8=5 同理也可以把地址转化为二进制来计算。</p>
<h5 id="3-A-每隔16元素一次冷不命中，命中率（15-16）"><a href="#3-A-每隔16元素一次冷不命中，命中率（15-16）" class="headerlink" title="3.A 每隔16元素一次冷不命中，命中率（15/16）"></a>3.A 每隔16元素一次冷不命中，命中率（15/16）</h5><p>B 每次相隔256个元素，256/16 = 16 块，16mod 8=0，每次访问后面数组元素的时候，总会把上一次装入到cache中的主存块覆盖掉。</p>
<p>所以每次访问的时候都会发生冲突，替换，因此没有一次命中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/12/Program-Optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/Program-Optimization/" itemprop="url">Program Optimization && Pipeline &&Architecture Lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-12T07:39:00+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ICS/" itemprop="url" rel="index">
                    <span itemprop="name">ICS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="General-Useful-Optimizations"><a href="#General-Useful-Optimizations" class="headerlink" title="General Useful Optimizations"></a>General Useful Optimizations</h3><h4 id="Code-Motion"><a href="#Code-Motion" class="headerlink" title="Code Motion"></a>Code Motion</h4><h5 id="reduce-the-frequency-where-computation-performed"><a href="#reduce-the-frequency-where-computation-performed" class="headerlink" title="reduce the frequency where computation performed"></a>reduce the frequency where computation performed</h5><p><img src="/home/alex/图片/ics1.png" alt="ics1"></p>
<p>try to use shift,add to replace multiply</p>
<h4 id="Reduction-on-strength"><a href="#Reduction-on-strength" class="headerlink" title="Reduction on strength"></a>Reduction on strength</h4><p><img src="/home/alex/图片/ics2.png" alt="ics2"></p>
<p>leaq (%rsi,%rcx),%rcx means %rcx = %rcx+%rsi</p>
<p>%rcx now is n  </p>
<p>%rsi now is i*n+j</p>
<h4 id="Share-common-Subexpressions"><a href="#Share-common-Subexpressions" class="headerlink" title="Share common Subexpressions"></a>Share common Subexpressions</h4><p><img src="/home/alex/图片/ics3.png" alt="ics3"></p>
<p>#### </p>
<p>possibly the memory of A and B overlap and the change of B might affect A</p>
<p><img src="/home/alex/图片/ics4.png" alt="ics4"></p>
<p>Memory aliasing, closely related (arguably synonymous) to pointer aliasing, means that more than one variable name points to the same underlying stored value. </p>
<h4 id="Benchmark-Computation"><a href="#Benchmark-Computation" class="headerlink" title="Benchmark Computation"></a>Benchmark Computation</h4><p>Cycles Per Element(CPE)</p>
<p>Length = n</p>
<p>CPE  =cycles per OP</p>
<p>T = CPE*n+Overhead??  what is overhead?</p>
<p><img src="/home/alex/图片/ics7.png" alt="ics7"></p>
<p><img src="/home/alex/图片/ics5.png" alt="ics5"></p>
<p>You don’t need to use get_vec in each loop,so avoid bound checking</p>
<p><img src="/home/alex/图片/ics6.png" alt="ics6"></p>
<h3 id="流水线的冒险"><a href="#流水线的冒险" class="headerlink" title="流水线的冒险"></a>流水线的冒险</h3><p>阻止下一条指令在下一个时钟周期开始执行的情况</p>
<p>1.结构冒险</p>
<p>所需要的硬件部件正在为之前的指令工作</p>
<p>2.数据冒险</p>
<p>需要等待之前的指令来完成数据的读写</p>
<p>3.控制冒险</p>
<p>需要根据之前指令的结果决定下一步的行为</p>
<h4 id="结构冒险"><a href="#结构冒险" class="headerlink" title="结构冒险"></a>结构冒险</h4><p>执行指令的硬件发生争抢</p>
<p><img src="/home/alex/图片/ics10.png" alt="ics10"></p>
<h6 id="解决方案一：-冒泡停顿"><a href="#解决方案一：-冒泡停顿" class="headerlink" title="解决方案一：  冒泡停顿"></a>解决方案一：  冒泡停顿</h6><p>但如果连续出现冒泡停顿，则会影响指令执行的效率</p>
<p><img src="/home/alex/图片/ics11.png" alt="ics11"></p>
<h6 id="解决方案二：-把数据和指令放在不同的存储器"><a href="#解决方案二：-把数据和指令放在不同的存储器" class="headerlink" title="解决方案二：  把数据和指令放在不同的存储器"></a>解决方案二：  把数据和指令放在不同的存储器</h6><p>但值得注意的是，冯诺伊曼结构要求内存（主存储器）同时存放<br>数据和指令，而只是在CPU的高速缓存（cache）当中，数据和指令可以分开存放</p>
<p>这个在设计CPU就已经处理好了，但是如果要设计一个新的处理器，这是一个要考虑的问题</p>
<p><img src="/home/alex/图片/ics12.png" alt="ics12"></p>
<h4 id="数据冒险"><a href="#数据冒险" class="headerlink" title="数据冒险"></a>数据冒险</h4><p>解决方法1：<br><img src="/home/alex/图片/ics13.png" alt="ics13"></p>
<p>解决方法2：</p>
<p>冲突产生原因是add 指令 需要 read 上一条指令write的结果（$t0）</p>
<p>但其实，$t0的值已经在ALU阶段就已经计算好，而add指令中，其实不是非得在<br>R阶段读$t0，只要在ALU阶段读取到数值就行。</p>
<p>那么就可以在sub指令中，把ALU计算得到的结果$t0送到流水线寄存器当中，<br>然后再送到add指令的ALU中。</p>
<p><img src="/home/alex/图片/ics15.png" alt="ics15"></p>
<p>从硬件角度来看，我们要这样修改：</p>
<p><img src="/home/alex/图片/ics16.png" alt="ics16"></p>
<p>sub先执行，所以在前面，add后执行，所以在后面</p>
<p>add指令需要用到前一条指令的结果，因此设置了绿色的旁路，<br>以是否有数据冒险情况作为激活信号。</p>
<p><img src="/home/alex/图片/ics17.png" alt="ics17"></p>
<p>第二种情况</p>
<p>对应下图</p>
<p><img src="/home/alex/图片/ics18.png" alt="ics18"></p>
<p>第三条指令需要用到第一条指令得到的结果，第一条的$t0在DMEM与write back阶段之间，所以呢，就是对应上上图，在访存阶段末期，通过旁路把数据传回给ALU</p>
<p>如果 instruction 3也需要用到$t0，因为R阶段之前，第一条指令刚好完成了write back，因此可以正常运行</p>
<h5 id="load-use冒险，不能用数据前递来解决"><a href="#load-use冒险，不能用数据前递来解决" class="headerlink" title="load-use冒险，不能用数据前递来解决"></a>load-use冒险，不能用数据前递来解决</h5><p>如下图，因为or需要用到上一条指令的$t1,但是or至少要在ALU阶段读取$t1的数值，然而lw只能在完成了访存阶段后才能把结果写回到$t1,因此只能通过冒泡来延后or指令的执行时间了。</p>
<p><img src="/home/alex/图片/ics19.png" alt="ics19"></p>
<h4 id="控制冒险"><a href="#控制冒险" class="headerlink" title="控制冒险"></a>控制冒险</h4><p>要到ALU阶段才能决定是否要取分支</p>
<p><img src="/home/alex/图片/ics14.png" alt="ics14"></p>
<h5 id="转移指令对流水线的影响"><a href="#转移指令对流水线的影响" class="headerlink" title="转移指令对流水线的影响"></a>转移指令对流水线的影响</h5><p><img src="/home/alex/图片/ics21.png" alt="ics21"></p>
<p>beq指令只有在进行完执行（ALU）阶段之后才能确定是否发生跳转，加入跳转条件成立，则说明lw sw是不应该取的。这时跳回sub指令，导致性能被浪费。</p>
<h5 id="转移指令的分类"><a href="#转移指令的分类" class="headerlink" title="转移指令的分类"></a>转移指令的分类</h5><p><img src="/home/alex/图片/ics22.png" alt="ics22"></p>
<h6 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h6><p>j指令在取指的时候就能判断是否为j指令，然后取出后26位，加上末两位的00，<br>然后在PC - update 阶段就能取PC+4的前四位，这些操作都能在一个时钟周期内完成。</p>
<p><img src="/home/alex/图片/ics23.png" alt="ics23"></p>
<p><img src="/home/alex/图片/ics24.png" alt="ics24"></p>
<p><img src="/home/alex/图片/ics25.png" alt="ics25"></p>
<p><img src="/home/alex/图片/ics26.png" alt="ics26"></p>
<p>译码阶段进行R【rs】，R【rt】的读取，在执行阶段进行两数的比较<br><img src="/home/alex/图片/ics27.png" alt="ics27"></p>
<p>但实际上进行减法不需要ALU那么复杂的部件，可以在译码阶段进行一点小改动</p>
<p><img src="/home/alex/图片/ics28.png" alt="ics28"></p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><img src="/home/alex/图片/ics29.png" alt="ics29"></p>
<p>为了避免停顿，可以把转移指令的前一条与转移指令无关的指令（xor）移到转移指令的下一条。</p>
<p><img src="/home/alex/图片/delay.png" alt="ics30"></p>
<h3 id="Arch-Lab"><a href="#Arch-Lab" class="headerlink" title="Arch Lab"></a>Arch Lab</h3><p>Part C </p>
<p>利用循环展开技术与加载使用冒险</p>
<p>加载使用冒险：</p>
<p><img src="/home/alex/图片/bubble.png" alt="bb"></p>
<p>因此可以在mrmovl后添加另外一条mrmovl指令，来抵消流水线停顿，同时也使得下一次操作提前取值。</p>
<p>循环展开大意就是减少循环次数，在每次循环的时候同时进行多次操作。同时也可以配合并行，并行就是例如把每次累加操作的的结果分为两部分，如奇数项累加成S1，偶数项累加成S2，最后结果就是S1+S2。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#You can modify this portion</span><br><span class="line">    # Loop header</span><br><span class="line">    xorq %rax,%rax      # count = 0;</span><br><span class="line">    iaddq $-2,%rdx</span><br><span class="line">    andq %rdx,%rdx      # len &lt;= 0?</span><br><span class="line">    jl newLoop      # if so, goto Done:</span><br><span class="line"></span><br><span class="line">Loop:   mrmovq (%rdi), %r10 # read val from src...</span><br><span class="line">    mrmovq 8(%rdi),%r11</span><br><span class="line">    rmmovq %r10, (%rsi) # ...and store it to dst</span><br><span class="line">    andq %r10, %r10     # val &lt;= 0?</span><br><span class="line">    jle Npos        # if so, goto Npos:</span><br><span class="line">    iaddq $1, %rax      # count++</span><br><span class="line">Npos:</span><br><span class="line">    rmmovq %r11,8(%rsi)</span><br><span class="line">    andq %r11,%r11</span><br><span class="line">    jle judge</span><br><span class="line">    iaddq $1,%rax</span><br><span class="line"></span><br><span class="line">judge:</span><br><span class="line">    iaddq $16,%rdi</span><br><span class="line">    iaddq $16,%rsi</span><br><span class="line">    iaddq $-2,%rdx</span><br><span class="line">    jge Loop</span><br><span class="line"></span><br><span class="line">newLoop:</span><br><span class="line">    iaddq $2,%rdx</span><br><span class="line">    je Done</span><br><span class="line">    mrmovq (%rdi),%r10</span><br><span class="line">    rmmovq %r10,(%rsi)</span><br><span class="line">    andq %r10,%r10</span><br><span class="line">    jle Done</span><br><span class="line">    iaddq $1,%rax</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/10/09/CSAPP-第四章-处理器体系结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/09/CSAPP-第四章-处理器体系结构/" itemprop="url">CSAPP 第四章 处理器体系结构——Y86流水线基本原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-09T03:18:00+08:00">
                2018-10-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Y86-流水线的实现"><a href="#Y86-流水线的实现" class="headerlink" title="Y86 流水线的实现"></a>Y86 流水线的实现</h2><h3 id="PC的计算"><a href="#PC的计算" class="headerlink" title="PC的计算"></a>PC的计算</h3><p>在非流水线结构中，计算PC是在时间周期结束的时候进行的。</p>
<p>而在流水线实现中，计算PC作为指令执行的第一步。</p>
<h3 id="Fetch-阶段"><a href="#Fetch-阶段" class="headerlink" title="Fetch 阶段"></a>Fetch 阶段</h3><p>三种情况：</p>
<p>1.预测错误，从流水线寄存器M（M_valA）读出该指令valP的数值，即下一条指令的地址。</p>
<p>2.RET 指令 W_valM 从流水线寄存器读出返回地址（访存）。</p>
<p>3.其他情况会使用存放在流水线寄存器F中的PC的预测值。</p>
<p>HCL代码如下：</p>
<p><img src="/home/alex/图片/2018-7.png" alt="ics24"></p>
<p>其中 f_predPC</p>
<p><img src="/home/alex/图片/ICS22.png" alt="ics22"></p>
<p>exercises:</p>
<p>写出 f_stat的HCL代码，提供取出指令的临时状态</p>
<p>word f_stat = </p>
<p>f_icode == IHALT : SHLT</p>
<p>mem_error : SADR</p>
<p>!instr_valid : SINS</p>
<p>1: SAOK</p>
<h3 id="译码和写回阶段"><a href="#译码和写回阶段" class="headerlink" title="译码和写回阶段"></a>译码和写回阶段</h3><h4 id="dsrc-A"><a href="#dsrc-A" class="headerlink" title="dsrc_A"></a>dsrc_A</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">word dsrc_A =</span><br><span class="line"></span><br><span class="line">DICODE in &#123;IRRMOVQ,IRMMOVQ,IPUSHQ,IOPQ&#125; : D_rA</span><br><span class="line"></span><br><span class="line">DICODE in &#123;IPOPQ,IRETURN&#125; : RRSP</span><br><span class="line"></span><br><span class="line">1: RNONE</span><br></pre></td></tr></table></figure>
<h5 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h5><p>RRMOVQ，RMMOVQ source A的值来自于寄存器A</p>
<p>而push 实际上就是</p>
<p>subl $4,%esp</p>
<p>movl %ebp,(%esp)</p>
<p>call实际上是 push+jump,先把返回地址（此时存放在EIP中）push进%ebp，<br>然后再jump到要执行指令的地址</p>
<h5 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h5><p>而POP指令实际上是 </p>
<p>movl (%esp),%eip //eip寄存器是保存CPU所要读取指令地址的寄存器</p>
<p>addl $4,%esp</p>
<h5 id="return"><a href="#return" class="headerlink" title="return"></a>return</h5><p>return 实际上是 把栈顶地址弹出到EIP，然后按照EIP指示的指令地址继续执行程序</p>
<p>需要用到栈指针来作为source A</p>
<h5 id="dsrc-B"><a href="#dsrc-B" class="headerlink" title="dsrc_B"></a>dsrc_B</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">word d_srcB = </span><br><span class="line"></span><br><span class="line">DICODE IN &#123;IOPQ，IMRMOVQ，IRMOVQ&#125; ：d_srcB</span><br><span class="line">DICODE IN &#123;IPUSHQ,IPOPQ,IRET,ICALL&#125; ：RRSP</span><br><span class="line">1:RNONE</span><br></pre></td></tr></table></figure>
<h5 id="dstE"><a href="#dstE" class="headerlink" title="dstE"></a>dstE</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">word d_dstE = </span><br><span class="line"></span><br><span class="line">// 目的寄存器是rB而且存储的是由数值运算得到的结果</span><br><span class="line"></span><br><span class="line">DICODE IN &#123;IOPQ,IIRMOVQ,IRRMOVQ&#125; : D_rB:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//因为pushq,popq都需要涉及到</span><br><span class="line"></span><br><span class="line">push: subl $4,%rsp</span><br><span class="line">pop : addl $4,%rsp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DICODE IN &#123;IPUSHQ,IPOPQ,IRET,ICALL&#125;： RRSP</span><br><span class="line"></span><br><span class="line">1： RNONE</span><br></pre></td></tr></table></figure>
<h5 id="dstM"><a href="#dstM" class="headerlink" title="dstM"></a>dstM</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DICODE IN &#123;IMRMOVQ,IPOPQ&#125;: R_rA</span><br><span class="line"></span><br><span class="line">1: RNONE</span><br></pre></td></tr></table></figure>
<h5 id="d-valA"><a href="#d-valA" class="headerlink" title="d_valA"></a>d_valA</h5><p>这五个转发源存在优先级，通常流水线的实现总是给处于最早的流水线阶段中的转发源以较高的优先级。</p>
<p><img src="/home/alex/图片/2018-8.png" alt="ics25"></p>
<p>只有pop指令关心访存或者写回阶段的两个源之间的优先级</p>
<p>pop 指令看作是 </p>
<p>movl (%rsp) , %rsp</p>
<p>addl $4,%rsp</p>
<p>因为默认 m_valM 访存的优先级 大于 M_valE 计算的优先级<br>因此加入下一条指令是</p>
<p>movl %rsp, %rax</p>
<p>则会把%rsp+4 之前的值传到%rax，满足x86的pop操作规定</p>
<h5 id="aluA"><a href="#aluA" class="headerlink" title="aluA"></a>aluA</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">word aluA = [</span><br><span class="line">   E_icode in &#123;IRRMOVQ,IOPQ&#125; : E_valA</span><br><span class="line">   E_icode in &#123;IIRMOVQ,IRMMOVQ,IMRMOVQ&#125; : E_valC</span><br><span class="line">   E_icode in &#123;ICALLQ, IPUSHQ&#125; : -8 //如果是iaddl 就是-4</span><br><span class="line">   E_icode in &#123;IPOPQ,IRETQ&#125; : 8</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h5 id="aluB"><a href="#aluB" class="headerlink" title="aluB"></a>aluB</h5><p><img src="/home/alex/图片/ics30.png" alt="ics30"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/09/11/CSAPP-程序及指令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/CSAPP-程序及指令/" itemprop="url">CSAPP-程序及指令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-11T05:16:00+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CPU的基本结构与功能"><a href="#CPU的基本结构与功能" class="headerlink" title="CPU的基本结构与功能"></a>CPU的基本结构与功能</h2><p><img src="/home/alex/图片/prog.png" alt="image"></p>
<p>CPI （Cycles Per Instruction）用于衡量电脑的性能<br>，指每条指令的时钟数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPI=TC/IC</span><br></pre></td></tr></table></figure>
<p>表示某个程序的所有指令的条数；TC表示执行某个程序所花费的时钟周期)</p>
<p><img src="/home/alex/图片/under.png" alt="image"><br>加深理解：<br>M【R【ebp】+8】指的是命令行参数首个地址，即char *str的地址，M【地址】等于在内存中取值，相当于这个就是strcpy的第二个实际参数str</p>
<p>而R【ebp】-16 意思就是buffer[0]，即buffer的首地址</p>
<p><img src="/home/alex/图片/7.png" alt="image"></p>
<p>红线下面都是在CPU了里面进行操作</p>
<p>红线上面都是通过总线在外面进行操作</p>
<p><img src="/home/alex/图片/lalala.png" alt="image"></p>
<p><img src="/home/alex/图片/MIPS.png" alt="image"></p>
<p>笔记：</p>
<p>取值令和PC+“1” 是并行的，（同时操作），“1”指一条指令的长度</p>
<p>在MIPS中，每个指令都是定长的，32位，占4位，因此实际上是PC+4</p>
<p>而在X86中，每个指令都不是定长的，是边长的，一定要在指令译码之后才能确定指令有多长</p>
<p>异常和指令区别：</p>
<p>异常指和处理中的这条指令有关的的问题</p>
<p>中断指和处理中的指令无关的问题</p>
<p><img src="/home/alex/图片/he.png" alt="image"></p>
<p><img src="/home/alex/图片/寄存器.png" alt="image"></p>
<p><img src="/home/alex/图片/von.png" alt="image"></p>
<p>MDR：内存数据寄存器</p>
<p>MAR: 主存地址寄存器</p>
<p><img src="/home/alex/图片/eflags.png" alt="image"></p>
<p>GPR 8个通用寄存器  属于可见寄存器</p>
<p>EFLAGs 标志寄存器  属于半可见寄存器</p>
<p>EIP 指令指针  属于半可见寄存器</p>
<p><img src="/home/alex/图片/exe.png" alt="image"></p>
<p>绿色的地址实际上是虚拟空间的地址。这里假定</p>
<h4 id="取值令"><a href="#取值令" class="headerlink" title="取值令"></a>取值令</h4><p>取地址放到EIP中，再放到主存地址寄存器当中。55 89 e5 放在主存。</p>
<p>控制器会发出读命令（红线），存储器会根据读信号根据传入的地址寻找里面的数值</p>
<p>过一段时间后（取数时间） 数据就会放在数据线上。</p>
<h4 id="指令译码"><a href="#指令译码" class="headerlink" title="指令译码"></a>指令译码</h4><p>根据功能产生控制信号</p>
<p><img src="/home/alex/图片/kanjia.png" alt="image"></p>
<p>R[esp]&lt;-R[esp]-4  ESP处的地址-4 变成 bffefffc</p>
<p>M[R[esp]]&lt;-R[ebp]</p>
<h4 id="esp内容放到MAR"><a href="#esp内容放到MAR" class="headerlink" title="esp内容放到MAR"></a>esp内容放到MAR</h4><p><img src="/home/alex/图片/esp.png" alt="image"></p>
<p><img src="/home/alex/图片/ssss.png" alt="image"></p>
<p>写信号，把要写的地址bffeffc 和写的内容（MDR中的bfff0020）传输到存储器中</p>
<p><img src="/home/alex/图片/2018-3.png" alt="image"></p>
<p><img src="/home/alex/图片/alu.png" alt="image"></p>
<p>而eax是0号寄存器，edx是2号寄存器</p>
<p><img src="/home/alex/图片/dd.png" alt="image"></p>
<p>经过这条指令之后</p>
<p><img src="/home/alex/图片/zz.png" alt="image"></p>
<p>结果变成这样</p>
<p><img src="/home/alex/图片/2018-4.png" alt="image"></p>
<p>小结</p>
<p><img src="/home/alex/图片/Linked.png" alt="image"></p>
<h3 id="练习答案"><a href="#练习答案" class="headerlink" title="练习答案"></a>练习答案</h3><p><img src="/home/alex/图片/2018-5.png" alt="image"></p>
<p><img src="/home/alex/图片/2018-6.png" alt="image"></p>
<p>什么是指令寄存器？什么是程序计数器？</p>
<p>指令寄存器（IR，Instruction Register），是临时放置从内存里面取得的程序指令的寄存器，用于存放当前从主存储器读出的正在执行的一条指令。</p>
<p>什么是程序计数器PC？</p>
<p>程序计数器是用于存放下一条指令所在单元的地址的地方。</p>
<p>当执行一条指令时，首先需要根据PC中存放的指令地址，将指令由内存取到指令寄存器中，此过程称为“取指令”。与此同时，PC中的地址或自动加1或由转移指针给出下一条指令的地址。此后经过分析指令，执行指令。完成第一条指令的执行，而后根据PC取出第二条指令的地址，如此循环，执行每一条指令。</p>
<h2 id="访问存储操作与基本术语"><a href="#访问存储操作与基本术语" class="headerlink" title="访问存储操作与基本术语"></a>访问存储操作与基本术语</h2><p><img src="/home/alex/图片/term.png" alt="imaeg"></p>
<p><img src="/home/alex/图片/li.png" alt="image"></p>
<h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="按工作性质-存储方式分类"><a href="#按工作性质-存储方式分类" class="headerlink" title="按工作性质/存储方式分类"></a>按工作性质/存储方式分类</h4><ol>
<li>Random Access Memory(RAM)</li>
</ol>
<p>随机存取存储器 </p>
<p>每个单元读写时间一样，与各单元所在位置无关，如内存</p>
<p>2.Sequential Access Memo在ry（SAM）</p>
<p>顺序采取存储器</p>
<p>数据按照顺序从存储载体的始端读出或者写入，因此存取时间长短与所在信息的位置有关。如磁带</p>
<p><img src="/home/alex/图片/luan.png" alt="image"></p>
<h3 id="其他分类方式"><a href="#其他分类方式" class="headerlink" title="其他分类方式"></a>其他分类方式</h3><p><img src="/home/alex/图片/存储器.png" alt="image"></p>
<h3 id="按功能-容量-速度-所在位置分类"><a href="#按功能-容量-速度-所在位置分类" class="headerlink" title="按功能/容量/速度/所在位置分类"></a>按功能/容量/速度/所在位置分类</h3><h4 id="寄存器："><a href="#寄存器：" class="headerlink" title="寄存器："></a>寄存器：</h4><p>封装在CPU中，用于存放当前执行的指令以及使用的数据</p>
<p>用触发器实现，速度快，x86 8个,MIPS 32个</p>
<h4 id="高速存储（cache）："><a href="#高速存储（cache）：" class="headerlink" title="高速存储（cache）："></a>高速存储（cache）：</h4><p>位于CPU内部或者附近，用来存放当前要执行的局部程序段和数据</p>
<p>用SRAM实现，速度可以与CPU匹配，容量小</p>
<p><img src="/home/alex/图片/neicun.png" alt="image"></p>
<h4 id="内存与外存关系："><a href="#内存与外存关系：" class="headerlink" title="内存与外存关系："></a>内存与外存关系：</h4><p><img src="/home/alex/图片/relation.png" alt="upload successful"></p>
<p><img src="/home/alex/图片/RAM.png" alt="存储器受CPU总线控制"></p>
<p>存储器受CPU总线控制，总线就是链接CPU和存储器的数据线，地址线和控制线</p>
<p>由于地址线是36位，因此存储单元地址有2^36种可能性，即可以寻找地址的范围为0-2^32-1 即64GB</p>
<p><img src="/home/alex/图片/daikuan.png" alt="imaeg"></p>
<p>Tmc&gt;TA</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/09/10/CS230-Shallow-Neural-Networks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/CS230-Shallow-Neural-Networks/" itemprop="url">CS230 Shallow Neural Networks</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-10T04:19:00+08:00">
                2018-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="神经网络是什么"><a href="#神经网络是什么" class="headerlink" title="神经网络是什么"></a>神经网络是什么</h2><p><img src="/home/alex/图片/sn.png" alt="image"></p>
<p>左下角，第一层就是计算a[1]，然后加上更新后的W【2】，b【2】，在第二层计算新的结果<br>z【2】</p>
<p><img src="/home/alex/图片/Presentation.png" alt="image"></p>
<h5 id="注意一般不把输入层算在神经网络层内"><a href="#注意一般不把输入层算在神经网络层内" class="headerlink" title="注意一般不把输入层算在神经网络层内"></a>注意一般不把输入层算在神经网络层内</h5><p>注意hidden layer 其实就是一个4x1的列矩阵</p>
<h5 id="神经网络表示"><a href="#神经网络表示" class="headerlink" title="神经网络表示"></a>神经网络表示</h5><p><br><br><img src="/home/alex/图片/ss.png" alt="image"></p>
<p>符号右上角表示层数，右下角表示该层第几个结点</p>
<p>实际上可以把神经网络计算过错化为向量矩阵运算</p>
<p><img src="/home/alex/图片/NNRL.png" alt="image"></p>
<p>Z （4X1） =  W (4X3) * x(3,1) +b(4,1)</p>
<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><h4 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h4><p>用tanh效果会比sigmodi好，因为均值为0，说明能起到数据中心化效果</p>
<p><img src="/home/alex/图片/ac1.png" alt="image"></p>
<h4 id="线性整流函数（ReLU）"><a href="#线性整流函数（ReLU）" class="headerlink" title="线性整流函数（ReLU）"></a>线性整流函数（ReLU）</h4><p><img src="/home/alex/图片/relu.png" alt="image"></p>
<p>使用ReLU 会使得神经网络学习的速度加快，因为在tanh与sigmoid当中，当斜率降低的时候，学习的速度也会相应的下降。</p>
<p>而ReLu则会减少则种情况</p>
<p><img src="/home/alex/图片/PAC.png" alt="image"></p>
<p>一般而言，不用sigmoid</p>
<h4 id="激活函数的导数"><a href="#激活函数的导数" class="headerlink" title="激活函数的导数"></a>激活函数的导数</h4><p>在反向传播的时候，需要计算激活函数的导数</p>
<h4 id="神经网络的梯度下降"><a href="#神经网络的梯度下降" class="headerlink" title="神经网络的梯度下降"></a>神经网络的梯度下降</h4><p>重点关注dZ【1】 dW的计算原理<br><img src="/home/alex/图片/ressss.png" alt="image"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/09/09/CSAPP-重定位/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/09/CSAPP-重定位/" itemprop="url">CSAPP-重定位</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-09T23:56:00+08:00">
                2018-09-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ICS/" itemprop="url" rel="index">
                    <span itemprop="name">ICS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="共享库与动态链接概述"><a href="#共享库与动态链接概述" class="headerlink" title="共享库与动态链接概述"></a>共享库与动态链接概述</h2><p>使用静态库 .a文件有一些缺点</p>
<p>1.静态库函数被包含在每个进程的代码段中，对于并发运行上百个进程的系统，会造成极大的主存资源浪费</p>
<p>2.静态库函数会被和并在可执行目标中，磁盘上存放着数千个可执行文件，会造成磁盘空间的极大浪费</p>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>Shared Libraries(共享库)</p>
<p>Linux 称为 动态共享对象 (Dynamic Shared Objects,.so文件)</p>
<p>Windows 中的.dll 文件</p>
<p>原理就是： 包含目标模块的文件，每个模块包含有代码和数据，从程序中分离出来，磁盘和内存中只有一个备份，可以在装入或者运行的时候被动态加载与链接。</p>
<p>举个例子，printf（）的代码不会包含在每个调用其的文件当中，所有进程共享调用这一份代码。</p>
<h3 id="共享库优点："><a href="#共享库优点：" class="headerlink" title="共享库优点："></a>共享库优点：</h3><h5 id="第一次加载的时候进行：（load-time-linking）"><a href="#第一次加载的时候进行：（load-time-linking）" class="headerlink" title="第一次加载的时候进行：（load-time linking）"></a>第一次加载的时候进行：（load-time linking）</h5><p>在linux当中通常由动态链接器自动处理</p>
<p>libc.so 通常按这种方式被动态链接</p>
<h5 id="在开始运行后进行："><a href="#在开始运行后进行：" class="headerlink" title="在开始运行后进行："></a>在开始运行后进行：</h5><p>在linux中，调用dlopen()等接口实现</p>
<p><img src="/home/alex/图片/dynamic.png" alt="image"></p>
<p>生成的代码文件是放在内存当中</p>
<h4 id="位置无关代码（PIC）"><a href="#位置无关代码（PIC）" class="headerlink" title="位置无关代码（PIC）"></a>位置无关代码（PIC）</h4><p><img src="/home/alex/图片/222.png" alt="image"></p>
<p>要跳转的目标地址 = 当前PC（当前指令下一条指令地址）+ 立即数<br><img src="/home/alex/图片/33.png" alt="image"></p>
<p>不需要重定位<br><img src="/home/alex/图片/yinyong.png" alt="image"></p>
<p>第三种情况</p>
<p><img src="/home/alex/图片/2018-2.png" alt="image"></p>
<p>call 指令的功能是：<br>1.把下一条指令地址压栈</p>
<p>2.jump到那条指令</p>
<p>popl %ebx 的功能就是把该条指令的地址送到 %ebx寄存器当中</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="Alex Chiu" />
            
              <p class="site-author-name" itemprop="name">Alex Chiu</p>
              <p class="site-description motion-element" itemprop="description">Alex's personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Chiu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
