<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Alex&apos;s personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Alex Chiu">
<meta property="og:url" content="http://AlexanderChiuluvB.github.io/page/3/index.html">
<meta property="og:site_name" content="Alex Chiu">
<meta property="og:description" content="Alex&apos;s personal blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alex Chiu">
<meta name="twitter:description" content="Alex&apos;s personal blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://AlexanderChiuluvB.github.io/page/3/"/>





  <title>Alex Chiu</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alex Chiu</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/22/线性模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/22/线性模型/" itemprop="url">PRML-线性模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-22T13:55:54+08:00">
                2018-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="线性基函数模型"><a href="#线性基函数模型" class="headerlink" title="线性基函数模型"></a>线性基函数模型</h3><p>线性回归模型 y(x,w) = w0+w1x1+w2x2+…wDxD</p>
<p>而为了改进模型，把xi替换为非线性表达式</p>
<p><img src="/home/alex/图片/six.png" alt="uploaccessful"></p>
<p>本实验使用了多项式基函数，高斯基函数和sigmoid基函数，以及混合型（多项式+sin正弦）而损失函数有两种选择，<em>交叉熵</em>函数以及<em>均方误差</em>，这里选择均方误差，求导比较方便。</p>
<h3 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h3><h4 id="多项式基函数"><a href="#多项式基函数" class="headerlink" title="多项式基函数"></a>多项式基函数</h4><p>y = w0+w1<em>x1+w2</em>x2^2 + b</p>
<p>λ2是L2正则化系数，可以解决过拟合问题</p>
<p>正则化意义：<a href="https://blog.csdn.net/jinping_shi/article/details/52433975" target="_blank" rel="noopener">https://blog.csdn.net/jinping_shi/article/details/52433975</a></p>
<h4 id="推导-1"><a href="#推导-1" class="headerlink" title="推导"></a>推导</h4><p><img src="/home/alex/图片/2018-98.png" alt="filename alrey exists, renamed"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def propogate(w,b,X,Y):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    :param w: (n,1)</span><br><span class="line">    :param b: scalar</span><br><span class="line">    :param X: (n,m)</span><br><span class="line">    :param Y: (1,n)</span><br><span class="line">    :return: grads a dict that saves the params dw,db</span><br><span class="line">            cost saves the cost after each iteration</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    #np.squeeze</span><br><span class="line">    #squeeze 函数：从数组的形状中删除单维度条目，即把shape中为1的维度去掉</span><br><span class="line">    m = X.shape[1]</span><br><span class="line"></span><br><span class="line">    Yba = np.dot(w.T,X) + b</span><br><span class="line"></span><br><span class="line">    cost = np.squeeze((0.5/m *np.dot((Yba-Y),(Yba-Y).T)))</span><br><span class="line"></span><br><span class="line">    dw = (1./m) * np.dot(X,(Yba-Y).T)</span><br><span class="line"></span><br><span class="line">    db = (1./m) * np.squeeze(np.sum(Yba-Y))</span><br><span class="line">    #save the updated result to the grads dict</span><br><span class="line">    grads = &#123;&quot;dw&quot;:dw,&quot;db&quot;:db&#125;</span><br><span class="line"></span><br><span class="line">    return grads,cost</span><br><span class="line"></span><br><span class="line">def optimize(w,b,X,Y,epochs,learning_rate,l2):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    :param w: (n,1) </span><br><span class="line">    :param b: scalar</span><br><span class="line">    :param X: (n,m)</span><br><span class="line">    :param Y: (1,n)</span><br><span class="line">    :param epochs: 迭代次数 </span><br><span class="line">    :param learning_rate: </span><br><span class="line">    :param l2: 正则化系数 </span><br><span class="line">    :return: params</span><br><span class="line">            grads save the final params ,used for test</span><br><span class="line">            costs save the cost</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    costs = []</span><br><span class="line"></span><br><span class="line">    for i in range(epochs):</span><br><span class="line">        grads,cost = propogate(w,b,X,Y)</span><br><span class="line">        dw = grads[&quot;dw&quot;]</span><br><span class="line">        db = grads[&quot;db&quot;]</span><br><span class="line"></span><br><span class="line">        w-=learning_rate*dw+l2*w</span><br><span class="line">        b-=learning_rate*db</span><br><span class="line"></span><br><span class="line">    params = &#123;&quot;w&quot;:w,&quot;b&quot;:b&#125;</span><br><span class="line">    grads = &#123;&quot;dw&quot;:dw,&quot;db&quot;:db&#125;</span><br><span class="line"></span><br><span class="line">    return params,grads,costs</span><br><span class="line"></span><br><span class="line">def main(x_train, y_train,n,epoches,learning_rate,l2):</span><br><span class="line">    &quot;&quot;&quot;训练模型，并返回从x到y的映射。&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 使用线性回归训练模型，根据训练集计算最优化参数</span><br><span class="line">    ## 请补全此处代码，替换以下示例</span><br><span class="line">    m = x_train.shape[0]</span><br><span class="line">    w = (np.random.randn(n,1))</span><br><span class="line">    X = np.zeros((n,m),dtype = np.float64)</span><br><span class="line">    b = np.float(0)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        X[i,:] = x_train**(i+1)</span><br><span class="line">    Y = np.float64(np.reshape(y_train,newshape=(1,m)))</span><br><span class="line">    params,grads,costs = optimize(w,b,X,Y,epoches,learning_rate,l2)</span><br><span class="line">    w = params[&apos;w&apos;]</span><br><span class="line">    b = params[&apos;b&apos;]</span><br><span class="line">    def f(x):</span><br><span class="line">        ## 请补全此处代码，替换以下示例</span><br><span class="line">        m = x.shape[0]</span><br><span class="line"></span><br><span class="line">        X = np.zeros((n,m))</span><br><span class="line">        for i in range(n):</span><br><span class="line">            X[i,:] = x**(i+1)</span><br><span class="line">        y = b+np.dot(w.T,X)</span><br><span class="line">        return y.squeeze()</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    return f</span><br></pre></td></tr></table></figure>
<h4 id="result"><a href="#result" class="headerlink" title="result"></a>result</h4><p>参数：n=2 epochs = 100000 lr 1e-7</p>
<p><img src="/home/alex/图片/2018-97.png" alt="filename alrey exists, renamed"></p>
<h4 id="高斯基函数"><a href="#高斯基函数" class="headerlink" title="高斯基函数"></a>高斯基函数</h4><p><img src="/home/alex/图片/gaosiji.png" alt="upload succeful"></p>
<h4 id="推导-2"><a href="#推导-2" class="headerlink" title="推导"></a>推导</h4><p><img src="/home/alex/图片/推导.png" alt="upload ssful"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def propogate(w,b,X,Y,mu,s):</span><br><span class="line"></span><br><span class="line">    m = X.shape[1]</span><br><span class="line">    Z = (X-mu)/s</span><br><span class="line">    A = np.exp(-(Z*Z)/2)</span><br><span class="line">    Yba = np.dot(w.T,A) + b</span><br><span class="line">    cost = np.squeeze((0.5/m *np.dot((Yba-Y),(Yba-Y).T)))</span><br><span class="line"></span><br><span class="line">    dY = 1./m*(Yba-Y)</span><br><span class="line">    dw = np.dot(A,dY.T)</span><br><span class="line">    db = np.squeeze(np.sum(dY))</span><br><span class="line">    dA = w*dY</span><br><span class="line">    dZ = dA*A*(-Z)</span><br><span class="line">    dmu = 1./m*np.sum(dZ*(-1/s),axis=1,keepdims=True)</span><br><span class="line">    ds = 1./m*np.sum(dZ*(-(X-mu)/(s*s)),axis=1,keepdims=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    grads = &#123;&quot;dw&quot;:dw,&quot;db&quot;:db,&quot;dmu&quot;:dmu,&quot;ds&quot;:ds&#125;</span><br><span class="line"></span><br><span class="line">    return grads,cost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def optimize(w,b,X,Y,mu,s,epochs,learning_rate,l2):</span><br><span class="line"></span><br><span class="line">    costs = []</span><br><span class="line"></span><br><span class="line">    for i in range(epochs):</span><br><span class="line">        grads,cost = propogate(w,b,X,Y,mu,s)</span><br><span class="line">        dw = grads[&quot;dw&quot;]</span><br><span class="line">        db = grads[&quot;db&quot;]</span><br><span class="line">        dmu = grads[&quot;dmu&quot;]</span><br><span class="line">        ds = grads[&quot;ds&quot;]</span><br><span class="line"></span><br><span class="line">        w-=learning_rate*dw+l2*w</span><br><span class="line">        b-=learning_rate*db+l2*b</span><br><span class="line">        mu-=learning_rate*dmu+l2*mu</span><br><span class="line">        s -=learning_rate*ds+l2*s</span><br><span class="line"></span><br><span class="line">        costs.append(cost)</span><br><span class="line"></span><br><span class="line">    params = &#123;&quot;w&quot;:w,&quot;b&quot;:b,&quot;mu&quot;:mu,&quot;s&quot;:s&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return params,costs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(x_train, y_train,n,epoches,learning_rate,l2):</span><br><span class="line">    &quot;&quot;&quot;训练模型，并返回从x到y的映射。&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 使用线性回归训练模型，根据训练集计算最优化参数</span><br><span class="line">    ## 请补全此处代码，替换以下示例</span><br><span class="line">    m = x_train.shape[0]</span><br><span class="line">    w = (np.random.randn(n,1))</span><br><span class="line">    # means of gaussian</span><br><span class="line">    mu = np.random.randn(n,1)</span><br><span class="line">    #I still have no idea why set like this?</span><br><span class="line">    for i in range(n):</span><br><span class="line">        mu[i,0]+=i*40</span><br><span class="line">    X = np.zeros((n,m),dtype = np.float64)</span><br><span class="line">    b = np.float(0)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        X[i,:] = x_train</span><br><span class="line">    Y = np.float64(np.reshape(y_train,newshape=(1,m)))</span><br><span class="line"></span><br><span class="line">    #initalize s if s is too close to 0 then it will go wrong</span><br><span class="line">    while True:</span><br><span class="line">        flag = True</span><br><span class="line">        s = np.random.randn(n,1)</span><br><span class="line">        jump = np.int32(np.abs(s)&lt;1)</span><br><span class="line">        if(np.sum(jump))&gt;=1:</span><br><span class="line">            flag = False</span><br><span class="line">        if flag is True:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    params,costs = optimize(w,b,X,Y,mu,s,epoches,learning_rate,l2)</span><br><span class="line">    w = params[&apos;w&apos;]</span><br><span class="line">    b = params[&apos;b&apos;]</span><br><span class="line">    mu = params[&apos;mu&apos;]</span><br><span class="line">    s = params[&apos;s&apos;]</span><br><span class="line">    def f(x):</span><br><span class="line">        ## 请补全此处代码，替换以下示例</span><br><span class="line">        m = x.shape[0]</span><br><span class="line"></span><br><span class="line">        X = np.zeros((n,m))</span><br><span class="line">        for i in range(n):</span><br><span class="line">            X[i,:] = x</span><br><span class="line">        Z = (X-mu)/s</span><br><span class="line">        A = np.exp(-(Z*Z)/2)</span><br><span class="line">        y = b+np.dot(w.T,A)</span><br><span class="line">        return y.squeeze()</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    return f</span><br></pre></td></tr></table></figure>
<p>参数：f = gaussian.main(x_train, y_train,3,500000,1e-2,0)</p>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p><img src="/home/alex/图片/2018-100.png" alt="fileme already exists, renamed"></p>
<h4 id="sigmoid-函数"><a href="#sigmoid-函数" class="headerlink" title="sigmoid 函数"></a>sigmoid 函数</h4><p><img src="/home/alex/图片/zhuanjiang.png" alt="upload succeful"></p>
<h4 id="推导-3"><a href="#推导-3" class="headerlink" title="推导"></a>推导</h4><p>结果与高斯类似</p>
<p><img src="/home/alex/图片/2018-99.png" alt="fiename already exists, renamed"></p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def sigmoidFunction(z):</span><br><span class="line">    return 1./(1+np.exp(-z))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def propogate(w,b,X,Y,mu,s):</span><br><span class="line"></span><br><span class="line">    m = X.shape[1]</span><br><span class="line">    Z = (X-mu)/s</span><br><span class="line">    A = sigmoidFunction(Z)</span><br><span class="line">    Yba = np.dot(w.T,A) + b</span><br><span class="line">    cost = np.squeeze((0.5/m *np.dot((Yba-Y),(Yba-Y).T)))</span><br><span class="line"></span><br><span class="line">    dY = 1./m*(Yba-Y)</span><br><span class="line">    dw = np.dot(A,dY.T)</span><br><span class="line">    db = np.squeeze(np.sum(dY))</span><br><span class="line">    dA = w*dY</span><br><span class="line">    dZ = dA*A*(1-A)</span><br><span class="line">    dmu = 1./m*np.sum(dZ*(-1./s),axis=1,keepdims=True)</span><br><span class="line">    ds = 1./m*np.sum(dZ*(-(X-mu)/(s*s)),axis=1,keepdims=True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    grads = &#123;&quot;dw&quot;:dw,&quot;db&quot;:db,&quot;dmu&quot;:dmu,&quot;ds&quot;:ds&#125;</span><br><span class="line"></span><br><span class="line">    return grads,cost</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def optimize(w,b,X,Y,mu,s,epochs,learning_rate,l2):</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    costs = []</span><br><span class="line"></span><br><span class="line">    for i in range(epochs):</span><br><span class="line">        grads,cost = propogate(w,b,X,Y,mu,s)</span><br><span class="line">        dw = grads[&quot;dw&quot;]</span><br><span class="line">        db = grads[&quot;db&quot;]</span><br><span class="line">        dmu = grads[&quot;dmu&quot;]</span><br><span class="line">        ds = grads[&quot;ds&quot;]</span><br><span class="line"></span><br><span class="line">        w-=learning_rate*dw+l2*w</span><br><span class="line">        b-=learning_rate*db+l2*b</span><br><span class="line">        mu-=learning_rate*dmu+l2*mu</span><br><span class="line">        s -=learning_rate*ds+l2*s</span><br><span class="line"></span><br><span class="line">        costs.append(cost)</span><br><span class="line"></span><br><span class="line">    params = &#123;&quot;w&quot;:w,&quot;b&quot;:b,&quot;mu&quot;:mu,&quot;s&quot;:s&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return params,costs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main(x_train, y_train,n,epoches,learning_rate,l2):</span><br><span class="line">    &quot;&quot;&quot;训练模型，并返回从x到y的映射。&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    # 使用线性回归训练模型，根据训练集计算最优化参数</span><br><span class="line">    ## 请补全此处代码，替换以下示例</span><br><span class="line">    m = x_train.shape[0]</span><br><span class="line">    w = (np.random.randn(n,1))</span><br><span class="line">    # means of gaussian</span><br><span class="line">    mu = np.random.randn(n,1)</span><br><span class="line">    # mu is the mean of the sigmoid</span><br><span class="line">    for i in range(n):</span><br><span class="line">        mu[i,0]+= i*100/n</span><br><span class="line">    X = np.zeros((n,m),dtype = np.float64)</span><br><span class="line">    b = np.float(0)</span><br><span class="line">    for i in range(n):</span><br><span class="line">        X[i,:] = x_train</span><br><span class="line">    Y = np.float64(np.reshape(y_train,newshape=(1,m)))</span><br><span class="line"></span><br><span class="line">    #initalize s if s is too close to 0 then it will go wrong</span><br><span class="line">    while True:</span><br><span class="line">        flag = True</span><br><span class="line">        s = np.random.randn(n,1)</span><br><span class="line">        jump = np.int32(np.abs(s)&lt;1)</span><br><span class="line">        if(np.sum(jump))&gt;=1:</span><br><span class="line">            flag = False</span><br><span class="line">        if flag is True:</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    params,costs = optimize(w,b,X,Y,mu,s,epoches,learning_rate,l2)</span><br><span class="line">    w = params[&apos;w&apos;]</span><br><span class="line">    b = params[&apos;b&apos;]</span><br><span class="line">    mu = params[&apos;mu&apos;]</span><br><span class="line">    s = params[&apos;s&apos;]</span><br><span class="line">    def f(x):</span><br><span class="line">        ## 请补全此处代码，替换以下示例</span><br><span class="line">        m = x.shape[0]</span><br><span class="line"></span><br><span class="line">        X = np.zeros((n,m))</span><br><span class="line">        for i in range(n):</span><br><span class="line">            X[i,:] = x</span><br><span class="line">        Z = (X-mu)/s</span><br><span class="line">        A = sigmoidFunction(Z)</span><br><span class="line">        y = b+np.dot(w.T,A)</span><br><span class="line">        return y.squeeze()</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    return f</span><br></pre></td></tr></table></figure>
<p>参数：  f = sigmoid.main(x_train, y_train,10,100000,1e-2,0)</p>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><p><img src="/home/alex/图片/jieguo.png" alt="upload successful"></p>
<h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><p><a href="https://github.com/Haicang/PRML/blob/master/lab1/Report.ipynb" target="_blank" rel="noopener">https://github.com/Haicang/PRML/blob/master/lab1/Report.ipynb</a></p>
<p><a href="https://blog.csdn.net/pipisorry/article/details/73770637" target="_blank" rel="noopener">https://blog.csdn.net/pipisorry/article/details/73770637</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/18/生产者与消费者模型-同步异步概念/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/生产者与消费者模型-同步异步概念/" itemprop="url">生产者与消费者模型&同步异步概念</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-18T13:01:48+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ref：</p>
<p><a href="https://blog.csdn.net/fuzhongmin05/article/details/54616344" target="_blank" rel="noopener">https://blog.csdn.net/fuzhongmin05/article/details/54616344</a></p>
<p><img src="/home/alex/图片/expla.png" alt="upload succsful"></p>
<p>code:</p>
<p><img src="/home/alex/图片/code.png" alt="upload successl"></p>
<p><strong><em>无法避免竞争</em></strong></p>
<p>对count的访问没有做限制。</p>
<p>这里有可能出现竞争条件，其原因是对count的访问未作限制。有可能出现以下情况：缓冲区为空，消费者刚刚读取count的值发现它为0，此时调度程序决定暂停消费者并启动运行生产者。生产者向缓冲区加入一个数据项，count加1。现在count的值变成了1，它推断认为count刚才为0，所以消费者此时一定在睡眠，于是生产者调用wakeup来唤醒消费者。</p>
<p> 但是消费者在逻辑上并未睡眠，所以wakeup信号丢失，当消费者下次运行时，它将测试先前读取的count值，发现它为0。于是睡眠，生产者迟早会填满整个缓冲区，然后睡眠，这样一来，两个进程将永远睡眠下去。</p>
<h3 id="引入信号量的操作"><a href="#引入信号量的操作" class="headerlink" title="引入信号量的操作"></a>引入信号量的操作</h3><p> Dijkstra建议设立两种操作：down和up（分别为一般化后的sleep和wakeup）。对一信号量执行down操作，则是检查其值是否大于0。若该值大于0，则将其减1（即用掉一个保存的唤醒信号）并继续；若该值为0，则进程将睡眠，而且此时down操作并未结束。检查数值、修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作完成。保证一旦一个信号量操作开始，则在该操作完成或阻塞之前，其他进程均不允许访问该信号量。这种原子性对于解决同步问题和避免竞争条件是绝对必要的。所谓原子操作，是指一组相关联的操作要么都不间断地执行，要么不执行。</p>
<p> up操作对信号量的值增1。如果一个或多个进程在该信号量上睡眠，无法完成一个先前的down操作，则由系统选择其中的一个（如随机挑选）并允许该进程完成它的down操作。于是，对一个有进程在其上睡眠的信号量执行一次up操作后，该信号量的值仍旧是0，但在其上睡眠的进程却少了一个。信号量的值增加1和唤醒一个进程同样也是不可分割的，不会有某个进程因执行up而阻塞，正如前面的模型中不会有进程因执行wakeup而阻塞一样。</p>
<p> 在Dijkstra原来的论文中，他分别使用名称P和V而不是down和up，荷兰语中，Proberen的意思是尝试，Verhogen的含义是增加或升高。</p>
<p>从物理上说明信号量的P、V操作的含义。 P(S)表示申请一个资源，S.value&gt;0表示有资源可用,其值为资源的数目；S.value=0表示无资源可用；S.value&lt;0, 则|S.value|表示S等待队列中的进程个数。V(S)表示释放一个资源，信号量的初值应该大于等于0。P操作相当于“等待一个信号”，而V操作相当于“发送一个信号”，在实现同步过程中，V操作相当于发送一个信号说合作者已经完成了某项任务，在实现互斥过程中，V操作相当于发送一个信号说临界资源可用了。实际上，在实现互斥时，P、V操作相当于申请资源和释放资源。</p>
<p>该解决方案使用了三个信号量：一个称为full，用来记录充满缓冲槽数目，一个称为empty，记录空的缓冲槽总数；一个称为mutex，用来确保生产者和消费者不会同时访问缓冲区。full的初值为0，empty的初值为缓冲区中槽的数目，mutex的初值为1。供两个或多个进程使用的信号量，其初值为1，保证同时只有一个进程可以进入临界区，称作二元信号量。如果每个进程在进入临界区前都执行down操作，并在刚刚退出时执行一个up操作，就能够实现互斥。</p>
<p> 在下面的例子中，我们实际上是通过两种不同的方式来使用信号量，两者之间的区别是很重要的，信号量mutex用于互斥，它用于保证任一时刻只有一个进程读写缓冲区和相关的变量。互斥是避免混乱所必需的操作。</p>
<p>例题：</p>
<p><img src="/home/alex/图片/mancao.png" alt="uplouccessful"></p>
<p> items  就是full，记录满槽数目，初始值位0</p>
<p> slots 就是empty，就是缓冲区中槽的数目,初始值为10</p>
<p> mutex inital value  = 0</p>
<p>那么insert function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">P(slots);       //empty slot-1</span><br><span class="line">P(mutex);		//进入临界区</span><br><span class="line">insert_item</span><br><span class="line">V(mutex);		//离开临界区</span><br><span class="line">V(items);		//full slot+1</span><br></pre></td></tr></table></figure>
<p>remove function</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P(items);		//满槽数目-1</span><br><span class="line">P(mutex);		</span><br><span class="line">remove_item;</span><br><span class="line">V(mutex);</span><br><span class="line">V(slots);		//空槽数目+1</span><br></pre></td></tr></table></figure>
<p>本例中，信号量保证缓冲区满的时候生产者停止运行，缓冲区空的时候消费者停止运行。</p>
<h3 id="信号量用于同步"><a href="#信号量用于同步" class="headerlink" title="信号量用于同步"></a>信号量用于同步</h3><h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>一个进程执行某个请求，如果需要一段时间才能返回信息，那么进程会一直等待下去。也就是说直到收到返回信息才继续下去。</p>
<h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><p>进程不需要一直等待下去，继续执行下面的操作，不管其他进程的状态。</p>
<p>对于无界缓冲区问题，消费者只需关心缓冲区是否空即可</p>
<p><img src="/home/alex/图片/empty.png" alt="upload suessful">。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/18/僵尸进程和孤儿进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/18/僵尸进程和孤儿进程/" itemprop="url">僵尸进程和孤儿进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-18T10:09:29+08:00">
                2018-12-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。</p>
<p>　　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<p>3、问题及危害</p>
<p>　　unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。</p>
<p>　　孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。</p>
<p>　　任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个 子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</p>
<p><img src="/home/alex/图片/手痒.png" alt="upload succesul"> </p>
<p>b</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/17/CSAPP-习题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/17/CSAPP-习题/" itemprop="url">CSAPP-习题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-17T10:36:00+08:00">
                2018-12-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/home/alex/图片/2018-93.png" alt="filename already exists, renmed"></p>
<p>C。读写锁只能同时由多个读者或者一个写者拥有，而且读和写是排他的，两者不能共存。</p>
<p><img src="/home/alex/图片/vpn.png" alt="uplo successful"></p>
<p>页大小大概占10位，那么虚拟地址分为虚拟页号和虚拟页偏移量，那么后10位就是偏移量，剩下的位就是索引位，对应在页表中的索引，那么所以说他们的索引一样，物理位置的物理页号一样，而物理偏移量A总是小于B</p>
<p><img src="/home/alex/图片/asd.png" alt="upload succesul"></p>
<p>*（x+2） = A[2];</p>
<p><img src="/home/alex/图片/100.png" alt="upload sussful"></p>
<p>b</p>
<p><img src="/home/alex/图片/11.png" alt="upload successl"></p>
<p>d</p>
<p>Size of a pointer should be 8 byte on any 64-bit C/C++ compiler, but not necessarily size of int.</p>
<h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 3;  //静态变量，外部链接性</span><br><span class="line">static int b = 4;  //静态变量，内部链接性</span><br><span class="line"> </span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">	static int c = 5;  //静态变量，无链接性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部链接性： 多个文件共享</p>
<p>内部链接性： 只有所属的文件可用</p>
<p>无连接性： 只有该代码段内可用</p>
<p>外部链接性的静态变量</p>
<p><img src="/home/alex/图片/waibu.png" alt="upload successful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 2;</span><br><span class="line"> </span><br><span class="line">void fun()</span><br><span class="line">&#123;</span><br><span class="line">	int a = 3;  //这是自动变量，会覆盖掉全局静态变量a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部链接性的静态变量"><a href="#内部链接性的静态变量" class="headerlink" title="内部链接性的静态变量"></a>内部链接性的静态变量</h3><p><img src="/home/alex/图片/2018-94.png" alt="filename alrey exists, renamed"></p>
<h3 id="无连接性的静态变量"><a href="#无连接性的静态变量" class="headerlink" title="无连接性的静态变量"></a>无连接性的静态变量</h3><p><img src="/home/alex/图片/wulianjie.png" alt="upload succsful"></p>
<h3 id="CSAPP6-34-6-35"><a href="#CSAPP6-34-6-35" class="headerlink" title="CSAPP6.34/6.35"></a>CSAPP6.34/6.35</h3><p>cache共有两个block，分别位于两个set中，设他们为b1和b2。每个block可以放下4个int类型的变量，也就是数组中的一行。在这一题中，源数组和目的数组是相邻排列的。所以内存和cache的映射情况是这样的：</p>
<p>b1 : src[0][] src[2][] dst[0][] dst[2][]</p>
<p>b2 : src[1][] src[3][] dst[1][] dst[3][]</p>
<p><img src="/home/alex/图片/GAOCUOLE.png" alt="upload succeful"></p>
<p>这里搞错了，应该是dst数组全是m，src数组是左边的样子。</p>
<p><img src="/home/alex/图片/2018-95.png" alt="filename already exists,named"></p>
<p>a</p>
<p><img src="/home/alex/图片/8byte.png" alt="upld successful"><br>An object that is “8 bytes aligned” is stored at a memory address that is a multiple of 8.</p>
<p>so choose c</p>
<h3 id="理解cache中的block，cache和line"><a href="#理解cache中的block，cache和line" class="headerlink" title="理解cache中的block，cache和line"></a>理解cache中的block，cache和line</h3><p><img src="/home/alex/图片/block.png" alt="upload succeful"></p>
<p>line就是block</p>
<p>directed mapped 就是一个set只有一个line</p>
<p>2way就是一个set可以放2个line</p>
<p>4way，就是一个set可以放4个line</p>
<p>fully associated 就是只有一个set，所以不需要中间位的index，来作为line index</p>
<h4 id="为什么要用中间位来做索引？"><a href="#为什么要用中间位来做索引？" class="headerlink" title="为什么要用中间位来做索引？"></a>为什么要用中间位来做索引？</h4><p>空间局部性。</p>
<p><img src="/home/alex/图片/4way.png" alt="upload succeful"></p>
<h4 id="fork函数到底复制了啥？"><a href="#fork函数到底复制了啥？" class="headerlink" title="fork函数到底复制了啥？"></a>fork函数到底复制了啥？</h4><p>“子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本。父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段。”</p>
<p><img src="/home/alex/图片/linux环境.png" alt="upload succeful"></p>
<p><img src="/home/alex/图片/2018-96.png" alt="filename already exists, ramed"></p>
<p>子进程得到的只是全局变量的副本，该题应该选b</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/15/CSAPP-proxy-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/15/CSAPP-proxy-lab/" itemprop="url">CSAPP-proxy lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-15T21:43:43+08:00">
                2018-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Implementing-a-sequential-web-proxy"><a href="#Implementing-a-sequential-web-proxy" class="headerlink" title="Implementing a sequential web proxy"></a>Implementing a sequential web proxy</h3><p>先搞清listen socket 和 connected socket 的区别。</p>
<p><img src="/home/alex/图片/taojiezidui.png" alt="upload succful"></p>
<p>一个套接字对标记着一个客户端和服务器的链接。</p>
<p>客户端是发起连接请求的主动实体，而内核会认为socket函数创建的套接字是主动套接字，而服务器就是要调用listen函数告诉内核，该套接字是被服务器而不是客户端使用的，即listen函数将一个主动套接字转化为<strong><em>监听套接字</em></strong>。</p>
<p>服务器通过accept函数等待来自客户端的连接请求到达监听套接字，并返回一个<strong><em>已连接套接字</em></strong>，这个connfd可以被用来与客户端进行通讯。</p>
<p>实验过程如下：</p>
<p><img src="/home/alex/图片/实验过程.png" alt="upload successful"></p>
<h4 id="some-def"><a href="#some-def" class="headerlink" title="some def"></a>some def</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* You won&apos;t lose style points for including this long line in your code */</span><br><span class="line">static const char *user_agent_hdr = &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;;</span><br><span class="line">static const char *conn_hdr = &quot;Connection: close\r\n&quot;;</span><br><span class="line">static const char *prox_hdr = &quot;Proxy-Connection: close\r\n&quot;;</span><br><span class="line">static const char *hostFormat = &quot;Host: %s\r\n&quot;;</span><br><span class="line">static const char *requestHeaderFormat = &quot;GET %s HTTP/1.0\r\n&quot;;</span><br><span class="line">static const char *endof_hdr = &quot;\r\n&quot;;</span><br><span class="line">static const char *connection_key = &quot;Connection&quot;;</span><br><span class="line">static const char *user_agent_key= &quot;User-Agent&quot;;</span><br><span class="line">static const char *proxy_connection_key = &quot;Proxy-Connection&quot;;</span><br><span class="line">static const char *hostKey = &quot;Host&quot;;</span><br><span class="line"></span><br><span class="line">void doit(int fd);</span><br><span class="line">void parse_uri(char *uri,char *hostname,char *path,int *port);</span><br><span class="line">void buildHTTPHeader(char *http_header,char *hostname,char *path,int port,rio_t *client_rio);</span><br><span class="line">int connectEndServer(char *hostname,int port,char *httpHeader);</span><br><span class="line">void *thread(void *vargp);</span><br><span class="line">void initCache();</span><br><span class="line">int reader(int fd,char *uri);</span><br><span class="line">void writer(char *uri,char *buf);</span><br><span class="line">//reference: https://zhuanlan.zhihu.com/p/37902495</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    char *buf;</span><br><span class="line">    char *uri;</span><br><span class="line">&#125;cacheLine;</span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    cacheLine* objects;</span><br><span class="line">    int count;</span><br><span class="line">&#125;Cache;</span><br><span class="line"></span><br><span class="line">Cache cache;</span><br><span class="line">int readCount;</span><br><span class="line">sem_t mutex,wmutex;</span><br><span class="line">//用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制</span><br></pre></td></tr></table></figure>
<p>main 函数，参考课本的tiny服务器，注意的是这里pthread_create是传值而不是引用，是为了避免竞争。（传值是传一个独立的副本）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int listenfd,connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    char hostname[MAXLINE];</span><br><span class="line">    char port[MAXLINE];</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    pthread_t tid;</span><br><span class="line">    if(argc!=2)&#123;</span><br><span class="line">        fprintf(stderr,&quot;usage %s &lt;port&gt;\n&quot;,argv[0]);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    initCache();</span><br><span class="line">    //ignore the SIGPIPE signal</span><br><span class="line">    signal(SIGPIPE, SIG_IGN);</span><br><span class="line">    //transfrom the fd to listenfd</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        clientlen = sizeof(clientaddr);</span><br><span class="line">        connfd = Accept(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);</span><br><span class="line">        //ip-&gt;host name</span><br><span class="line">        Getnameinfo((SA *)&amp;clientaddr,clientlen,hostname,MAXLINE,port,MAXLINE,0);</span><br><span class="line">        printf(&quot;Accepted connection from (%s %s)\n&quot;,hostname,port);</span><br><span class="line">        //pass value of connfd to create function to avoid competition</span><br><span class="line">        Pthread_create(&amp;tid,NULL,thread,(void*)connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void *thread(void *vargp)&#123;</span><br><span class="line">    int connfd = (int)vargp;</span><br><span class="line">    //要把线程分离出去，让这个线程计数结束之后自己回收资源，避免内存泄露。</span><br><span class="line">    Pthread_detach(pthread_self());</span><br><span class="line">    doit(connfd);</span><br><span class="line">    Close(connfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doit"><a href="#doit" class="headerlink" title="doit"></a>doit</h3><p>函数逻辑：</p>
<p>1.得到解析后的请求行和请求头</p>
<p>2.然后去连接对应的服务器，发送请求</p>
<p>3.建立连接后，返回信息会在描述符中，也就是endServerFd</p>
<p>4.再把信息从endServerFd中读取出来，直接写进客户端对应的描述符fd就可以。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">//对客户端请求的HTTP header 进行处理，首先获得request header</span><br><span class="line">//eg: GET http://www.zhihu.com HTTP/1.1</span><br><span class="line">//然后对于请求URL进行分析，获取需要连接的服务器的hostname，port，</span><br><span class="line">//修改客户端的HTTP，让proxy充当客户端把信息转发给正确的服务器，然后接收服务器</span><br><span class="line">//的返回并转发给正确的客户端</span><br><span class="line">void doit(int connfd)&#123;</span><br><span class="line"></span><br><span class="line">    char buf[MAXLINE],uri[MAXLINE],method[MAXLINE],version[MAXLINE];</span><br><span class="line">    //parseRequest(fd,&amp;requestLine,headers,&amp;numHead);</span><br><span class="line">    char endServerHTTP [MAXLINE];</span><br><span class="line">    char hostname[MAXLINE],path[MAXLINE];</span><br><span class="line">    char objectBUF[MAX_OBJECT_SIZE];</span><br><span class="line">    int port,endServerFd;</span><br><span class="line"></span><br><span class="line">    rio_t rio,serverRio;</span><br><span class="line"></span><br><span class="line">    Rio_readinitb(&amp;rio,connfd);</span><br><span class="line">    Rio_readlineb(&amp;rio,buf,MAXLINE);</span><br><span class="line">    //read GET http://www.zhihu.com HTTP/1.1</span><br><span class="line">    //format read function</span><br><span class="line">    sscanf(buf,&quot;%s %s %s&quot;,method,uri,version);</span><br><span class="line">    </span><br><span class="line">    if(strcasecmp(method,&quot;GET&quot;))&#123;</span><br><span class="line">        printf(&quot;Proxy does not implement the method&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //parse the uri and save the hostname,path,port number to the argument</span><br><span class="line">    parse_uri(uri,hostname,path,&amp;port);</span><br><span class="line"></span><br><span class="line">    //build the http header which will send to the end server</span><br><span class="line">    buildHTTPHeader(endServerHTTP,hostname,path,port,&amp;rio);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    strcpy(uri,hostname);</span><br><span class="line">    strcpy(uri+strlen(uri),path);</span><br><span class="line">    if(reader(connfd,uri))&#123;</span><br><span class="line">        fprintf(stdout,&quot;%s from cache\n&quot;,uri);</span><br><span class="line">        fflush(stdout);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int totalSize = 0;</span><br><span class="line">    //connect to the end server;</span><br><span class="line">    endServerFd = connectEndServer(hostname,port);</span><br><span class="line">    if(endServerFd&lt;0)&#123;</span><br><span class="line">        printf(&quot;connection failed&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Rio_readinitb(&amp;serverRio,endServerFd);</span><br><span class="line">    Rio_writen(endServerFd,endServerHTTP,strlen(endServerHTTP));</span><br><span class="line"></span><br><span class="line">    //receive message from end server and send to client</span><br><span class="line">    size_t n;</span><br><span class="line">    while((n=Rio_readlineb(&amp;serverRio,buf,MAXLINE)))&#123;</span><br><span class="line">        printf(&quot;proxy received %ld bytes,then send.\n&quot;,n);</span><br><span class="line">        Rio_writen(connfd,buf,n);</span><br><span class="line">        strcpy(objectBUF+totalSize,buf);</span><br><span class="line">        totalSize+=n;</span><br><span class="line">    &#125;</span><br><span class="line">   //each objectBUF save all info of the request</span><br><span class="line">    if(totalSize&lt;MAX_OBJECT_SIZE)</span><br><span class="line">        writer(uri,objectBUF);</span><br><span class="line">    Close(endServerFd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="build-HTTP-that-send-to-the-end-server"><a href="#build-HTTP-that-send-to-the-end-server" class="headerlink" title="build HTTP that send to the end server"></a>build HTTP that send to the end server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">void buildHTTPHeader(char *http_header,char *hostname,char *path,int port,rio_t *client_rio)&#123;</span><br><span class="line"></span><br><span class="line">    char buf[MAXLINE],requestHeader[MAXLINE],otherHeader[MAXLINE],hostHeader[MAXLINE];</span><br><span class="line"></span><br><span class="line">    //request line</span><br><span class="line">    //static const char *requestHeaderFormat = &quot;GET %s HTTP/1.0\r\n&quot;;</span><br><span class="line">    //把path内容按照格式写入requestHeader</span><br><span class="line">    sprintf(requestHeader,requestHeaderFormat,path);</span><br><span class="line">    while(Rio_readlineb(client_rio,buf,MAXLINE)&gt;0)&#123;</span><br><span class="line"></span><br><span class="line">        if(!strcmp(buf,endof_hdr))&#123;</span><br><span class="line">            break; //EOF</span><br><span class="line">        &#125;</span><br><span class="line">        //Host</span><br><span class="line">        if(!strncasecmp(buf,hostKey,strlen(hostKey)))&#123;</span><br><span class="line">            strcpy(hostHeader,buf);</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!strncasecmp(buf,connection_key,strlen(connection_key))&amp;&amp;!</span><br><span class="line">            strncasecmp(buf,proxy_connection_key,strlen(proxy_connection_key)),</span><br><span class="line">            !strncasecmp(buf,user_agent_key,strlen(user_agent_key)))&#123;</span><br><span class="line">            //把两个串连接起来</span><br><span class="line">            strcat(otherHeader,buf);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    if(strlen(hostHeader)==0)&#123;</span><br><span class="line">        sprintf(hostHeader,hostFormat,buf);</span><br><span class="line">    &#125;</span><br><span class="line">    //static const char *user_agent_hdr = &quot;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 Firefox/10.0.3\r\n&quot;;</span><br><span class="line">    //static const char *conn_hdr = &quot;Connection: close\r\n&quot;;</span><br><span class="line">    //static const char *prox_hdr = &quot;Proxy-Connection: close\r\n&quot;;</span><br><span class="line">    //static const char *endof_hdr = &quot;\r\n&quot;;</span><br><span class="line">    </span><br><span class="line">    //put all header to http_header</span><br><span class="line">    sprintf(http_header,&quot;%s%s%s%s%s%s%s&quot;,requestHeader,hostHeader,</span><br><span class="line">            conn_hdr,prox_hdr,user_agent_hdr,otherHeader,endof_hdr);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="parseuri"><a href="#parseuri" class="headerlink" title="parseuri"></a>parseuri</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void parse_uri(char *uri,char *hostname,char *path,int *port)&#123;</span><br><span class="line"></span><br><span class="line">    //strstr(str1,str2) 函数用于判断字符串str2是否是str1的子串。</span><br><span class="line">    //如果是，则该函数返回str2在str1中首次出现的地址；否则，返回NULL。</span><br><span class="line"></span><br><span class="line">    *port = 80;</span><br><span class="line">    char *pos1 = strstr(uri,&quot;//&quot;);</span><br><span class="line"></span><br><span class="line">    if(pos1)&#123;</span><br><span class="line">        pos1 =  pos1+2;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        pos1 = uri;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    char *pos2 = strstr(pos1,&quot;:&quot;);</span><br><span class="line">    //case the uri has the port info</span><br><span class="line">    if(pos2)&#123;</span><br><span class="line"></span><br><span class="line">        //          userinfo     host        port</span><br><span class="line">        //          ┌─┴────┐ ┌────┴────────┐ ┌┴┐</span><br><span class="line">        //  https://john.doe@www.example.com:123/forum/questions/?tag=networking&amp;order=newest#top</span><br><span class="line">        //  └─┬─┘ └───────┬────────────────────┘└─┬─────────────┘└──┬───────────────────────┘└┬─┘</span><br><span class="line">        //  scheme     authority                 path              query                      fragment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //initalize the head of pos2 is \0 i.e clean the pos2</span><br><span class="line">        *pos2 = &apos;\0&apos;;</span><br><span class="line">        sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">        sscanf(pos2+1,&quot;%d%s&quot;,port,path);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        //</span><br><span class="line">        //telnet://192.0.2.16:80/xxx</span><br><span class="line">        //└──┬─┘ └──────┬──────┘│</span><br><span class="line">        //scheme    authority  path</span><br><span class="line">        // no port info</span><br><span class="line">        pos2 = strstr(pos1,&quot;/&quot;);</span><br><span class="line">        if(pos2)&#123;</span><br><span class="line">            sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">            *pos2 = &apos;/&apos;;</span><br><span class="line">            sscanf(pos2,&quot;%s&quot;,path);</span><br><span class="line">        &#125;</span><br><span class="line">        //only hostname info</span><br><span class="line">        else&#123;</span><br><span class="line">            sscanf(pos1,&quot;%s&quot;,hostname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="connect-end-server"><a href="#connect-end-server" class="headerlink" title="connect end server"></a>connect end server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline int connectEndServer(char *hostname,int port)&#123;</span><br><span class="line"></span><br><span class="line">    char portStr[100];</span><br><span class="line">    sprintf(portStr,&quot;%d&quot;,port);</span><br><span class="line">    return Open_clientfd(hostname,portStr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>采用读者-写者模型，可以让多个线程同时来读。</p>
<p>没有实现LRU，只是简单地把1MiB内存分为十块，每次接受请求并解析之后，先去cache看看有没有对应的web object，如果有直接返回给客户端，没有再从服务端请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">int reader(int fd,char *uri)&#123;</span><br><span class="line"></span><br><span class="line">    //here uri = each server&apos;s hostname+path</span><br><span class="line">    int Found = 0;</span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    readCount++;</span><br><span class="line">    if(readCount==1)&#123;</span><br><span class="line">        P(&amp;wmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        if(!strcmp(cache.objects[i].uri,uri))&#123;</span><br><span class="line">            Rio_writen(fd,cache.objects[i].buf,MAX_OBJECT_SIZE);</span><br><span class="line">            Found=1;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    readCount--;</span><br><span class="line">    if(readCount==0)&#123;</span><br><span class="line">        V(&amp;wmutex);</span><br><span class="line">    &#125;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">    return Found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void writer(char *uri,char *buf)&#123;</span><br><span class="line"></span><br><span class="line">    P(&amp;wmutex);</span><br><span class="line">    strcpy(cache.objects[cache.count].uri,uri);</span><br><span class="line">    strcpy(cache.objects[cache.count].buf,buf);</span><br><span class="line">    ++cache.count;</span><br><span class="line">    V(&amp;wmutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//simple cache no use LRU,just split the memory to 10 block,</span><br><span class="line">//each time use a loop to find whether the uri of the request is in the block</span><br><span class="line">//在server和client之间加入代理的好处之一，就可以实现cache化。</span><br><span class="line">//因为，经常有很多对同一个资源多次请求的情况，如果每次都从服务端获取，那样服务器会很累。</span><br><span class="line">//如果可以在代理部分就实现一个cache，</span><br><span class="line">//将最近客户端请求过的数据给存储起来，那样就不需要每次都要从服务器请求了，进而提高服务器的效率。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void initCache()&#123;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;mutex,0,1);</span><br><span class="line">    sem_init(&amp;wmutex,0,1);</span><br><span class="line">    cache.objects = (cacheLine*)malloc(sizeof(cacheLine)*10);</span><br><span class="line">    cache.count=0;</span><br><span class="line">    readCount=0;</span><br><span class="line">    for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">        cache.objects[i].buf = malloc(sizeof(char)*MAXLINE);</span><br><span class="line">        cache.objects[i].uri = malloc(sizeof(char)*MAX_OBJECT_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><ul>
<li><p>use ./free-port.sh to get a free port, like 4501</p>
</li>
<li><p>open a terminal, nc -l 4501</p>
<ul>
<li>this is to start netcat as a server listening on port you get</li>
</ul>
</li>
<li><p>open a terminal </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --proxy http://localhost:23885/ http://localhost:4501/</span><br></pre></td></tr></table></figure>
<ul>
<li>open a terminal </li>
</ul>
<p>./proxy 23885</p>
<p><img src="/home/alex/图片/2018-91.png" alt="filename alady exists, renamed"></p>
<p>netcat is listening on 4501,proxy is listening on 23885,here netcat serves as a server,print sth in the ‘nc -l’ window,then you can see the exact sth print on the ‘curl’ window</p>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h3><p><a href="https://blog.csdn.net/u012336567/article/details/52056089" target="_blank" rel="noopener">https://blog.csdn.net/u012336567/article/details/52056089</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37902495" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37902495</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/15/SAPP-Synchronization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/15/SAPP-Synchronization/" itemprop="url">CSAPP-Synchronization</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-15T13:50:00+08:00">
                2018-12-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>现代操作系统提供三种构造并发程序的方法：</p>
<p>1.进程</p>
<p>2.I/O多路复用</p>
<p>3.线程</p>
<h3 id="基于进程的并发编程"><a href="#基于进程的并发编程" class="headerlink" title="基于进程的并发编程"></a>基于进程的并发编程</h3><p>1.内核自动管理多个逻辑流</p>
<p>2.每个进程有私有的地址空间（进程切换的时候要保存和载入数据）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void sigchld_handler(int sig)&#123;</span><br><span class="line">    while (waitpid(-1, 0, WNOHANG) &gt; 0)</span><br><span class="line">        ;</span><br><span class="line">    return;</span><br><span class="line">    // Reap all zombie children</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char **argv) &#123;</span><br><span class="line">    int listenfd, connfd;</span><br><span class="line">    socklen_t clientlen;</span><br><span class="line">    struct sockaddr_storage clientaddr;</span><br><span class="line">    </span><br><span class="line">    Signal(SIGCHLD, sigchld_handler);</span><br><span class="line">    listenfd = Open_listenfd(argv[1]);</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        clientlen = sizeof(struct sockaddr_storage);</span><br><span class="line">        connfd = Accept(listenfd, (SA *) &amp;clientaddr, &amp;clientlen);</span><br><span class="line">        if (Fork() == 0) &#123;</span><br><span class="line">            Close(listenfd); // Child closes its listening socket</span><br><span class="line">            echo(connfd); // Child services client</span><br><span class="line">            Close(connfd); // Child closes connection with client</span><br><span class="line">            exit(0); // Child exits</span><br><span class="line">        &#125;</span><br><span class="line">        Close(connfd); // Parent closes connected socket (important!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器在accept函数中等待连接请求，然后客户端通过调用connect函数发送连接请求，最后服务器在accept中返回connfd并且fork一个子进程来处理客户端链接，链接就建立在listenfd和connfd之间。</p>
<ul>
<li><p>每个客户端由独立的子进程处理，而且必须回收僵尸进程，避免内存泄漏</p>
</li>
<li><p>不同进程之间不共享数据</p>
</li>
<li><p>父进程和子进程都有listenfd和connfd，所以父进程中要关闭connfd，子进程要关闭listenfd</p>
<ul>
<li>内核会保存对每个socket的引用计数，(refcnt(connfd)=2)，所以父进程需要关闭connfd，这样在子进程结束后引用计数才会变为0</li>
</ul>
</li>
</ul>
<p>优点：只共享已打开的file table，无论是descriptor还是全局变量都不共享，不容易造成同步问题。</p>
<p>缺点：带来额外的进程管理开销，进程间通信需要用IPC</p>
<h3 id="基于事件-I-O-multiplexing"><a href="#基于事件-I-O-multiplexing" class="headerlink" title="基于事件 I/O multiplexing"></a>基于事件 I/O multiplexing</h3><p>1.由程序员手动控制多个逻辑流。</p>
<p>2.所有逻辑流共享同一个地址空间</p>
<h3 id="基于线程"><a href="#基于线程" class="headerlink" title="基于线程"></a>基于线程</h3><p>内核自动管理多个逻辑流</p>
<p>每个线程共享地址空间</p>
<p>属于基于进程和基于事件的混合体</p>
<h3 id="传统观点下的进程"><a href="#传统观点下的进程" class="headerlink" title="传统观点下的进程"></a>传统观点下的进程</h3><p><img src="/home/alex/图片/jincheng.png" alt="upload sessful"></p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>一个进程有多个线程，每个线程有自己的线程id，有自己的逻辑控制流，也有自己用来保存局部变量的栈（其他线程可以修改）。而且共享所有代码，数据和内核上下文。</p>
<p><img src="/home/alex/图片/xiancheng.png" alt="upload sucssful"></p>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p><img src="/home/alex/图片/duoxianc.png" alt="upload sussful"></p>
<p>概念上的</p>
<p><img src="/home/alex/图片/gainian.png" alt="upload sessful"></p>
<p>实际上的</p>
<p><img src="/home/alex/图片/globaland.png" alt="upload sucsful"></p>
<p>不同线程之间的数据其实可以相互访问</p>
<h3 id="Shared-variable"><a href="#Shared-variable" class="headerlink" title="Shared variable"></a>Shared variable</h3><p>a variable x is shared if and only if multiple threads reference some instance of x </p>
<h4 id="global-amp-local-variable"><a href="#global-amp-local-variable" class="headerlink" title="global &amp; local variable"></a>global &amp; local variable</h4><p><img src="/home/alex/图片/stat.png" alt="upload sful"></p>
<h4 id="example"><a href="#example" class="headerlink" title="example"></a>example</h4><p><img src="/home/alex/图片/example.png" alt="upload suessful"></p>
<p>ptr是全局变量，shared by main thread and thread 1&amp;2</p>
<p>i is only referenced by main, so not shared</p>
<p>msgs is referenced by all 3 threads, so is is shared </p>
<p>myid is only referenced by thread 1 &amp; 2 seperately</p>
<p>static int cnt is referenced by both 1 &amp;2</p>
<p>so if <strong><em>multiple threads reference the same x instance, the x is shared </em></strong></p>
<p><img src="/home/alex/图片/shared.png" alt="upload succful"></p>
<h3 id="bad-example"><a href="#bad-example" class="headerlink" title="bad example"></a>bad example</h3><p><img src="/home/alex/图片/badeg.png" alt="upload successful"></p>
<p>看loop的汇编代码</p>
<p><img src="/home/alex/图片/2018-86.png" alt="filename ady exists, renamed"></p>
<p>正常结果</p>
<p><img src="/home/alex/图片/zhengchang.png" alt="upload succful"></p>
<p>下图是线程2提前Load了cnt，结果rdx2为0，正确结果是等到线程1store之后线程2再load</p>
<p><img src="/home/alex/图片/dang.png" alt="upload succeful"></p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile的本意是“易变的” 因为访问寄存器要比访问内存单元快的多,所以编译器一般都会作减少存取内存的优化，但有可能会读脏数据。当要求使用volatile声明变量值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。精确地说就是，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问；如果不使用valatile，则编译器将对所声明的语句进行优化。（简洁的说就是：volatile关键词影响编译器编译的结果，用volatile声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错）</p>
<h3 id="再看信号量"><a href="#再看信号量" class="headerlink" title="再看信号量:"></a>再看信号量:</h3><p><img src="/home/alex/图片/sss.png" alt="upload sussful"></p>
<p>信号量的提出，是为了解决<strong><em>同步不同执行线程问题</em></strong>的方法。</p>
<p>什么是信号量？</p>
<p>信号量<strong>s</strong>是一个具有非负值的全局变量。</p>
<p>只能由两种特殊操作P，V来处理</p>
<p>P，V原理如上图</p>
<p><img src="/home/alex/图片/xinhaol.png" alt="uploadccessful"></p>
<p>定义P和V，为了确保一个正在运行的程序绝不可能进入s是负值的状态，这个属性叫<strong><em>信号量不变性</em></strong></p>
<h3 id="使用信号量实现互斥"><a href="#使用信号量实现互斥" class="headerlink" title="使用信号量实现互斥"></a>使用信号量实现互斥</h3><p><img src="/home/alex/图片/jiasuo.png" alt="upload cessful"></p>
<p><img src="/home/alex/图片/2018-87.png" alt="filename alrey exists, renamed"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">volatile int cnt=0; </span><br><span class="line">sem_t mutex; //声明信号量mutex</span><br><span class="line"></span><br><span class="line">Sem_init(&amp;mutex,0,1);//主线程中初始化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//在线程例程中对共享变量cnt的更新包围P和V操作，从而保护他们</span><br><span class="line">for(i=0;i&lt;niters;i++)&#123;</span><br><span class="line"></span><br><span class="line">    P(&amp;mutex);</span><br><span class="line">    cnt++;</span><br><span class="line">    V(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用信号量来调度共享资源"><a href="#使用信号量来调度共享资源" class="headerlink" title="使用信号量来调度共享资源"></a>使用信号量来调度共享资源</h3><h4 id="生产者和消费者"><a href="#生产者和消费者" class="headerlink" title="生产者和消费者"></a>生产者和消费者</h4><p><img src="/home/alex/图片/yuanli.png" alt="upload cessful"></p>
<h4 id="读者和写者问题"><a href="#读者和写者问题" class="headerlink" title="读者和写者问题"></a>读者和写者问题</h4><p><img src="/home/alex/图片/duzhe.png" alt="load successful"></p>
<p><img src="/home/alex/图片/esa.png" alt="upload sucsful"></p>
<p><img src="/home/alex/图片/2018-88.png" alt="filename exists, renamed"></p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>一个函数如果被多个并发线程反复调用的时候，会一直产生正确的结果，否则就是线程不安全的。</p>
<p>1.不保护共享变量的函数</p>
<p>解决方案，利用P,V这样的同步操作来保护共享的变量</p>
<p>2.保持跨越多个调用状态的函数</p>
<p><img src="/home/alex/图片/jiang.png" alt="uoad successful"></p>
<p>3.返回指向静态变量的指针的函数</p>
<p><img src="/home/alex/图片/hanshu.png" alt="upload scessful"></p>
<p>4.调用线程不安全函数的函数。</p>
<p> 1.如果函数f调用线程不安全函数g。那么f可能不安全。<br> 2.如果g是第二类，那么f一定不安全，也没有办法去修正，只能改变g.<br> 3.如果g是第一，三类，可以用加锁-拷贝技术来解决。</p>
<h3 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h3><p>当一个程序的正确性依赖于一个线程要在另一个线程到达y点之前到达它的控制流中的x点，就会发生竞争。</p>
<p>1.通常，竞争发生的理由是因为程序员假定某种特殊的轨迹线穿过执行状态空间。</p>
<p><img src="/home/alex/图片/face.png" alt="u successful"></p>
<p><img src="/home/alex/图片/2018-89.png" alt="filename alry exists, renamed"></p>
<p><img src="/home/alex/图片/sisuo.png" alt="upload successf"></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p><img src="/home/alex/图片/2018-90.png" alt="filename ady exists, renamed"></p>
<p><img src="/home/alex/图片/pindong.png" alt="uploaessful"></p>
<h3 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h3><p>判断 myid会不会出现竞争</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 版本一</span><br><span class="line">void *foo(void *vargp)</span><br><span class="line">&#123;</span><br><span class="line">    int myid;</span><br><span class="line">    myid = *((int *)vargp);</span><br><span class="line">    Free(vargp);</span><br><span class="line">    printf(&quot;Thread %d\n&quot;, myid);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[2];</span><br><span class="line">    int i, *ptr;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; 2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ptr = Malloc(sizeof(int));</span><br><span class="line">        *ptr = i;</span><br><span class="line">        Pthread_create(&amp;tid[i], 0, foo, ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    Pthread_join(tid[0], 0);</span><br><span class="line">    Pthread_join(tid[1], 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环中每次创建不同的指针，两个线程不是共享同一个变量。</p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 版本二</span><br><span class="line">void *foo(void *vargp)</span><br><span class="line">&#123;</span><br><span class="line">    int myid;</span><br><span class="line">    myid = *((int *)vargp);</span><br><span class="line">    printf(&quot;Thread %d\n&quot;, myid);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid[2];</span><br><span class="line">    int i;</span><br><span class="line">    </span><br><span class="line">    for (i = 0; i &lt; 2; i++)</span><br><span class="line">        Pthread_create(&amp;tid[i], NULL, foo, &amp;i);</span><br><span class="line">    Pthread_join(tid[0], NULL);</span><br><span class="line">    Pthread_join(tid[1], NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个线程共享i变量，而i++和myid = <em>((int </em>)vargp)<br>会发生竞争，当然前提是传的是引用&amp;i，因为这样的话foo函数会改变i本身的值，若如果是传值i，则只会改变i的一个副本。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-Network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-Network/" itemprop="url">CSAPP-Network</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T20:19:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p><img src="/home/alex/图片/socket.png" alt="upload sucsful"></p>
<h4 id="socket-address-structures"><a href="#socket-address-structures" class="headerlink" title="socket address structures"></a>socket address structures</h4><p><img src="/home/alex/图片/sas.png" alt="upload suful"></p>
<p><img src="/home/alex/图片/2018-82.png" alt="filename aly exists, renamed"></p>
<p>发明套接字接口的时候，还没有void*,为了兼容，可以定义套接字函数要求一个指向通用sockaddr结构的指针，然后要求应用程序将与协议特定的结构的指针强制转换成这个通用的结构。</p>
<h3 id="socket-Interface"><a href="#socket-Interface" class="headerlink" title="socket Interface"></a>socket Interface</h3><p><img src="/home/alex/图片/socketInterface.png" alt="upload succesl"></p>
<p>1.开启服务器</p>
<ul>
<li>（open_listenfd函数，做好接收请求的准备）</li>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>accept</li>
</ul>
<p>2.开启客户端</p>
<ul>
<li>getaddrinfo</li>
<li>socket</li>
<li>connect</li>
</ul>
<ol start="3">
<li>交换数据</li>
</ol>
<p>4.关闭客户端</p>
<p>5.断开客户端</p>
<h4 id="getaddrinfo："><a href="#getaddrinfo：" class="headerlink" title="getaddrinfo："></a>getaddrinfo：</h4><p>设置服务器的相关信息</p>
<h4 id="socket-1"><a href="#socket-1" class="headerlink" title="socket"></a>socket</h4><p>创建socket descriptor ，也就是之后用来读写的file descriptor</p>
<p><img src="/home/alex/图片/socf.png" alt="upload cessful"></p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>请求kernel把socket address 和 socket descriptor绑定</p>
<p>Bind is kernel call to designate which service this program will be hosting</p>
<p>告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来，对于socket和connect，最好方法是用getaddrinfo来为bind提供参数</p>
<p><img src="/home/alex/图片/2018-83.png" alt="filename alrey exists, renamed"></p>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a>listen</h4><p>由于客户端是发起连接要求的主动实体，服务器是被动等待连接请求的，所以默认条件下，内核会认为socket函数创建的描述符对应于主动套接字，它存在于一个连接的客户端。服务器调用listen函数告诉内核，描述符是被服务器而不是客户端使用的。</p>
<p>也就是说listen函数把sockfd从一个主动套接字转化为一个监听套接字，这个套接字可以接受来自客户端的连接请求。</p>
<p><img src="/home/alex/图片/listen.png" alt="upload succeul"></p>
<h4 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h4><p>等待来自客户端的连接请求到达listenfd，然后在addr中填写客户端的套接字地址，并且返回一个已连接描述符，这个描述符可以用来利用Unix I/O 函数与客户端通信。</p>
<p><img src="/home/alex/图片/accept.png" alt="upload succeul"></p>
<p><img src="/home/alex/图片/2018-84.png" alt="filename ady exists, renamed"></p>
<h4 id="connect-client-side"><a href="#connect-client-side" class="headerlink" title="connect (client side)"></a>connect (client side)</h4><p>connect 函数试图与套接字地址为addr的服务器建立一个因特网链接，其中addrlen是sizeof（sockaddr_in）connect函数会阻塞，一直到连接成功或者发现错误。</p>
<p><img src="/home/alex/图片/connect.png" alt="uploessful"></p>
<h3 id="diff-of-connected-amp-listening-descriptors"><a href="#diff-of-connected-amp-listening-descriptors" class="headerlink" title="diff of connected &amp; listening descriptors"></a>diff of connected &amp; listening descriptors</h3><p><img src="/home/alex/图片/connected.png" alt="upload successful"></p>
<h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p><img src="/home/alex/图片/get.png" alt="upload succesl"></p>
<h3 id="Host-and-service-connection"><a href="#Host-and-service-connection" class="headerlink" title="Host and service connection"></a>Host and service connection</h3><p><img src="/home/alex/图片/host.png" alt="uload successful"></p>
<p>result 指向addrinfo结构的链表</p>
<h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p><img src="/home/alex/图片/info.png" alt="upload succesul"></p>
<h3 id="LLR-by-getinfo"><a href="#LLR-by-getinfo" class="headerlink" title="LLR by getinfo"></a>LLR by getinfo</h3><p><img src="/home/alex/图片/adddd.png" alt="upload sussful"></p>
<h4 id="addrinfo-struct（代码实现）"><a href="#addrinfo-struct（代码实现）" class="headerlink" title="addrinfo struct（代码实现）"></a>addrinfo struct（代码实现）</h4><p><img src="/home/alex/图片/daimashixian.png" alt="upload succel"></p>
<p>以下函数是用来把域名转化为IP地址的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc,char **argv)&#123;</span><br><span class="line"></span><br><span class="line">	struct addrinfo *p,*listp,hints;</span><br><span class="line">	char buf[MAXLINE];</span><br><span class="line">	int rc,flags;</span><br><span class="line"></span><br><span class="line">	if(argc!=2)&#123;</span><br><span class="line">		fprintf(stderr,&quot;usage: %s &lt;domain name&gt;\n&quot;,argv[0]);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	//get a list of addinfo records</span><br><span class="line">	memset(&amp;hints,0,sizeof(struct addrinfo));</span><br><span class="line">	hints.ai_family = AF_INET;</span><br><span class="line">	hints.ai_socktype = SOCK_STREAM;</span><br><span class="line">	if((rc=getaddrinfo(argv[1],NULL,&amp;hints,&amp;listp))!=0)&#123;</span><br><span class="line">		fprintf(stderr,&quot;getaddrinfo error: %s\n&quot;,gai_strerror(rc));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	flags = NI_NUMERICHOST;</span><br><span class="line"></span><br><span class="line">	for(p=listp;p;p = p-&gt;ai_next)&#123;</span><br><span class="line">		Getnameinfo(p-&gt;ai_addr,p-&gt;ai_addrlen,buf,MAXLINE,NULL,0,flags);</span><br><span class="line">		printf(&quot;%s\n&quot;,buf);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Freeaddrinfo(listp);</span><br><span class="line"></span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p><img src="/home/alex/图片/cline.png" alt="upload sssful"></p>
<p>web server return content to clients,in 2 different ways:</p>
<p>1.取磁盘文件，并把他的内容返回给客户端，磁盘文件称为静态内容，返回文件给客户端叫服务静态内容。</p>
<p>2.运行一个可执行文件，把输出返回给客户端，运行的时候输出内容叫做动态内容，而运行程序并返回输出内容叫做服务动态内容。</p>
<p>web服务器返回的内容都是和它管理的某个文件相关联的，这些文件中的每一个都有一个唯一的名字叫<strong><em>URL，通用资源定位符。</em></strong></p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>超文本传输协议</p>
<h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>通用网关接口，用来处理服务器向客户端提供动态内容的问题</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-UNIX-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-UNIX-IO/" itemprop="url">CSAPP-UNIX/IO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T16:45:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Unix-I-O-Overview"><a href="#Unix-I-O-Overview" class="headerlink" title="Unix I/O Overview"></a>Unix I/O Overview</h3><p>1.A linux file is a sequence of m bytes</p>
<p>  B0,B1..Bm-1</p>
<p>2.all I/O devices and even the kernel are represented as files</p>
<p>/dev/sda2 (/usr disk partition)<br>/dev/tty2 (terminal)</p>
<p><img src="/home/alex/图片/2018-76.png" alt="filename aady exists, renamed"></p>
<h3 id="File-Types"><a href="#File-Types" class="headerlink" title="File Types"></a>File Types</h3><p>1.regular file</p>
<p>2.directory</p>
<p>3.<strong>socket</strong> for communicating with a process on another machine</p>
<h4 id="regular-files"><a href="#regular-files" class="headerlink" title="regular files"></a>regular files</h4><p>Kernel doesn’t know the difference between text files and regular files</p>
<h3 id="pathname"><a href="#pathname" class="headerlink" title="pathname"></a>pathname</h3><h4 id="absolute-pathname"><a href="#absolute-pathname" class="headerlink" title="absolute pathname"></a>absolute pathname</h4><p>starts with ‘/‘ and denotes path from root</p>
<p>/home/droh/a.c</p>
<h4 id="relative-pathname"><a href="#relative-pathname" class="headerlink" title="relative pathname"></a>relative pathname</h4><p>../home/droh/a.c</p>
<p><img src="/home/alex/图片/ics.png" alt="upload succsful"></p>
<h3 id="open-amp-closing-file"><a href="#open-amp-closing-file" class="headerlink" title="open&amp;closing file"></a>open&amp;closing file</h3><p><img src="/home/alex/图片/open.png" alt="upload successul"></p>
<p><img src="/home/alex/图片/1.png" alt="upload suessful"></p>
<h3 id="Reading-Files"><a href="#Reading-Files" class="headerlink" title="Reading Files"></a>Reading Files</h3><p><img src="/home/alex/图片/rf.png" alt="upload succful"></p>
<h3 id="Writing-Files"><a href="#Writing-Files" class="headerlink" title="Writing Files"></a>Writing Files</h3><p><img src="/home/alex/图片/2018-77.png" alt="filenameady exists, renamed"></p>
<h3 id="Simple-Unix-I-O-example"><a href="#Simple-Unix-I-O-example" class="headerlink" title="Simple Unix I/O example"></a>Simple Unix I/O example</h3><h4 id="bad-case"><a href="#bad-case" class="headerlink" title="bad case"></a>bad case</h4><p>Each while loop, execute 2 operating system function,that means you have to go to the kernel,go through,context switch,do whatever you wants,then switch back. in a word,it is too <strong>expensive</strong>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;csapp.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    char c;</span><br><span class="line"></span><br><span class="line">    while(Read(STDIN_FILENO, &amp;c, 1) != 0)</span><br><span class="line">        Write(STDOUT_FILENO, &amp;c, 1);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="short-counts"><a href="#short-counts" class="headerlink" title="short counts"></a>short counts</h3><p><img src="/home/alex/图片/2018-78.png" alt="filename y exists, renamed"></p>
<h3 id="File-Metadata"><a href="#File-Metadata" class="headerlink" title="File Metadata"></a>File Metadata</h3><p><img src="/home/alex/图片/file metadata.png" alt="upload essful"></p>
<h3 id="File-Sharing"><a href="#File-Sharing" class="headerlink" title="File Sharing"></a>File Sharing</h3><p><img src="/home/alex/图片/fileSharing.png" alt="upload succesul"></p>
<p><img src="/home/alex/图片/2018-79.png" alt="filename ady exists, renamed"></p>
<h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p><img src="/home/alex/图片/output.png" alt="upload scessful"></p>
<p><img src="/home/alex/图片/2018-80.png" alt="filename aldy exists, renamed"></p>
<p>内核用三个相关的数据结构来表示打开的文件</p>
<p>1.每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的，每个打开的描述符表项指向文件表一个表项。</p>
<p>2.文件表。是所有进程共享的，保存当前文件位置，引用计数（当前指向该表项的描述符表项数），以及一个指向vnode表对应表项的指针</p>
<p>3.vnode表，所有进程共享</p>
<h3 id="I-O-Redirection"><a href="#I-O-Redirection" class="headerlink" title="I/O Redirection"></a>I/O Redirection</h3><p><img src="/home/alex/图片/ioredi.png" alt="upload cessful"></p>
<h4 id="steps-1"><a href="#steps-1" class="headerlink" title="steps 1"></a>steps 1</h4><p><img src="/home/alex/图片/steps1.png" alt="upload sucessful"></p>
<h4 id="steps-2"><a href="#steps-2" class="headerlink" title="steps 2"></a>steps 2</h4><p><img src="/home/alex/图片/samefile.png" alt="upload essful"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fd(5,0)</span><br></pre></td></tr></table></figure>
<p>就是把重定向标准输入到描述符5</p>
<h3 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h3><p><img src="/home/alex/图片/ggg.png" alt="upload succeful"></p>
<p>fd3重定向到了fd2，所以他们指向同样的open file table项，c2是第一个字符a，而c3在此基础上读下一个字符，所以是b。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/14/CSAPP-malloc-lab/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/14/CSAPP-malloc-lab/" itemprop="url">CSAPP-malloc lab</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-14T14:43:00+08:00">
                2018-12-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index">
                    <span itemprop="name">CSAPP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>所用策略：Segregated lists + best fits + explicit free list</p>
<p><img src="/home/alex/图片/disanwei.png" alt="upload sucssful"></p>
<p>堆的结构：<br>地址从上到下是从低到高<br><img src="/home/alex/图片/heap.png" alt="upload successful"></p>
<p><img src="/home/alex/图片/fenlishipei.png" alt="upload ful"></p>
<p>分离适配的原理：</p>
<p>allocator 维护一个空闲链表的数组，每个空闲链表是和一个大小类相关联的，被组织成某种类型的显式或者隐式链表，每个链表包含潜在的大小不同的块。</p>
<p>为了分配，要先确定请求的大小的类，并且对适当的空闲链表做首次适配，如果找到，就分割，并把剩余部分查到空闲链表。如果找不到，就搜索下一个更大的类，如果还是没有，就向操作系统请求额外的堆内存，然后从这个堆内存中分配出一个块，并把剩余部分放在适当的大小类中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/* single word (4) or double word (8) alignment */</span><br><span class="line">#define ALIGNMENT 8</span><br><span class="line"></span><br><span class="line">/* rounds up to the nearest multiple of ALIGNMENT */</span><br><span class="line">#define ALIGN(size) (((size) + (ALIGNMENT-1)) &amp; ~0x7)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#define WSIZE 4 //word and header/footer size</span><br><span class="line">#define DSIZE 8 //double word size (bytes)</span><br><span class="line"></span><br><span class="line">#define INITCHUNKSIZE (1&lt;&lt;6) //the size of extended heap </span><br><span class="line">#define CHUNKSIZE (1&lt;&lt;12) //extend heap </span><br><span class="line"></span><br><span class="line">#define MAX(x,y) ((x)&gt;(y))?(x):(y)</span><br><span class="line">#define MIN(x,y) ((x)&lt;(y))?(x):(y)</span><br><span class="line"></span><br><span class="line">#define PACK(size,alloc) ((size)|(alloc))</span><br><span class="line"></span><br><span class="line">//read and write a word at addr p</span><br><span class="line">#define GET(p) (*(unsigned int*)(p))</span><br><span class="line">#define PUT(p,val) (*(unsigned int*)(p) = (val))</span><br><span class="line"></span><br><span class="line">#define SET_PTR(p,ptr) (*(unsigned int*)(p) = (unsigned int)(ptr))</span><br><span class="line"></span><br><span class="line">#define GET_SIZE(p)  (GET(p)&amp;~0x7)</span><br><span class="line">#define GET_ALLOC(p)  (GET(p)&amp;0x1)</span><br><span class="line"></span><br><span class="line">//given block ptr bp,compute address of its header and footer</span><br><span class="line">#define HDRP(bp)  ((char*)(bp)-WSIZE)</span><br><span class="line">// (char*bp)+size -wsize= next&apos;s block&apos;s bp &apos;s position,-DSIZE,that means </span><br><span class="line">//  previous block&apos;s foot address</span><br><span class="line">#define FTRP(bp)  ((char*)(bp)+GET_SIZE(HDRP(bp))-DSIZE)</span><br><span class="line"></span><br><span class="line">#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE((char *)(bp)-WSIZE))</span><br><span class="line">#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp)-DSIZE))</span><br><span class="line"></span><br><span class="line">#define PRED_PTR(ptr) ((char*)(ptr))</span><br><span class="line">#define SUCC_PTR(ptr) ((char*)(ptr)+WSIZE)</span><br><span class="line"></span><br><span class="line">#define PRED(ptr) (*(char **)(ptr))</span><br><span class="line">#define SUCC(ptr) (*(char **)(SUCC_PTR(ptr)))</span><br><span class="line"></span><br><span class="line">#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))</span><br><span class="line">#define LIST_SIZE 16</span><br></pre></td></tr></table></figure>
<p>全局函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static void *extend_heap(size_t words);</span><br><span class="line">static void *coalesce(void *bp);</span><br><span class="line">static void *place(void *bp,size_t asize);</span><br><span class="line">static void insert(void *bp,size_t size);</span><br><span class="line">static void delete(void *bp);</span><br></pre></td></tr></table></figure></p>
<p>初始化列表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line"> * mm_init - initialize the malloc package.</span><br><span class="line"> */</span><br><span class="line">int mm_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    void *heap;</span><br><span class="line">    if((heap=mem_sbrk(4*WSIZE))==(void*)-1)</span><br><span class="line">        return -1;</span><br><span class="line">    </span><br><span class="line">    int idx;</span><br><span class="line">	</span><br><span class="line">    //initialize the list</span><br><span class="line">    for(idx=0;idx&lt;LIST_SIZE;idx++)&#123;</span><br><span class="line">        list[idx] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    //alignment padding</span><br><span class="line">    //按照上图堆的结构来初始化</span><br><span class="line">    PUT(heap,0);</span><br><span class="line">    PUT(heap+(1*WSIZE),PACK(DSIZE,1));  //prologue header</span><br><span class="line">    PUT(heap+(2*WSIZE),PACK(DSIZE,1)); //prologue footer</span><br><span class="line">    PUT(heap+(3*WSIZE),PACK(0,1)); //Epilogue header</span><br><span class="line"></span><br><span class="line">    if(extend_heap(INITCHUNKSIZE)==NULL)</span><br><span class="line">        return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">/* </span><br><span class="line"> * mm_malloc - Allocate a block by incrementing the brk pointer.</span><br><span class="line"> *     Always allocate a block whose size is a multiple of the alignment.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">void *mm_malloc(size_t size)</span><br><span class="line">&#123;</span><br><span class="line">    //ignore spurious requeses</span><br><span class="line">    if(size==0)</span><br><span class="line">        return NULL;</span><br><span class="line">    </span><br><span class="line">    if(size&lt;=DSIZE)</span><br><span class="line">        size = 2*DSIZE;</span><br><span class="line">    else</span><br><span class="line">        size = ALIGN(size+DSIZE);</span><br><span class="line"></span><br><span class="line">    int idx = 0;</span><br><span class="line">    size_t ssize = size;</span><br><span class="line">    void *ptr = NULL;</span><br><span class="line"></span><br><span class="line">    while(idx&lt;LIST_SIZE)&#123;</span><br><span class="line">		//链表类的大小分别是 1 1 2 4 8 16 32...</span><br><span class="line">        // 分别存储 &#123;0&#125;,&#123;1&#125;,&#123;2,3&#125;,&#123;4,5,6,7&#125;..</span><br><span class="line">        // 通过循环 ssize&gt;&gt;=1 与idx,找到该分配的</span><br><span class="line">        //字节大小所在的链表</span><br><span class="line">        //然后再内嵌一个循环，在这个链表中寻找大小适			//合的pointer</span><br><span class="line">        if((ssize&lt;=1)&amp;&amp;(list[idx]!=NULL))&#123;</span><br><span class="line">            ptr = list[idx];</span><br><span class="line">            while(ptr&amp;&amp;((size&gt;GET_SIZE(HDRP(ptr)))))&#123;</span><br><span class="line">                ptr = PRED(ptr);</span><br><span class="line">            &#125;</span><br><span class="line">            //如果找到了就break</span><br><span class="line">            if(ptr!=NULL)</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        ssize&gt;&gt;=1;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //如果找不到，向系统申请额外的堆内存</span><br><span class="line">    if(ptr==NULL)&#123;</span><br><span class="line">        int extendsize = MAX(size,CHUNKSIZE);</span><br><span class="line">        if((ptr=extend_heap(extendsize))==NULL)</span><br><span class="line">            return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //在free块中allocate size大小的块</span><br><span class="line">    ptr = place(ptr,size);</span><br><span class="line"></span><br><span class="line">    return ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void mm_free(void *ptr)</span><br><span class="line">&#123;</span><br><span class="line">    size_t size = GET_SIZE(HDRP(ptr));</span><br><span class="line"></span><br><span class="line">	//把该块头脚末位都标注为0，说明这一块是free</span><br><span class="line">    PUT(HDRP(ptr), PACK(size, 0));</span><br><span class="line">    PUT(FTRP(ptr), PACK(size, 0));</span><br><span class="line"></span><br><span class="line">    /* 插入分离空闲链表 */</span><br><span class="line">    insert_node(ptr, size);</span><br><span class="line">    /* 合并 */</span><br><span class="line">    coalesce(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://AlexanderChiuluvB.github.io/2018/12/13/并发与并行区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alex Chiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/header.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alex Chiu">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/13/并发与并行区别/" itemprop="url">并发与并行区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-13T17:15:32+08:00">
                2018-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://www.cnblogs.com/liqiuhao/p/8082246.html" target="_blank" rel="noopener">https://www.cnblogs.com/liqiuhao/p/8082246.html</a></p>
<h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>程序加载到内存中执行，（这时变成进程），操作系统会通过虚拟内存机制，通过让它和其他进程分时段占用CPU，使其产生独占CPU的假象。在CPU执行一个进程的指令的时候，被执行的许多指令连接起来，就构成了逻辑控制流。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>就是两个逻辑控制流交替进行</p>
<p><img src="/home/alex/图片/bingfa.png" alt="upload succe"></p>
<p>A与B，A与C并发</p>
<p><strong><em>并发与CPU个数或者计算机个数无关</em></strong></p>
<h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p><strong><em>如果两个逻辑控制流同时（一个cpu时段内）在不同的cpu（多核）或者计算机上被执行，我们就称其为并行。</em></strong></p>
<p><img src="/home/alex/图片/2018-75.png" alt="filename already existsmed"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/header.jpg"
                alt="Alex Chiu" />
            
              <p class="site-author-name" itemprop="name">Alex Chiu</p>
              <p class="site-description motion-element" itemprop="description">Alex's personal blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">52</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alex Chiu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
